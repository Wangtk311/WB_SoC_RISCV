
..\linuxbuild\bin/bootrom_tests.elf:     file format elf64-littleriscv


Disassembly of section .text:

0000000000010000 <_ftext>:
  .globl interrupt_m_timer_c
  .globl interrupt_s_external_c
  .globl interrupt_m_external_c

_start:
  j reset_vector
   10000:	0380006f          	j	10038 <reset_vector>

0000000000010004 <trap_table>:
trap_table:
  j trap_entry
   10004:	7500006f          	j	10754 <trap_entry>
/* if mtvec is configured as a vectorized interrupt handlers */
  j interrupt_s_software_entry  # 1 Supervisor software interrupt
   10008:	17c0006f          	j	10184 <interrupt_s_software_entry>
  j bad_irq                     # 2 Reserved
   1000c:	0280006f          	j	10034 <bad_irq>
  j interrupt_m_software_entry  # 3 Machine software interrupt
   10010:	26c0006f          	j	1027c <interrupt_m_software_entry>
  j bad_irq                     # 4 User timer interrupt
   10014:	0200006f          	j	10034 <bad_irq>
  j interrupt_s_timer_entry     # 5 Supervisor timer interrupt
   10018:	35c0006f          	j	10374 <interrupt_s_timer_entry>
  j bad_irq                     # 6 Reserved
   1001c:	0180006f          	j	10034 <bad_irq>
  j interrupt_m_timer_entry     # 7 Machine timer interrupt
   10020:	44c0006f          	j	1046c <interrupt_m_timer_entry>
  j bad_irq                     # 8 User external interrupt
   10024:	0100006f          	j	10034 <bad_irq>
  j interrupt_s_external_entry  # 9 Supervisor external interrupt
   10028:	53c0006f          	j	10564 <interrupt_s_external_entry>
  j bad_irq                     # 10 Reserved
   1002c:	0080006f          	j	10034 <bad_irq>
  j interrupt_m_external_entry  # 11 Machine external interrupt
   10030:	62c0006f          	j	1065c <interrupt_m_external_entry>

0000000000010034 <bad_irq>:

bad_irq:
  j bad_irq
   10034:	0000006f          	j	10034 <bad_irq>

0000000000010038 <reset_vector>:

reset_vector:
  li  x1, 0
   10038:	00000093          	li	ra,0
  li  x2, 0
   1003c:	00000113          	li	sp,0
  li  x3, 0
   10040:	00000193          	li	gp,0
  li  x4, 0
   10044:	00000213          	li	tp,0
  li  x5, 0
   10048:	00000293          	li	t0,0
  li  x6, 0
   1004c:	00000313          	li	t1,0
  li  x7, 0
   10050:	00000393          	li	t2,0
  li  x8, 0
   10054:	00000413          	li	s0,0
  li  x9, 0
   10058:	00000493          	li	s1,0
  li  x10,0
   1005c:	00000513          	li	a0,0
  li  x11,0
   10060:	00000593          	li	a1,0
  li  x12,0
   10064:	00000613          	li	a2,0
  li  x13,0
   10068:	00000693          	li	a3,0
  li  x14,0
   1006c:	00000713          	li	a4,0
  li  x15,0
   10070:	00000793          	li	a5,0
  li  x16,0
   10074:	00000813          	li	a6,0
  li  x17,0
   10078:	00000893          	li	a7,0
  li  x18,0
   1007c:	00000913          	li	s2,0
  li  x19,0
   10080:	00000993          	li	s3,0
  li  x20,0
   10084:	00000a13          	li	s4,0
  li  x21,0
   10088:	00000a93          	li	s5,0
  li  x22,0
   1008c:	00000b13          	li	s6,0
  li  x23,0
   10090:	00000b93          	li	s7,0
  li  x24,0
   10094:	00000c13          	li	s8,0
  li  x25,0
   10098:	00000c93          	li	s9,0
  li  x26,0
   1009c:	00000d13          	li	s10,0
  li  x27,0
   100a0:	00000d93          	li	s11,0
  li  x28,0
   100a4:	00000e13          	li	t3,0
  li  x29,0
   100a8:	00000e93          	li	t4,0
  li  x30,0
   100ac:	00000f13          	li	t5,0
  li  x31,0
   100b0:	00000f93          	li	t6,0
# intialization when HW FPU enabled
#ifdef FPU_ENABLED
  fssr    x0
   100b4:	00301073          	fssr	zero
  fmv.d.x f0, x0
   100b8:	f2000053          	fmv.d.x	ft0,zero
  fmv.d.x f1, x0
   100bc:	f20000d3          	fmv.d.x	ft1,zero
  fmv.d.x f2, x0
   100c0:	f2000153          	fmv.d.x	ft2,zero
  fmv.d.x f3, x0
   100c4:	f20001d3          	fmv.d.x	ft3,zero
  fmv.d.x f4, x0
   100c8:	f2000253          	fmv.d.x	ft4,zero
  fmv.d.x f5, x0
   100cc:	f20002d3          	fmv.d.x	ft5,zero
  fmv.d.x f6, x0
   100d0:	f2000353          	fmv.d.x	ft6,zero
  fmv.d.x f7, x0
   100d4:	f20003d3          	fmv.d.x	ft7,zero
  fmv.d.x f8, x0
   100d8:	f2000453          	fmv.d.x	fs0,zero
  fmv.d.x f9, x0
   100dc:	f20004d3          	fmv.d.x	fs1,zero
  fmv.d.x f10,x0
   100e0:	f2000553          	fmv.d.x	fa0,zero
  fmv.d.x f11,x0
   100e4:	f20005d3          	fmv.d.x	fa1,zero
  fmv.d.x f12,x0
   100e8:	f2000653          	fmv.d.x	fa2,zero
  fmv.d.x f13,x0
   100ec:	f20006d3          	fmv.d.x	fa3,zero
  fmv.d.x f14,x0
   100f0:	f2000753          	fmv.d.x	fa4,zero
  fmv.d.x f15,x0
   100f4:	f20007d3          	fmv.d.x	fa5,zero
  fmv.d.x f16,x0
   100f8:	f2000853          	fmv.d.x	fa6,zero
  fmv.d.x f17,x0
   100fc:	f20008d3          	fmv.d.x	fa7,zero
  fmv.d.x f18,x0
   10100:	f2000953          	fmv.d.x	fs2,zero
  fmv.d.x f19,x0
   10104:	f20009d3          	fmv.d.x	fs3,zero
  fmv.d.x f20,x0
   10108:	f2000a53          	fmv.d.x	fs4,zero
  fmv.d.x f21,x0
   1010c:	f2000ad3          	fmv.d.x	fs5,zero
  fmv.d.x f22,x0
   10110:	f2000b53          	fmv.d.x	fs6,zero
  fmv.d.x f23,x0
   10114:	f2000bd3          	fmv.d.x	fs7,zero
  fmv.d.x f24,x0
   10118:	f2000c53          	fmv.d.x	fs8,zero
  fmv.d.x f25,x0
   1011c:	f2000cd3          	fmv.d.x	fs9,zero
  fmv.d.x f26,x0
   10120:	f2000d53          	fmv.d.x	fs10,zero
  fmv.d.x f27,x0
   10124:	f2000dd3          	fmv.d.x	fs11,zero
  fmv.d.x f28,x0
   10128:	f2000e53          	fmv.d.x	ft8,zero
  fmv.d.x f29,x0
   1012c:	f2000ed3          	fmv.d.x	ft9,zero
  fmv.d.x f30,x0
   10130:	f2000f53          	fmv.d.x	ft10,zero
  fmv.d.x f31,x0
   10134:	f2000fd3          	fmv.d.x	ft11,zero
#endif
  csrw mscratch, x0
   10138:	34001073          	csrw	mscratch,zero

  ##! init mtvec register in vector mode (MODE=0x1)
  la t0, trap_table
   1013c:	00000297          	auipc	t0,0x0
   10140:	ec828293          	addi	t0,t0,-312 # 10004 <trap_table>
  or t0, t0, 0x1
   10144:	0012e293          	ori	t0,t0,1
  csrw mtvec, t0
   10148:	30529073          	csrw	mtvec,t0

  ##! get core id
  csrr a0, mhartid            # a0 <= MHARTID value
   1014c:	f1402573          	csrr	a0,mhartid
#define SRAM_BASE_ADDR  0x08000000
#define SRAM_SIZE_BYTES (1<<18)
#define STACK_PER_CORE_BYTES 4096
#define CFG_CPU_MAX 4

  li  sp, SRAM_BASE_ADDR+SRAM_SIZE_BYTES
   10150:	08040137          	lui	sp,0x8040

  # Initialze stack pointer for each cpu
  li  a1, (CFG_CPU_MAX - 1)
   10154:	00300593          	li	a1,3
  sub a0, a1, a0                  # (CFG_CPU_MAX - 1 - hartid)
   10158:	40a58533          	sub	a0,a1,a0
  li  a1, STACK_PER_CORE_BYTES
   1015c:	000015b7          	lui	a1,0x1
  mul a0, a0, a1
   10160:	02b50533          	mul	a0,a0,a1
  sub sp, sp, a0
   10164:	40a10133          	sub	sp,sp,a0
  # allocate special 256B region in a stack to save/restore context
  addi sp, sp,-256
   10168:	f0010113          	addi	sp,sp,-256 # 803ff00 <_end+0x8020664>
  csrw 0x7b3, sp          # save dedicated stack region into dscratch1 register to run riscv-tests
   1016c:	7b311073          	csrw	0x7b3,sp
  mv tp, sp               # or use dedicated tp for context saving
   10170:	00010213          	mv	tp,sp


  # check Hart ID
  csrr a0, mhartid            # a0 <= MHARTID value
   10174:	f1402573          	csrr	a0,mhartid
  beqz a0, init0
   10178:	00050463          	beqz	a0,10180 <_mbist_ram_exit>
  j end_init0
   1017c:	0040006f          	j	10180 <_mbist_ram_exit>

0000000000010180 <_mbist_ram_exit>:
  #jal _mbist_ram
_mbist_ram_exit:
end_init0:

  # run tests in machine mode:
  jal main
   10180:	4bd090ef          	jal	ra,19e3c <main>

0000000000010184 <interrupt_s_software_entry>:
  ## Never reach here



interrupt_s_software_entry:
  _save_context(tp)
   10184:	00123023          	sd	ra,0(tp) # 0 <_ftext-0x10000>
   10188:	00823423          	sd	s0,8(tp) # 8 <_ftext-0xfff8>
   1018c:	00923823          	sd	s1,16(tp) # 10 <_ftext-0xfff0>
   10190:	01223c23          	sd	s2,24(tp) # 18 <_ftext-0xffe8>
   10194:	03323023          	sd	s3,32(tp) # 20 <_ftext-0xffe0>
   10198:	03423423          	sd	s4,40(tp) # 28 <_ftext-0xffd8>
   1019c:	03523823          	sd	s5,48(tp) # 30 <_ftext-0xffd0>
   101a0:	03623c23          	sd	s6,56(tp) # 38 <_ftext-0xffc8>
   101a4:	05723023          	sd	s7,64(tp) # 40 <_ftext-0xffc0>
   101a8:	05823423          	sd	s8,72(tp) # 48 <_ftext-0xffb8>
   101ac:	05923823          	sd	s9,80(tp) # 50 <_ftext-0xffb0>
   101b0:	05a23c23          	sd	s10,88(tp) # 58 <_ftext-0xffa8>
   101b4:	07b23023          	sd	s11,96(tp) # 60 <_ftext-0xffa0>
   101b8:	06223423          	sd	sp,104(tp) # 68 <_ftext-0xff98>
   101bc:	07023c23          	sd	a6,120(tp) # 78 <_ftext-0xff88>
   101c0:	09123023          	sd	a7,128(tp) # 80 <_ftext-0xff80>
   101c4:	08a23423          	sd	a0,136(tp) # 88 <_ftext-0xff78>
   101c8:	08b23823          	sd	a1,144(tp) # 90 <_ftext-0xff70>
   101cc:	08c23c23          	sd	a2,152(tp) # 98 <_ftext-0xff68>
   101d0:	0ad23023          	sd	a3,160(tp) # a0 <_ftext-0xff60>
   101d4:	0ae23423          	sd	a4,168(tp) # a8 <_ftext-0xff58>
   101d8:	0af23823          	sd	a5,176(tp) # b0 <_ftext-0xff50>
   101dc:	0b023c23          	sd	a6,184(tp) # b8 <_ftext-0xff48>
   101e0:	0d123023          	sd	a7,192(tp) # c0 <_ftext-0xff40>
   101e4:	0c523423          	sd	t0,200(tp) # c8 <_ftext-0xff38>
   101e8:	0c623823          	sd	t1,208(tp) # d0 <_ftext-0xff30>
   101ec:	0c723c23          	sd	t2,216(tp) # d8 <_ftext-0xff28>
   101f0:	0fc23023          	sd	t3,224(tp) # e0 <_ftext-0xff20>
   101f4:	0fd23423          	sd	t4,232(tp) # e8 <_ftext-0xff18>
   101f8:	0e323823          	sd	gp,240(tp) # f0 <_ftext-0xff10>
  jal interrupt_s_software_c
   101fc:	230010ef          	jal	ra,1142c <interrupt_s_software_c>
  _restore_context(tp)
   10200:	00023083          	ld	ra,0(tp) # 0 <_ftext-0x10000>
   10204:	00823403          	ld	s0,8(tp) # 8 <_ftext-0xfff8>
   10208:	01023483          	ld	s1,16(tp) # 10 <_ftext-0xfff0>
   1020c:	01823903          	ld	s2,24(tp) # 18 <_ftext-0xffe8>
   10210:	02023983          	ld	s3,32(tp) # 20 <_ftext-0xffe0>
   10214:	02823a03          	ld	s4,40(tp) # 28 <_ftext-0xffd8>
   10218:	03023a83          	ld	s5,48(tp) # 30 <_ftext-0xffd0>
   1021c:	03823b03          	ld	s6,56(tp) # 38 <_ftext-0xffc8>
   10220:	04023b83          	ld	s7,64(tp) # 40 <_ftext-0xffc0>
   10224:	04823c03          	ld	s8,72(tp) # 48 <_ftext-0xffb8>
   10228:	05023c83          	ld	s9,80(tp) # 50 <_ftext-0xffb0>
   1022c:	05823d03          	ld	s10,88(tp) # 58 <_ftext-0xffa8>
   10230:	06023d83          	ld	s11,96(tp) # 60 <_ftext-0xffa0>
   10234:	06823103          	ld	sp,104(tp) # 68 <_ftext-0xff98>
   10238:	07823803          	ld	a6,120(tp) # 78 <_ftext-0xff88>
   1023c:	08023883          	ld	a7,128(tp) # 80 <_ftext-0xff80>
   10240:	08823503          	ld	a0,136(tp) # 88 <_ftext-0xff78>
   10244:	09023583          	ld	a1,144(tp) # 90 <_ftext-0xff70>
   10248:	09823603          	ld	a2,152(tp) # 98 <_ftext-0xff68>
   1024c:	0a023683          	ld	a3,160(tp) # a0 <_ftext-0xff60>
   10250:	0a823703          	ld	a4,168(tp) # a8 <_ftext-0xff58>
   10254:	0b023783          	ld	a5,176(tp) # b0 <_ftext-0xff50>
   10258:	0b823803          	ld	a6,184(tp) # b8 <_ftext-0xff48>
   1025c:	0c023883          	ld	a7,192(tp) # c0 <_ftext-0xff40>
   10260:	0c823283          	ld	t0,200(tp) # c8 <_ftext-0xff38>
   10264:	0d023303          	ld	t1,208(tp) # d0 <_ftext-0xff30>
   10268:	0d823383          	ld	t2,216(tp) # d8 <_ftext-0xff28>
   1026c:	0e023e03          	ld	t3,224(tp) # e0 <_ftext-0xff20>
   10270:	0e823e83          	ld	t4,232(tp) # e8 <_ftext-0xff18>
   10274:	0f023183          	ld	gp,240(tp) # f0 <_ftext-0xff10>
  sret
   10278:	10200073          	sret

000000000001027c <interrupt_m_software_entry>:

interrupt_m_software_entry:
  _save_context(tp)
   1027c:	00123023          	sd	ra,0(tp) # 0 <_ftext-0x10000>
   10280:	00823423          	sd	s0,8(tp) # 8 <_ftext-0xfff8>
   10284:	00923823          	sd	s1,16(tp) # 10 <_ftext-0xfff0>
   10288:	01223c23          	sd	s2,24(tp) # 18 <_ftext-0xffe8>
   1028c:	03323023          	sd	s3,32(tp) # 20 <_ftext-0xffe0>
   10290:	03423423          	sd	s4,40(tp) # 28 <_ftext-0xffd8>
   10294:	03523823          	sd	s5,48(tp) # 30 <_ftext-0xffd0>
   10298:	03623c23          	sd	s6,56(tp) # 38 <_ftext-0xffc8>
   1029c:	05723023          	sd	s7,64(tp) # 40 <_ftext-0xffc0>
   102a0:	05823423          	sd	s8,72(tp) # 48 <_ftext-0xffb8>
   102a4:	05923823          	sd	s9,80(tp) # 50 <_ftext-0xffb0>
   102a8:	05a23c23          	sd	s10,88(tp) # 58 <_ftext-0xffa8>
   102ac:	07b23023          	sd	s11,96(tp) # 60 <_ftext-0xffa0>
   102b0:	06223423          	sd	sp,104(tp) # 68 <_ftext-0xff98>
   102b4:	07023c23          	sd	a6,120(tp) # 78 <_ftext-0xff88>
   102b8:	09123023          	sd	a7,128(tp) # 80 <_ftext-0xff80>
   102bc:	08a23423          	sd	a0,136(tp) # 88 <_ftext-0xff78>
   102c0:	08b23823          	sd	a1,144(tp) # 90 <_ftext-0xff70>
   102c4:	08c23c23          	sd	a2,152(tp) # 98 <_ftext-0xff68>
   102c8:	0ad23023          	sd	a3,160(tp) # a0 <_ftext-0xff60>
   102cc:	0ae23423          	sd	a4,168(tp) # a8 <_ftext-0xff58>
   102d0:	0af23823          	sd	a5,176(tp) # b0 <_ftext-0xff50>
   102d4:	0b023c23          	sd	a6,184(tp) # b8 <_ftext-0xff48>
   102d8:	0d123023          	sd	a7,192(tp) # c0 <_ftext-0xff40>
   102dc:	0c523423          	sd	t0,200(tp) # c8 <_ftext-0xff38>
   102e0:	0c623823          	sd	t1,208(tp) # d0 <_ftext-0xff30>
   102e4:	0c723c23          	sd	t2,216(tp) # d8 <_ftext-0xff28>
   102e8:	0fc23023          	sd	t3,224(tp) # e0 <_ftext-0xff20>
   102ec:	0fd23423          	sd	t4,232(tp) # e8 <_ftext-0xff18>
   102f0:	0e323823          	sd	gp,240(tp) # f0 <_ftext-0xff10>
  jal interrupt_m_software_c
   102f4:	154010ef          	jal	ra,11448 <interrupt_m_software_c>
  _restore_context(tp)
   102f8:	00023083          	ld	ra,0(tp) # 0 <_ftext-0x10000>
   102fc:	00823403          	ld	s0,8(tp) # 8 <_ftext-0xfff8>
   10300:	01023483          	ld	s1,16(tp) # 10 <_ftext-0xfff0>
   10304:	01823903          	ld	s2,24(tp) # 18 <_ftext-0xffe8>
   10308:	02023983          	ld	s3,32(tp) # 20 <_ftext-0xffe0>
   1030c:	02823a03          	ld	s4,40(tp) # 28 <_ftext-0xffd8>
   10310:	03023a83          	ld	s5,48(tp) # 30 <_ftext-0xffd0>
   10314:	03823b03          	ld	s6,56(tp) # 38 <_ftext-0xffc8>
   10318:	04023b83          	ld	s7,64(tp) # 40 <_ftext-0xffc0>
   1031c:	04823c03          	ld	s8,72(tp) # 48 <_ftext-0xffb8>
   10320:	05023c83          	ld	s9,80(tp) # 50 <_ftext-0xffb0>
   10324:	05823d03          	ld	s10,88(tp) # 58 <_ftext-0xffa8>
   10328:	06023d83          	ld	s11,96(tp) # 60 <_ftext-0xffa0>
   1032c:	06823103          	ld	sp,104(tp) # 68 <_ftext-0xff98>
   10330:	07823803          	ld	a6,120(tp) # 78 <_ftext-0xff88>
   10334:	08023883          	ld	a7,128(tp) # 80 <_ftext-0xff80>
   10338:	08823503          	ld	a0,136(tp) # 88 <_ftext-0xff78>
   1033c:	09023583          	ld	a1,144(tp) # 90 <_ftext-0xff70>
   10340:	09823603          	ld	a2,152(tp) # 98 <_ftext-0xff68>
   10344:	0a023683          	ld	a3,160(tp) # a0 <_ftext-0xff60>
   10348:	0a823703          	ld	a4,168(tp) # a8 <_ftext-0xff58>
   1034c:	0b023783          	ld	a5,176(tp) # b0 <_ftext-0xff50>
   10350:	0b823803          	ld	a6,184(tp) # b8 <_ftext-0xff48>
   10354:	0c023883          	ld	a7,192(tp) # c0 <_ftext-0xff40>
   10358:	0c823283          	ld	t0,200(tp) # c8 <_ftext-0xff38>
   1035c:	0d023303          	ld	t1,208(tp) # d0 <_ftext-0xff30>
   10360:	0d823383          	ld	t2,216(tp) # d8 <_ftext-0xff28>
   10364:	0e023e03          	ld	t3,224(tp) # e0 <_ftext-0xff20>
   10368:	0e823e83          	ld	t4,232(tp) # e8 <_ftext-0xff18>
   1036c:	0f023183          	ld	gp,240(tp) # f0 <_ftext-0xff10>
  mret
   10370:	30200073          	mret

0000000000010374 <interrupt_s_timer_entry>:


interrupt_s_timer_entry:
  _save_context(tp)
   10374:	00123023          	sd	ra,0(tp) # 0 <_ftext-0x10000>
   10378:	00823423          	sd	s0,8(tp) # 8 <_ftext-0xfff8>
   1037c:	00923823          	sd	s1,16(tp) # 10 <_ftext-0xfff0>
   10380:	01223c23          	sd	s2,24(tp) # 18 <_ftext-0xffe8>
   10384:	03323023          	sd	s3,32(tp) # 20 <_ftext-0xffe0>
   10388:	03423423          	sd	s4,40(tp) # 28 <_ftext-0xffd8>
   1038c:	03523823          	sd	s5,48(tp) # 30 <_ftext-0xffd0>
   10390:	03623c23          	sd	s6,56(tp) # 38 <_ftext-0xffc8>
   10394:	05723023          	sd	s7,64(tp) # 40 <_ftext-0xffc0>
   10398:	05823423          	sd	s8,72(tp) # 48 <_ftext-0xffb8>
   1039c:	05923823          	sd	s9,80(tp) # 50 <_ftext-0xffb0>
   103a0:	05a23c23          	sd	s10,88(tp) # 58 <_ftext-0xffa8>
   103a4:	07b23023          	sd	s11,96(tp) # 60 <_ftext-0xffa0>
   103a8:	06223423          	sd	sp,104(tp) # 68 <_ftext-0xff98>
   103ac:	07023c23          	sd	a6,120(tp) # 78 <_ftext-0xff88>
   103b0:	09123023          	sd	a7,128(tp) # 80 <_ftext-0xff80>
   103b4:	08a23423          	sd	a0,136(tp) # 88 <_ftext-0xff78>
   103b8:	08b23823          	sd	a1,144(tp) # 90 <_ftext-0xff70>
   103bc:	08c23c23          	sd	a2,152(tp) # 98 <_ftext-0xff68>
   103c0:	0ad23023          	sd	a3,160(tp) # a0 <_ftext-0xff60>
   103c4:	0ae23423          	sd	a4,168(tp) # a8 <_ftext-0xff58>
   103c8:	0af23823          	sd	a5,176(tp) # b0 <_ftext-0xff50>
   103cc:	0b023c23          	sd	a6,184(tp) # b8 <_ftext-0xff48>
   103d0:	0d123023          	sd	a7,192(tp) # c0 <_ftext-0xff40>
   103d4:	0c523423          	sd	t0,200(tp) # c8 <_ftext-0xff38>
   103d8:	0c623823          	sd	t1,208(tp) # d0 <_ftext-0xff30>
   103dc:	0c723c23          	sd	t2,216(tp) # d8 <_ftext-0xff28>
   103e0:	0fc23023          	sd	t3,224(tp) # e0 <_ftext-0xff20>
   103e4:	0fd23423          	sd	t4,232(tp) # e8 <_ftext-0xff18>
   103e8:	0e323823          	sd	gp,240(tp) # f0 <_ftext-0xff10>
  jal interrupt_s_timer_c
   103ec:	0c4010ef          	jal	ra,114b0 <interrupt_s_timer_c>
  _restore_context(tp)
   103f0:	00023083          	ld	ra,0(tp) # 0 <_ftext-0x10000>
   103f4:	00823403          	ld	s0,8(tp) # 8 <_ftext-0xfff8>
   103f8:	01023483          	ld	s1,16(tp) # 10 <_ftext-0xfff0>
   103fc:	01823903          	ld	s2,24(tp) # 18 <_ftext-0xffe8>
   10400:	02023983          	ld	s3,32(tp) # 20 <_ftext-0xffe0>
   10404:	02823a03          	ld	s4,40(tp) # 28 <_ftext-0xffd8>
   10408:	03023a83          	ld	s5,48(tp) # 30 <_ftext-0xffd0>
   1040c:	03823b03          	ld	s6,56(tp) # 38 <_ftext-0xffc8>
   10410:	04023b83          	ld	s7,64(tp) # 40 <_ftext-0xffc0>
   10414:	04823c03          	ld	s8,72(tp) # 48 <_ftext-0xffb8>
   10418:	05023c83          	ld	s9,80(tp) # 50 <_ftext-0xffb0>
   1041c:	05823d03          	ld	s10,88(tp) # 58 <_ftext-0xffa8>
   10420:	06023d83          	ld	s11,96(tp) # 60 <_ftext-0xffa0>
   10424:	06823103          	ld	sp,104(tp) # 68 <_ftext-0xff98>
   10428:	07823803          	ld	a6,120(tp) # 78 <_ftext-0xff88>
   1042c:	08023883          	ld	a7,128(tp) # 80 <_ftext-0xff80>
   10430:	08823503          	ld	a0,136(tp) # 88 <_ftext-0xff78>
   10434:	09023583          	ld	a1,144(tp) # 90 <_ftext-0xff70>
   10438:	09823603          	ld	a2,152(tp) # 98 <_ftext-0xff68>
   1043c:	0a023683          	ld	a3,160(tp) # a0 <_ftext-0xff60>
   10440:	0a823703          	ld	a4,168(tp) # a8 <_ftext-0xff58>
   10444:	0b023783          	ld	a5,176(tp) # b0 <_ftext-0xff50>
   10448:	0b823803          	ld	a6,184(tp) # b8 <_ftext-0xff48>
   1044c:	0c023883          	ld	a7,192(tp) # c0 <_ftext-0xff40>
   10450:	0c823283          	ld	t0,200(tp) # c8 <_ftext-0xff38>
   10454:	0d023303          	ld	t1,208(tp) # d0 <_ftext-0xff30>
   10458:	0d823383          	ld	t2,216(tp) # d8 <_ftext-0xff28>
   1045c:	0e023e03          	ld	t3,224(tp) # e0 <_ftext-0xff20>
   10460:	0e823e83          	ld	t4,232(tp) # e8 <_ftext-0xff18>
   10464:	0f023183          	ld	gp,240(tp) # f0 <_ftext-0xff10>
  sret
   10468:	10200073          	sret

000000000001046c <interrupt_m_timer_entry>:

interrupt_m_timer_entry:
  _save_context(tp)
   1046c:	00123023          	sd	ra,0(tp) # 0 <_ftext-0x10000>
   10470:	00823423          	sd	s0,8(tp) # 8 <_ftext-0xfff8>
   10474:	00923823          	sd	s1,16(tp) # 10 <_ftext-0xfff0>
   10478:	01223c23          	sd	s2,24(tp) # 18 <_ftext-0xffe8>
   1047c:	03323023          	sd	s3,32(tp) # 20 <_ftext-0xffe0>
   10480:	03423423          	sd	s4,40(tp) # 28 <_ftext-0xffd8>
   10484:	03523823          	sd	s5,48(tp) # 30 <_ftext-0xffd0>
   10488:	03623c23          	sd	s6,56(tp) # 38 <_ftext-0xffc8>
   1048c:	05723023          	sd	s7,64(tp) # 40 <_ftext-0xffc0>
   10490:	05823423          	sd	s8,72(tp) # 48 <_ftext-0xffb8>
   10494:	05923823          	sd	s9,80(tp) # 50 <_ftext-0xffb0>
   10498:	05a23c23          	sd	s10,88(tp) # 58 <_ftext-0xffa8>
   1049c:	07b23023          	sd	s11,96(tp) # 60 <_ftext-0xffa0>
   104a0:	06223423          	sd	sp,104(tp) # 68 <_ftext-0xff98>
   104a4:	07023c23          	sd	a6,120(tp) # 78 <_ftext-0xff88>
   104a8:	09123023          	sd	a7,128(tp) # 80 <_ftext-0xff80>
   104ac:	08a23423          	sd	a0,136(tp) # 88 <_ftext-0xff78>
   104b0:	08b23823          	sd	a1,144(tp) # 90 <_ftext-0xff70>
   104b4:	08c23c23          	sd	a2,152(tp) # 98 <_ftext-0xff68>
   104b8:	0ad23023          	sd	a3,160(tp) # a0 <_ftext-0xff60>
   104bc:	0ae23423          	sd	a4,168(tp) # a8 <_ftext-0xff58>
   104c0:	0af23823          	sd	a5,176(tp) # b0 <_ftext-0xff50>
   104c4:	0b023c23          	sd	a6,184(tp) # b8 <_ftext-0xff48>
   104c8:	0d123023          	sd	a7,192(tp) # c0 <_ftext-0xff40>
   104cc:	0c523423          	sd	t0,200(tp) # c8 <_ftext-0xff38>
   104d0:	0c623823          	sd	t1,208(tp) # d0 <_ftext-0xff30>
   104d4:	0c723c23          	sd	t2,216(tp) # d8 <_ftext-0xff28>
   104d8:	0fc23023          	sd	t3,224(tp) # e0 <_ftext-0xff20>
   104dc:	0fd23423          	sd	t4,232(tp) # e8 <_ftext-0xff18>
   104e0:	0e323823          	sd	gp,240(tp) # f0 <_ftext-0xff10>
  jal interrupt_m_timer_c
   104e4:	7e9000ef          	jal	ra,114cc <interrupt_m_timer_c>
  _restore_context(tp)
   104e8:	00023083          	ld	ra,0(tp) # 0 <_ftext-0x10000>
   104ec:	00823403          	ld	s0,8(tp) # 8 <_ftext-0xfff8>
   104f0:	01023483          	ld	s1,16(tp) # 10 <_ftext-0xfff0>
   104f4:	01823903          	ld	s2,24(tp) # 18 <_ftext-0xffe8>
   104f8:	02023983          	ld	s3,32(tp) # 20 <_ftext-0xffe0>
   104fc:	02823a03          	ld	s4,40(tp) # 28 <_ftext-0xffd8>
   10500:	03023a83          	ld	s5,48(tp) # 30 <_ftext-0xffd0>
   10504:	03823b03          	ld	s6,56(tp) # 38 <_ftext-0xffc8>
   10508:	04023b83          	ld	s7,64(tp) # 40 <_ftext-0xffc0>
   1050c:	04823c03          	ld	s8,72(tp) # 48 <_ftext-0xffb8>
   10510:	05023c83          	ld	s9,80(tp) # 50 <_ftext-0xffb0>
   10514:	05823d03          	ld	s10,88(tp) # 58 <_ftext-0xffa8>
   10518:	06023d83          	ld	s11,96(tp) # 60 <_ftext-0xffa0>
   1051c:	06823103          	ld	sp,104(tp) # 68 <_ftext-0xff98>
   10520:	07823803          	ld	a6,120(tp) # 78 <_ftext-0xff88>
   10524:	08023883          	ld	a7,128(tp) # 80 <_ftext-0xff80>
   10528:	08823503          	ld	a0,136(tp) # 88 <_ftext-0xff78>
   1052c:	09023583          	ld	a1,144(tp) # 90 <_ftext-0xff70>
   10530:	09823603          	ld	a2,152(tp) # 98 <_ftext-0xff68>
   10534:	0a023683          	ld	a3,160(tp) # a0 <_ftext-0xff60>
   10538:	0a823703          	ld	a4,168(tp) # a8 <_ftext-0xff58>
   1053c:	0b023783          	ld	a5,176(tp) # b0 <_ftext-0xff50>
   10540:	0b823803          	ld	a6,184(tp) # b8 <_ftext-0xff48>
   10544:	0c023883          	ld	a7,192(tp) # c0 <_ftext-0xff40>
   10548:	0c823283          	ld	t0,200(tp) # c8 <_ftext-0xff38>
   1054c:	0d023303          	ld	t1,208(tp) # d0 <_ftext-0xff30>
   10550:	0d823383          	ld	t2,216(tp) # d8 <_ftext-0xff28>
   10554:	0e023e03          	ld	t3,224(tp) # e0 <_ftext-0xff20>
   10558:	0e823e83          	ld	t4,232(tp) # e8 <_ftext-0xff18>
   1055c:	0f023183          	ld	gp,240(tp) # f0 <_ftext-0xff10>
  mret
   10560:	30200073          	mret

0000000000010564 <interrupt_s_external_entry>:


interrupt_s_external_entry:
  _save_context(tp)
   10564:	00123023          	sd	ra,0(tp) # 0 <_ftext-0x10000>
   10568:	00823423          	sd	s0,8(tp) # 8 <_ftext-0xfff8>
   1056c:	00923823          	sd	s1,16(tp) # 10 <_ftext-0xfff0>
   10570:	01223c23          	sd	s2,24(tp) # 18 <_ftext-0xffe8>
   10574:	03323023          	sd	s3,32(tp) # 20 <_ftext-0xffe0>
   10578:	03423423          	sd	s4,40(tp) # 28 <_ftext-0xffd8>
   1057c:	03523823          	sd	s5,48(tp) # 30 <_ftext-0xffd0>
   10580:	03623c23          	sd	s6,56(tp) # 38 <_ftext-0xffc8>
   10584:	05723023          	sd	s7,64(tp) # 40 <_ftext-0xffc0>
   10588:	05823423          	sd	s8,72(tp) # 48 <_ftext-0xffb8>
   1058c:	05923823          	sd	s9,80(tp) # 50 <_ftext-0xffb0>
   10590:	05a23c23          	sd	s10,88(tp) # 58 <_ftext-0xffa8>
   10594:	07b23023          	sd	s11,96(tp) # 60 <_ftext-0xffa0>
   10598:	06223423          	sd	sp,104(tp) # 68 <_ftext-0xff98>
   1059c:	07023c23          	sd	a6,120(tp) # 78 <_ftext-0xff88>
   105a0:	09123023          	sd	a7,128(tp) # 80 <_ftext-0xff80>
   105a4:	08a23423          	sd	a0,136(tp) # 88 <_ftext-0xff78>
   105a8:	08b23823          	sd	a1,144(tp) # 90 <_ftext-0xff70>
   105ac:	08c23c23          	sd	a2,152(tp) # 98 <_ftext-0xff68>
   105b0:	0ad23023          	sd	a3,160(tp) # a0 <_ftext-0xff60>
   105b4:	0ae23423          	sd	a4,168(tp) # a8 <_ftext-0xff58>
   105b8:	0af23823          	sd	a5,176(tp) # b0 <_ftext-0xff50>
   105bc:	0b023c23          	sd	a6,184(tp) # b8 <_ftext-0xff48>
   105c0:	0d123023          	sd	a7,192(tp) # c0 <_ftext-0xff40>
   105c4:	0c523423          	sd	t0,200(tp) # c8 <_ftext-0xff38>
   105c8:	0c623823          	sd	t1,208(tp) # d0 <_ftext-0xff30>
   105cc:	0c723c23          	sd	t2,216(tp) # d8 <_ftext-0xff28>
   105d0:	0fc23023          	sd	t3,224(tp) # e0 <_ftext-0xff20>
   105d4:	0fd23423          	sd	t4,232(tp) # e8 <_ftext-0xff18>
   105d8:	0e323823          	sd	gp,240(tp) # f0 <_ftext-0xff10>
  jal interrupt_s_external_c
   105dc:	789000ef          	jal	ra,11564 <interrupt_s_external_c>
  _restore_context(tp)
   105e0:	00023083          	ld	ra,0(tp) # 0 <_ftext-0x10000>
   105e4:	00823403          	ld	s0,8(tp) # 8 <_ftext-0xfff8>
   105e8:	01023483          	ld	s1,16(tp) # 10 <_ftext-0xfff0>
   105ec:	01823903          	ld	s2,24(tp) # 18 <_ftext-0xffe8>
   105f0:	02023983          	ld	s3,32(tp) # 20 <_ftext-0xffe0>
   105f4:	02823a03          	ld	s4,40(tp) # 28 <_ftext-0xffd8>
   105f8:	03023a83          	ld	s5,48(tp) # 30 <_ftext-0xffd0>
   105fc:	03823b03          	ld	s6,56(tp) # 38 <_ftext-0xffc8>
   10600:	04023b83          	ld	s7,64(tp) # 40 <_ftext-0xffc0>
   10604:	04823c03          	ld	s8,72(tp) # 48 <_ftext-0xffb8>
   10608:	05023c83          	ld	s9,80(tp) # 50 <_ftext-0xffb0>
   1060c:	05823d03          	ld	s10,88(tp) # 58 <_ftext-0xffa8>
   10610:	06023d83          	ld	s11,96(tp) # 60 <_ftext-0xffa0>
   10614:	06823103          	ld	sp,104(tp) # 68 <_ftext-0xff98>
   10618:	07823803          	ld	a6,120(tp) # 78 <_ftext-0xff88>
   1061c:	08023883          	ld	a7,128(tp) # 80 <_ftext-0xff80>
   10620:	08823503          	ld	a0,136(tp) # 88 <_ftext-0xff78>
   10624:	09023583          	ld	a1,144(tp) # 90 <_ftext-0xff70>
   10628:	09823603          	ld	a2,152(tp) # 98 <_ftext-0xff68>
   1062c:	0a023683          	ld	a3,160(tp) # a0 <_ftext-0xff60>
   10630:	0a823703          	ld	a4,168(tp) # a8 <_ftext-0xff58>
   10634:	0b023783          	ld	a5,176(tp) # b0 <_ftext-0xff50>
   10638:	0b823803          	ld	a6,184(tp) # b8 <_ftext-0xff48>
   1063c:	0c023883          	ld	a7,192(tp) # c0 <_ftext-0xff40>
   10640:	0c823283          	ld	t0,200(tp) # c8 <_ftext-0xff38>
   10644:	0d023303          	ld	t1,208(tp) # d0 <_ftext-0xff30>
   10648:	0d823383          	ld	t2,216(tp) # d8 <_ftext-0xff28>
   1064c:	0e023e03          	ld	t3,224(tp) # e0 <_ftext-0xff20>
   10650:	0e823e83          	ld	t4,232(tp) # e8 <_ftext-0xff18>
   10654:	0f023183          	ld	gp,240(tp) # f0 <_ftext-0xff10>
  sret
   10658:	10200073          	sret

000000000001065c <interrupt_m_external_entry>:

interrupt_m_external_entry:
  _save_context(tp)
   1065c:	00123023          	sd	ra,0(tp) # 0 <_ftext-0x10000>
   10660:	00823423          	sd	s0,8(tp) # 8 <_ftext-0xfff8>
   10664:	00923823          	sd	s1,16(tp) # 10 <_ftext-0xfff0>
   10668:	01223c23          	sd	s2,24(tp) # 18 <_ftext-0xffe8>
   1066c:	03323023          	sd	s3,32(tp) # 20 <_ftext-0xffe0>
   10670:	03423423          	sd	s4,40(tp) # 28 <_ftext-0xffd8>
   10674:	03523823          	sd	s5,48(tp) # 30 <_ftext-0xffd0>
   10678:	03623c23          	sd	s6,56(tp) # 38 <_ftext-0xffc8>
   1067c:	05723023          	sd	s7,64(tp) # 40 <_ftext-0xffc0>
   10680:	05823423          	sd	s8,72(tp) # 48 <_ftext-0xffb8>
   10684:	05923823          	sd	s9,80(tp) # 50 <_ftext-0xffb0>
   10688:	05a23c23          	sd	s10,88(tp) # 58 <_ftext-0xffa8>
   1068c:	07b23023          	sd	s11,96(tp) # 60 <_ftext-0xffa0>
   10690:	06223423          	sd	sp,104(tp) # 68 <_ftext-0xff98>
   10694:	07023c23          	sd	a6,120(tp) # 78 <_ftext-0xff88>
   10698:	09123023          	sd	a7,128(tp) # 80 <_ftext-0xff80>
   1069c:	08a23423          	sd	a0,136(tp) # 88 <_ftext-0xff78>
   106a0:	08b23823          	sd	a1,144(tp) # 90 <_ftext-0xff70>
   106a4:	08c23c23          	sd	a2,152(tp) # 98 <_ftext-0xff68>
   106a8:	0ad23023          	sd	a3,160(tp) # a0 <_ftext-0xff60>
   106ac:	0ae23423          	sd	a4,168(tp) # a8 <_ftext-0xff58>
   106b0:	0af23823          	sd	a5,176(tp) # b0 <_ftext-0xff50>
   106b4:	0b023c23          	sd	a6,184(tp) # b8 <_ftext-0xff48>
   106b8:	0d123023          	sd	a7,192(tp) # c0 <_ftext-0xff40>
   106bc:	0c523423          	sd	t0,200(tp) # c8 <_ftext-0xff38>
   106c0:	0c623823          	sd	t1,208(tp) # d0 <_ftext-0xff30>
   106c4:	0c723c23          	sd	t2,216(tp) # d8 <_ftext-0xff28>
   106c8:	0fc23023          	sd	t3,224(tp) # e0 <_ftext-0xff20>
   106cc:	0fd23423          	sd	t4,232(tp) # e8 <_ftext-0xff18>
   106d0:	0e323823          	sd	gp,240(tp) # f0 <_ftext-0xff10>
  jal interrupt_m_external_c
   106d4:	725000ef          	jal	ra,115f8 <interrupt_m_external_c>
  _restore_context(tp)
   106d8:	00023083          	ld	ra,0(tp) # 0 <_ftext-0x10000>
   106dc:	00823403          	ld	s0,8(tp) # 8 <_ftext-0xfff8>
   106e0:	01023483          	ld	s1,16(tp) # 10 <_ftext-0xfff0>
   106e4:	01823903          	ld	s2,24(tp) # 18 <_ftext-0xffe8>
   106e8:	02023983          	ld	s3,32(tp) # 20 <_ftext-0xffe0>
   106ec:	02823a03          	ld	s4,40(tp) # 28 <_ftext-0xffd8>
   106f0:	03023a83          	ld	s5,48(tp) # 30 <_ftext-0xffd0>
   106f4:	03823b03          	ld	s6,56(tp) # 38 <_ftext-0xffc8>
   106f8:	04023b83          	ld	s7,64(tp) # 40 <_ftext-0xffc0>
   106fc:	04823c03          	ld	s8,72(tp) # 48 <_ftext-0xffb8>
   10700:	05023c83          	ld	s9,80(tp) # 50 <_ftext-0xffb0>
   10704:	05823d03          	ld	s10,88(tp) # 58 <_ftext-0xffa8>
   10708:	06023d83          	ld	s11,96(tp) # 60 <_ftext-0xffa0>
   1070c:	06823103          	ld	sp,104(tp) # 68 <_ftext-0xff98>
   10710:	07823803          	ld	a6,120(tp) # 78 <_ftext-0xff88>
   10714:	08023883          	ld	a7,128(tp) # 80 <_ftext-0xff80>
   10718:	08823503          	ld	a0,136(tp) # 88 <_ftext-0xff78>
   1071c:	09023583          	ld	a1,144(tp) # 90 <_ftext-0xff70>
   10720:	09823603          	ld	a2,152(tp) # 98 <_ftext-0xff68>
   10724:	0a023683          	ld	a3,160(tp) # a0 <_ftext-0xff60>
   10728:	0a823703          	ld	a4,168(tp) # a8 <_ftext-0xff58>
   1072c:	0b023783          	ld	a5,176(tp) # b0 <_ftext-0xff50>
   10730:	0b823803          	ld	a6,184(tp) # b8 <_ftext-0xff48>
   10734:	0c023883          	ld	a7,192(tp) # c0 <_ftext-0xff40>
   10738:	0c823283          	ld	t0,200(tp) # c8 <_ftext-0xff38>
   1073c:	0d023303          	ld	t1,208(tp) # d0 <_ftext-0xff30>
   10740:	0d823383          	ld	t2,216(tp) # d8 <_ftext-0xff28>
   10744:	0e023e03          	ld	t3,224(tp) # e0 <_ftext-0xff20>
   10748:	0e823e83          	ld	t4,232(tp) # e8 <_ftext-0xff18>
   1074c:	0f023183          	ld	gp,240(tp) # f0 <_ftext-0xff10>
  mret
   10750:	30200073          	mret

0000000000010754 <trap_entry>:

trap_entry:
  ## was it an interrupt or an exception?
  csrw mscratch, t5;
   10754:	340f1073          	csrw	mscratch,t5
  csrr t5, mcause;
   10758:	34202f73          	csrr	t5,mcause
  bgez t5, handle_exception;
   1075c:	100f5c63          	bgez	t5,10874 <handle_exception>

0000000000010760 <interrupt_entry>:

interrupt_entry:
  _save_context(tp)
   10760:	00123023          	sd	ra,0(tp) # 0 <_ftext-0x10000>
   10764:	00823423          	sd	s0,8(tp) # 8 <_ftext-0xfff8>
   10768:	00923823          	sd	s1,16(tp) # 10 <_ftext-0xfff0>
   1076c:	01223c23          	sd	s2,24(tp) # 18 <_ftext-0xffe8>
   10770:	03323023          	sd	s3,32(tp) # 20 <_ftext-0xffe0>
   10774:	03423423          	sd	s4,40(tp) # 28 <_ftext-0xffd8>
   10778:	03523823          	sd	s5,48(tp) # 30 <_ftext-0xffd0>
   1077c:	03623c23          	sd	s6,56(tp) # 38 <_ftext-0xffc8>
   10780:	05723023          	sd	s7,64(tp) # 40 <_ftext-0xffc0>
   10784:	05823423          	sd	s8,72(tp) # 48 <_ftext-0xffb8>
   10788:	05923823          	sd	s9,80(tp) # 50 <_ftext-0xffb0>
   1078c:	05a23c23          	sd	s10,88(tp) # 58 <_ftext-0xffa8>
   10790:	07b23023          	sd	s11,96(tp) # 60 <_ftext-0xffa0>
   10794:	06223423          	sd	sp,104(tp) # 68 <_ftext-0xff98>
   10798:	07023c23          	sd	a6,120(tp) # 78 <_ftext-0xff88>
   1079c:	09123023          	sd	a7,128(tp) # 80 <_ftext-0xff80>
   107a0:	08a23423          	sd	a0,136(tp) # 88 <_ftext-0xff78>
   107a4:	08b23823          	sd	a1,144(tp) # 90 <_ftext-0xff70>
   107a8:	08c23c23          	sd	a2,152(tp) # 98 <_ftext-0xff68>
   107ac:	0ad23023          	sd	a3,160(tp) # a0 <_ftext-0xff60>
   107b0:	0ae23423          	sd	a4,168(tp) # a8 <_ftext-0xff58>
   107b4:	0af23823          	sd	a5,176(tp) # b0 <_ftext-0xff50>
   107b8:	0b023c23          	sd	a6,184(tp) # b8 <_ftext-0xff48>
   107bc:	0d123023          	sd	a7,192(tp) # c0 <_ftext-0xff40>
   107c0:	0c523423          	sd	t0,200(tp) # c8 <_ftext-0xff38>
   107c4:	0c623823          	sd	t1,208(tp) # d0 <_ftext-0xff30>
   107c8:	0c723c23          	sd	t2,216(tp) # d8 <_ftext-0xff28>
   107cc:	0fc23023          	sd	t3,224(tp) # e0 <_ftext-0xff20>
   107d0:	0fd23423          	sd	t4,232(tp) # e8 <_ftext-0xff18>
   107d4:	0e323823          	sd	gp,240(tp) # f0 <_ftext-0xff10>
  ##       long handle_trap(long cause, long epc, long long regs[32])
  ##             a0 = argument 1: cause
  ##             a1 = argument 2: mepc
  ##             a2 = argument 3: pointer on stack
  ## @return     a0 New instruction pointer offset
  csrr a0, mcause
   107d8:	34202573          	csrr	a0,mcause
  csrr a1, mepc
   107dc:	341025f3          	csrr	a1,mepc
  sd a1,COOP_REG_TP(tp)
   107e0:	06b23823          	sd	a1,112(tp) # 70 <_ftext-0xff90>
  mv a2, sp
   107e4:	00010613          	mv	a2,sp
  jal interrupt_handler_c
   107e8:	6a5000ef          	jal	ra,1168c <interrupt_handler_c>

  # tp-offset in the context array is used to save mepc value. An it may be
  # modified by isr handler during preemtive task switching.
  ld t5,COOP_REG_TP(tp)
   107ec:	07023f03          	ld	t5,112(tp) # 70 <_ftext-0xff90>
  csrw mepc,t5
   107f0:	341f1073          	csrw	mepc,t5
  _restore_context(tp)
   107f4:	00023083          	ld	ra,0(tp) # 0 <_ftext-0x10000>
   107f8:	00823403          	ld	s0,8(tp) # 8 <_ftext-0xfff8>
   107fc:	01023483          	ld	s1,16(tp) # 10 <_ftext-0xfff0>
   10800:	01823903          	ld	s2,24(tp) # 18 <_ftext-0xffe8>
   10804:	02023983          	ld	s3,32(tp) # 20 <_ftext-0xffe0>
   10808:	02823a03          	ld	s4,40(tp) # 28 <_ftext-0xffd8>
   1080c:	03023a83          	ld	s5,48(tp) # 30 <_ftext-0xffd0>
   10810:	03823b03          	ld	s6,56(tp) # 38 <_ftext-0xffc8>
   10814:	04023b83          	ld	s7,64(tp) # 40 <_ftext-0xffc0>
   10818:	04823c03          	ld	s8,72(tp) # 48 <_ftext-0xffb8>
   1081c:	05023c83          	ld	s9,80(tp) # 50 <_ftext-0xffb0>
   10820:	05823d03          	ld	s10,88(tp) # 58 <_ftext-0xffa8>
   10824:	06023d83          	ld	s11,96(tp) # 60 <_ftext-0xffa0>
   10828:	06823103          	ld	sp,104(tp) # 68 <_ftext-0xff98>
   1082c:	07823803          	ld	a6,120(tp) # 78 <_ftext-0xff88>
   10830:	08023883          	ld	a7,128(tp) # 80 <_ftext-0xff80>
   10834:	08823503          	ld	a0,136(tp) # 88 <_ftext-0xff78>
   10838:	09023583          	ld	a1,144(tp) # 90 <_ftext-0xff70>
   1083c:	09823603          	ld	a2,152(tp) # 98 <_ftext-0xff68>
   10840:	0a023683          	ld	a3,160(tp) # a0 <_ftext-0xff60>
   10844:	0a823703          	ld	a4,168(tp) # a8 <_ftext-0xff58>
   10848:	0b023783          	ld	a5,176(tp) # b0 <_ftext-0xff50>
   1084c:	0b823803          	ld	a6,184(tp) # b8 <_ftext-0xff48>
   10850:	0c023883          	ld	a7,192(tp) # c0 <_ftext-0xff40>
   10854:	0c823283          	ld	t0,200(tp) # c8 <_ftext-0xff38>
   10858:	0d023303          	ld	t1,208(tp) # d0 <_ftext-0xff30>
   1085c:	0d823383          	ld	t2,216(tp) # d8 <_ftext-0xff28>
   10860:	0e023e03          	ld	t3,224(tp) # e0 <_ftext-0xff20>
   10864:	0e823e83          	ld	t4,232(tp) # e8 <_ftext-0xff18>
   10868:	0f023183          	ld	gp,240(tp) # f0 <_ftext-0xff10>
  csrr t5,mscratch
   1086c:	34002f73          	csrr	t5,mscratch
  mret
   10870:	30200073          	mret

0000000000010874 <handle_exception>:

handle_exception:
  _save_context(tp)
   10874:	00123023          	sd	ra,0(tp) # 0 <_ftext-0x10000>
   10878:	00823423          	sd	s0,8(tp) # 8 <_ftext-0xfff8>
   1087c:	00923823          	sd	s1,16(tp) # 10 <_ftext-0xfff0>
   10880:	01223c23          	sd	s2,24(tp) # 18 <_ftext-0xffe8>
   10884:	03323023          	sd	s3,32(tp) # 20 <_ftext-0xffe0>
   10888:	03423423          	sd	s4,40(tp) # 28 <_ftext-0xffd8>
   1088c:	03523823          	sd	s5,48(tp) # 30 <_ftext-0xffd0>
   10890:	03623c23          	sd	s6,56(tp) # 38 <_ftext-0xffc8>
   10894:	05723023          	sd	s7,64(tp) # 40 <_ftext-0xffc0>
   10898:	05823423          	sd	s8,72(tp) # 48 <_ftext-0xffb8>
   1089c:	05923823          	sd	s9,80(tp) # 50 <_ftext-0xffb0>
   108a0:	05a23c23          	sd	s10,88(tp) # 58 <_ftext-0xffa8>
   108a4:	07b23023          	sd	s11,96(tp) # 60 <_ftext-0xffa0>
   108a8:	06223423          	sd	sp,104(tp) # 68 <_ftext-0xff98>
   108ac:	07023c23          	sd	a6,120(tp) # 78 <_ftext-0xff88>
   108b0:	09123023          	sd	a7,128(tp) # 80 <_ftext-0xff80>
   108b4:	08a23423          	sd	a0,136(tp) # 88 <_ftext-0xff78>
   108b8:	08b23823          	sd	a1,144(tp) # 90 <_ftext-0xff70>
   108bc:	08c23c23          	sd	a2,152(tp) # 98 <_ftext-0xff68>
   108c0:	0ad23023          	sd	a3,160(tp) # a0 <_ftext-0xff60>
   108c4:	0ae23423          	sd	a4,168(tp) # a8 <_ftext-0xff58>
   108c8:	0af23823          	sd	a5,176(tp) # b0 <_ftext-0xff50>
   108cc:	0b023c23          	sd	a6,184(tp) # b8 <_ftext-0xff48>
   108d0:	0d123023          	sd	a7,192(tp) # c0 <_ftext-0xff40>
   108d4:	0c523423          	sd	t0,200(tp) # c8 <_ftext-0xff38>
   108d8:	0c623823          	sd	t1,208(tp) # d0 <_ftext-0xff30>
   108dc:	0c723c23          	sd	t2,216(tp) # d8 <_ftext-0xff28>
   108e0:	0fc23023          	sd	t3,224(tp) # e0 <_ftext-0xff20>
   108e4:	0fd23423          	sd	t4,232(tp) # e8 <_ftext-0xff18>
   108e8:	0e323823          	sd	gp,240(tp) # f0 <_ftext-0xff10>
  jal exception_handler_c
   108ec:	534000ef          	jal	ra,10e20 <exception_handler_c>
  _restore_context(tp)
   108f0:	00023083          	ld	ra,0(tp) # 0 <_ftext-0x10000>
   108f4:	00823403          	ld	s0,8(tp) # 8 <_ftext-0xfff8>
   108f8:	01023483          	ld	s1,16(tp) # 10 <_ftext-0xfff0>
   108fc:	01823903          	ld	s2,24(tp) # 18 <_ftext-0xffe8>
   10900:	02023983          	ld	s3,32(tp) # 20 <_ftext-0xffe0>
   10904:	02823a03          	ld	s4,40(tp) # 28 <_ftext-0xffd8>
   10908:	03023a83          	ld	s5,48(tp) # 30 <_ftext-0xffd0>
   1090c:	03823b03          	ld	s6,56(tp) # 38 <_ftext-0xffc8>
   10910:	04023b83          	ld	s7,64(tp) # 40 <_ftext-0xffc0>
   10914:	04823c03          	ld	s8,72(tp) # 48 <_ftext-0xffb8>
   10918:	05023c83          	ld	s9,80(tp) # 50 <_ftext-0xffb0>
   1091c:	05823d03          	ld	s10,88(tp) # 58 <_ftext-0xffa8>
   10920:	06023d83          	ld	s11,96(tp) # 60 <_ftext-0xffa0>
   10924:	06823103          	ld	sp,104(tp) # 68 <_ftext-0xff98>
   10928:	07823803          	ld	a6,120(tp) # 78 <_ftext-0xff88>
   1092c:	08023883          	ld	a7,128(tp) # 80 <_ftext-0xff80>
   10930:	08823503          	ld	a0,136(tp) # 88 <_ftext-0xff78>
   10934:	09023583          	ld	a1,144(tp) # 90 <_ftext-0xff70>
   10938:	09823603          	ld	a2,152(tp) # 98 <_ftext-0xff68>
   1093c:	0a023683          	ld	a3,160(tp) # a0 <_ftext-0xff60>
   10940:	0a823703          	ld	a4,168(tp) # a8 <_ftext-0xff58>
   10944:	0b023783          	ld	a5,176(tp) # b0 <_ftext-0xff50>
   10948:	0b823803          	ld	a6,184(tp) # b8 <_ftext-0xff48>
   1094c:	0c023883          	ld	a7,192(tp) # c0 <_ftext-0xff40>
   10950:	0c823283          	ld	t0,200(tp) # c8 <_ftext-0xff38>
   10954:	0d023303          	ld	t1,208(tp) # d0 <_ftext-0xff30>
   10958:	0d823383          	ld	t2,216(tp) # d8 <_ftext-0xff28>
   1095c:	0e023e03          	ld	t3,224(tp) # e0 <_ftext-0xff20>
   10960:	0e823e83          	ld	t4,232(tp) # e8 <_ftext-0xff18>
   10964:	0f023183          	ld	gp,240(tp) # f0 <_ftext-0xff10>
  csrr t5, mscratch;
   10968:	34002f73          	csrr	t5,mscratch
  mret
   1096c:	30200073          	mret
   10970:	0000                	unimp
	...

0000000000010974 <get_dev_bar>:
    uint64_t fwdbg3;            /// 0xfffff038: RW: FW debug register 3
    uint8_t cfg_table[(1 << 12) - 0x40];/// 0xfffff040: RO: PNP configuration
} pnp_map;


static uint64_t get_dev_bar(pnp_map *pnp, uint16_t vid, uint16_t did) {
   10974:	fb010113          	addi	sp,sp,-80
   10978:	04813423          	sd	s0,72(sp)
   1097c:	05010413          	addi	s0,sp,80
   10980:	faa43c23          	sd	a0,-72(s0)
   10984:	00058793          	mv	a5,a1
   10988:	00060713          	mv	a4,a2
   1098c:	faf41b23          	sh	a5,-74(s0)
   10990:	00070793          	mv	a5,a4
   10994:	faf41a23          	sh	a5,-76(s0)
    dev_cfg_type dcfg;
    int slots_total = (pnp->cfg >> 8) & 0xFF;
   10998:	fb843783          	ld	a5,-72(s0)
   1099c:	0087a783          	lw	a5,8(a5)
   109a0:	0087d79b          	srliw	a5,a5,0x8
   109a4:	0007879b          	sext.w	a5,a5
   109a8:	0007879b          	sext.w	a5,a5
   109ac:	0ff7f793          	andi	a5,a5,255
   109b0:	fef42223          	sw	a5,-28(s0)
    int off = 0;
   109b4:	fe042623          	sw	zero,-20(s0)

    // skip all masters
    for (int i = 0; i < slots_total; i++) {
   109b8:	fe042423          	sw	zero,-24(s0)
   109bc:	09c0006f          	j	10a58 <get_dev_bar+0xe4>
        dcfg = *(dev_cfg_type *)&pnp->cfg_table[off];
   109c0:	fec42783          	lw	a5,-20(s0)
   109c4:	04078793          	addi	a5,a5,64
   109c8:	fb843703          	ld	a4,-72(s0)
   109cc:	00f707b3          	add	a5,a4,a5
   109d0:	0007b703          	ld	a4,0(a5)
   109d4:	fce43023          	sd	a4,-64(s0)
   109d8:	0087b703          	ld	a4,8(a5)
   109dc:	fce43423          	sd	a4,-56(s0)
   109e0:	0107b703          	ld	a4,16(a5)
   109e4:	fce43823          	sd	a4,-48(s0)
   109e8:	0187b783          	ld	a5,24(a5)
   109ec:	fcf43c23          	sd	a5,-40(s0)
        off += sizeof(dcfg);
   109f0:	fec42783          	lw	a5,-20(s0)
   109f4:	0207879b          	addiw	a5,a5,32
   109f8:	0007879b          	sext.w	a5,a5
   109fc:	fef42623          	sw	a5,-20(s0)
        if (dcfg.u.descrtype != PNP_CFG_TYPE_SLAVE) {
   10a00:	fc144783          	lbu	a5,-63(s0)
   10a04:	0037f793          	andi	a5,a5,3
   10a08:	0ff7f793          	andi	a5,a5,255
   10a0c:	00078713          	mv	a4,a5
   10a10:	00200793          	li	a5,2
   10a14:	02f71a63          	bne	a4,a5,10a48 <get_dev_bar+0xd4>
            continue;
        }
        if (dcfg.u.vid == vid && dcfg.u.did == did) {
   10a18:	fc645783          	lhu	a5,-58(s0)
   10a1c:	fb645703          	lhu	a4,-74(s0)
   10a20:	0007071b          	sext.w	a4,a4
   10a24:	0007879b          	sext.w	a5,a5
   10a28:	02f71263          	bne	a4,a5,10a4c <get_dev_bar+0xd8>
   10a2c:	fc445783          	lhu	a5,-60(s0)
   10a30:	fb445703          	lhu	a4,-76(s0)
   10a34:	0007071b          	sext.w	a4,a4
   10a38:	0007879b          	sext.w	a5,a5
   10a3c:	00f71863          	bne	a4,a5,10a4c <get_dev_bar+0xd8>
            return dcfg.u.addr_start;
   10a40:	fd043783          	ld	a5,-48(s0)
   10a44:	02c0006f          	j	10a70 <get_dev_bar+0xfc>
            continue;
   10a48:	00000013          	nop
    for (int i = 0; i < slots_total; i++) {
   10a4c:	fe842783          	lw	a5,-24(s0)
   10a50:	0017879b          	addiw	a5,a5,1
   10a54:	fef42423          	sw	a5,-24(s0)
   10a58:	fe842703          	lw	a4,-24(s0)
   10a5c:	fe442783          	lw	a5,-28(s0)
   10a60:	0007071b          	sext.w	a4,a4
   10a64:	0007879b          	sext.w	a5,a5
   10a68:	f4f74ce3          	blt	a4,a5,109c0 <get_dev_bar+0x4c>
        }
    }

    return DEV_NONE;
   10a6c:	fff00793          	li	a5,-1
}
   10a70:	00078513          	mv	a0,a5
   10a74:	04813403          	ld	s0,72(sp)
   10a78:	05010113          	addi	sp,sp,80
   10a7c:	00008067          	ret

0000000000010a80 <mpu_region_total>:
    mpu_ctrl_wrbits_type bits;
    uint64_t value;
} mpu_ctrl_type;

// Read CSR_MPU_ctrl vendor specific register
static int mpu_region_total() {
   10a80:	fe010113          	addi	sp,sp,-32
   10a84:	00813c23          	sd	s0,24(sp)
   10a88:	02010413          	addi	s0,sp,32
    uint64_t val = 0;
   10a8c:	fe043423          	sd	zero,-24(s0)
    asm("csrr %0, 0xBC4" : "=r" (val));
   10a90:	bc4027f3          	csrr	a5,0xbc4
   10a94:	fef43423          	sd	a5,-24(s0)
    return (int)(val >> 8);
   10a98:	fe843783          	ld	a5,-24(s0)
   10a9c:	0087d793          	srli	a5,a5,0x8
   10aa0:	0007879b          	sext.w	a5,a5
}
   10aa4:	00078513          	mv	a0,a5
   10aa8:	01813403          	ld	s0,24(sp)
   10aac:	02010113          	addi	sp,sp,32
   10ab0:	00008067          	ret

0000000000010ab4 <mpu_disable_region>:

static void mpu_disable_region(int idx) {
   10ab4:	fd010113          	addi	sp,sp,-48
   10ab8:	02813423          	sd	s0,40(sp)
   10abc:	03010413          	addi	s0,sp,48
   10ac0:	00050793          	mv	a5,a0
   10ac4:	fcf42e23          	sw	a5,-36(s0)
    mpu_ctrl_type ctrl;
    ctrl.value = 0;
   10ac8:	fe043423          	sd	zero,-24(s0)
    ctrl.bits.IDX = idx;
   10acc:	fdc42783          	lw	a5,-36(s0)
   10ad0:	0ff7f793          	andi	a5,a5,255
   10ad4:	fef404a3          	sb	a5,-23(s0)
    ctrl.bits.WE = 1;
   10ad8:	fe844783          	lbu	a5,-24(s0)
   10adc:	f807e793          	ori	a5,a5,-128
   10ae0:	fef40423          	sb	a5,-24(s0)
    asm("csrw 0xBC4, %0" : :"r"(ctrl.value));
   10ae4:	fe843783          	ld	a5,-24(s0)
   10ae8:	bc479073          	csrw	0xbc4,a5
}
   10aec:	00000013          	nop
   10af0:	02813403          	ld	s0,40(sp)
   10af4:	03010113          	addi	sp,sp,48
   10af8:	00008067          	ret

0000000000010afc <mpu_enable_region>:

static void mpu_enable_region(int idx,
                       uint64_t bar,
                       uint64_t KB,
                       int cached,
                       const char *rwx) {
   10afc:	fb010113          	addi	sp,sp,-80
   10b00:	04813423          	sd	s0,72(sp)
   10b04:	05010413          	addi	s0,sp,80
   10b08:	00050793          	mv	a5,a0
   10b0c:	fcb43023          	sd	a1,-64(s0)
   10b10:	fac43c23          	sd	a2,-72(s0)
   10b14:	fae43823          	sd	a4,-80(s0)
   10b18:	fcf42623          	sw	a5,-52(s0)
   10b1c:	00068793          	mv	a5,a3
   10b20:	fcf42423          	sw	a5,-56(s0)
    uint64_t mask = (~0ull) << 10;
   10b24:	c0000793          	li	a5,-1024
   10b28:	fef43423          	sd	a5,-24(s0)
    const char *p = rwx;
   10b2c:	fb043783          	ld	a5,-80(s0)
   10b30:	fef43023          	sd	a5,-32(s0)
    mpu_ctrl_type ctrl;

    asm("csrw 0xBC2, %0" : :"r"(bar));
   10b34:	fc043783          	ld	a5,-64(s0)
   10b38:	bc279073          	csrw	0xbc2,a5

    KB >>= 1;
   10b3c:	fb843783          	ld	a5,-72(s0)
   10b40:	0017d793          	srli	a5,a5,0x1
   10b44:	faf43c23          	sd	a5,-72(s0)
    while (KB) {
   10b48:	01c0006f          	j	10b64 <mpu_enable_region+0x68>
        mask <<= 1;
   10b4c:	fe843783          	ld	a5,-24(s0)
   10b50:	00179793          	slli	a5,a5,0x1
   10b54:	fef43423          	sd	a5,-24(s0)
        KB >>= 1;
   10b58:	fb843783          	ld	a5,-72(s0)
   10b5c:	0017d793          	srli	a5,a5,0x1
   10b60:	faf43c23          	sd	a5,-72(s0)
    while (KB) {
   10b64:	fb843783          	ld	a5,-72(s0)
   10b68:	fe0792e3          	bnez	a5,10b4c <mpu_enable_region+0x50>
    }
    asm("csrw 0xBC3, %0" : :"r"(mask));
   10b6c:	fe843783          	ld	a5,-24(s0)
   10b70:	bc379073          	csrw	0xbc3,a5

    ctrl.value = 0;
   10b74:	fc043c23          	sd	zero,-40(s0)
    ctrl.bits.IDX = idx;
   10b78:	fcc42783          	lw	a5,-52(s0)
   10b7c:	0ff7f793          	andi	a5,a5,255
   10b80:	fcf40ca3          	sb	a5,-39(s0)
    ctrl.bits.ENA = 1;
   10b84:	fd844783          	lbu	a5,-40(s0)
   10b88:	0107e793          	ori	a5,a5,16
   10b8c:	fcf40c23          	sb	a5,-40(s0)
    ctrl.bits.CACHABLE = cached;
   10b90:	fc842783          	lw	a5,-56(s0)
   10b94:	0017f793          	andi	a5,a5,1
   10b98:	0ff7f793          	andi	a5,a5,255
   10b9c:	0017f793          	andi	a5,a5,1
   10ba0:	0037969b          	slliw	a3,a5,0x3
   10ba4:	fd844783          	lbu	a5,-40(s0)
   10ba8:	ff77f793          	andi	a5,a5,-9
   10bac:	00078713          	mv	a4,a5
   10bb0:	00068793          	mv	a5,a3
   10bb4:	00f767b3          	or	a5,a4,a5
   10bb8:	fcf40c23          	sb	a5,-40(s0)
    ctrl.bits.WE = 1; // write into MPU
   10bbc:	fd844783          	lbu	a5,-40(s0)
   10bc0:	f807e793          	ori	a5,a5,-128
   10bc4:	fcf40c23          	sb	a5,-40(s0)
    while (*p) {
   10bc8:	0700006f          	j	10c38 <mpu_enable_region+0x13c>
        if (*p == 'r') {
   10bcc:	fe043783          	ld	a5,-32(s0)
   10bd0:	0007c783          	lbu	a5,0(a5)
   10bd4:	00078713          	mv	a4,a5
   10bd8:	07200793          	li	a5,114
   10bdc:	00f71863          	bne	a4,a5,10bec <mpu_enable_region+0xf0>
            ctrl.bits.RD = 1;
   10be0:	fd844783          	lbu	a5,-40(s0)
   10be4:	0027e793          	ori	a5,a5,2
   10be8:	fcf40c23          	sb	a5,-40(s0)
        }
        if (*p == 'w') {
   10bec:	fe043783          	ld	a5,-32(s0)
   10bf0:	0007c783          	lbu	a5,0(a5)
   10bf4:	00078713          	mv	a4,a5
   10bf8:	07700793          	li	a5,119
   10bfc:	00f71863          	bne	a4,a5,10c0c <mpu_enable_region+0x110>
            ctrl.bits.WR = 1;
   10c00:	fd844783          	lbu	a5,-40(s0)
   10c04:	0017e793          	ori	a5,a5,1
   10c08:	fcf40c23          	sb	a5,-40(s0)
        }
        if (*p == 'x') {
   10c0c:	fe043783          	ld	a5,-32(s0)
   10c10:	0007c783          	lbu	a5,0(a5)
   10c14:	00078713          	mv	a4,a5
   10c18:	07800793          	li	a5,120
   10c1c:	00f71863          	bne	a4,a5,10c2c <mpu_enable_region+0x130>
            ctrl.bits.EXEC = 1;
   10c20:	fd844783          	lbu	a5,-40(s0)
   10c24:	0047e793          	ori	a5,a5,4
   10c28:	fcf40c23          	sb	a5,-40(s0)
        }
        p++;
   10c2c:	fe043783          	ld	a5,-32(s0)
   10c30:	00178793          	addi	a5,a5,1
   10c34:	fef43023          	sd	a5,-32(s0)
    while (*p) {
   10c38:	fe043783          	ld	a5,-32(s0)
   10c3c:	0007c783          	lbu	a5,0(a5)
   10c40:	f80796e3          	bnez	a5,10bcc <mpu_enable_region+0xd0>
    }
    asm("csrw 0xBC4, %0" : :"r"(ctrl.value));
   10c44:	fd843783          	ld	a5,-40(s0)
   10c48:	bc479073          	csrw	0xbc4,a5
}
   10c4c:	00000013          	nop
   10c50:	04813403          	ld	s0,72(sp)
   10c54:	05010113          	addi	sp,sp,80
   10c58:	00008067          	ret

0000000000010c5c <get_mcause>:
#include "encoding.h"
#include "fw_api.h"

static const char EXCEPTION_TABLE_NAME[8] = "extbl";

int get_mcause() {
   10c5c:	fe010113          	addi	sp,sp,-32
   10c60:	00813c23          	sd	s0,24(sp)
   10c64:	02010413          	addi	s0,sp,32
    int ret;
    asm("csrr %0, mcause" : "=r" (ret));
   10c68:	342027f3          	csrr	a5,mcause
   10c6c:	fef42623          	sw	a5,-20(s0)
    return ret;
   10c70:	fec42783          	lw	a5,-20(s0)
}
   10c74:	00078513          	mv	a0,a5
   10c78:	01813403          	ld	s0,24(sp)
   10c7c:	02010113          	addi	sp,sp,32
   10c80:	00008067          	ret

0000000000010c84 <get_mepc>:

int get_mepc() {
   10c84:	fe010113          	addi	sp,sp,-32
   10c88:	00813c23          	sd	s0,24(sp)
   10c8c:	02010413          	addi	s0,sp,32
    int ret;
    asm("csrr %0, mepc" : "=r" (ret));
   10c90:	341027f3          	csrr	a5,mepc
   10c94:	fef42623          	sw	a5,-20(s0)
    return ret;
   10c98:	fec42783          	lw	a5,-20(s0)
}
   10c9c:	00078513          	mv	a0,a5
   10ca0:	01813403          	ld	s0,24(sp)
   10ca4:	02010113          	addi	sp,sp,32
   10ca8:	00008067          	ret

0000000000010cac <get_mbadaddr>:

int get_mbadaddr() {
   10cac:	fe010113          	addi	sp,sp,-32
   10cb0:	00813c23          	sd	s0,24(sp)
   10cb4:	02010413          	addi	s0,sp,32
    int ret;
    asm("csrr %0, mbadaddr" : "=r" (ret));
   10cb8:	343027f3          	csrr	a5,mbadaddr
   10cbc:	fef42623          	sw	a5,-20(s0)
    return ret;
   10cc0:	fec42783          	lw	a5,-20(s0)
}
   10cc4:	00078513          	mv	a0,a5
   10cc8:	01813403          	ld	s0,24(sp)
   10ccc:	02010113          	addi	sp,sp,32
   10cd0:	00008067          	ret

0000000000010cd4 <exception_instr_load_fault_c>:

void exception_instr_load_fault_c() {
   10cd4:	fe010113          	addi	sp,sp,-32
   10cd8:	00113c23          	sd	ra,24(sp)
   10cdc:	00813823          	sd	s0,16(sp)
   10ce0:	02010413          	addi	s0,sp,32
    pnp_map *pnp = (pnp_map *)ADDR_BUS0_XSLV_PNP;
   10ce4:	100ff7b7          	lui	a5,0x100ff
   10ce8:	fef43423          	sd	a5,-24(s0)
    uint64_t t1 = pnp->fwdbg1;
   10cec:	fe843783          	ld	a5,-24(s0)
   10cf0:	0287b783          	ld	a5,40(a5) # 100ff028 <_end+0x100df78c>
   10cf4:	fef43023          	sd	a5,-32(s0)
    asm("csrw mepc, %0" : :"r"(t1));
   10cf8:	fe043783          	ld	a5,-32(s0)
   10cfc:	34179073          	csrw	mepc,a5
    pnp->fwdbg1 = get_mbadaddr();
   10d00:	00000097          	auipc	ra,0x0
   10d04:	fac080e7          	jalr	-84(ra) # 10cac <get_mbadaddr>
   10d08:	00050793          	mv	a5,a0
   10d0c:	00078713          	mv	a4,a5
   10d10:	fe843783          	ld	a5,-24(s0)
   10d14:	02e7b423          	sd	a4,40(a5)
}
   10d18:	00000013          	nop
   10d1c:	01813083          	ld	ra,24(sp)
   10d20:	01013403          	ld	s0,16(sp)
   10d24:	02010113          	addi	sp,sp,32
   10d28:	00008067          	ret

0000000000010d2c <exception_load_fault_c>:

void exception_load_fault_c() {
   10d2c:	fe010113          	addi	sp,sp,-32
   10d30:	00113c23          	sd	ra,24(sp)
   10d34:	00813823          	sd	s0,16(sp)
   10d38:	02010413          	addi	s0,sp,32
    pnp_map *pnp = (pnp_map *)ADDR_BUS0_XSLV_PNP;
   10d3c:	100ff7b7          	lui	a5,0x100ff
   10d40:	fef43423          	sd	a5,-24(s0)
    pnp->fwdbg1 = get_mbadaddr();
   10d44:	f69ff0ef          	jal	ra,10cac <get_mbadaddr>
   10d48:	00050793          	mv	a5,a0
   10d4c:	00078713          	mv	a4,a5
   10d50:	fe843783          	ld	a5,-24(s0)
   10d54:	02e7b423          	sd	a4,40(a5) # 100ff028 <_end+0x100df78c>
}
   10d58:	00000013          	nop
   10d5c:	01813083          	ld	ra,24(sp)
   10d60:	01013403          	ld	s0,16(sp)
   10d64:	02010113          	addi	sp,sp,32
   10d68:	00008067          	ret

0000000000010d6c <exception_store_fault_c>:

void exception_store_fault_c() {
   10d6c:	fe010113          	addi	sp,sp,-32
   10d70:	00113c23          	sd	ra,24(sp)
   10d74:	00813823          	sd	s0,16(sp)
   10d78:	02010413          	addi	s0,sp,32
    pnp_map *pnp = (pnp_map *)ADDR_BUS0_XSLV_PNP;
   10d7c:	100ff7b7          	lui	a5,0x100ff
   10d80:	fef43423          	sd	a5,-24(s0)
    pnp->fwdbg1 = get_mbadaddr();
   10d84:	00000097          	auipc	ra,0x0
   10d88:	f28080e7          	jalr	-216(ra) # 10cac <get_mbadaddr>
   10d8c:	00050793          	mv	a5,a0
   10d90:	00078713          	mv	a4,a5
   10d94:	fe843783          	ld	a5,-24(s0)
   10d98:	02e7b423          	sd	a4,40(a5) # 100ff028 <_end+0x100df78c>
}
   10d9c:	00000013          	nop
   10da0:	01813083          	ld	ra,24(sp)
   10da4:	01013403          	ld	s0,16(sp)
   10da8:	02010113          	addi	sp,sp,32
   10dac:	00008067          	ret

0000000000010db0 <exception_stack_overflow_c>:

void exception_stack_overflow_c() {
   10db0:	fe010113          	addi	sp,sp,-32
   10db4:	00813c23          	sd	s0,24(sp)
   10db8:	02010413          	addi	s0,sp,32
    // CSR_mstackovr = 0x350 - non-standard CSR
    pnp_map *pnp = (pnp_map *)ADDR_BUS0_XSLV_PNP;
   10dbc:	100ff7b7          	lui	a5,0x100ff
   10dc0:	fef43423          	sd	a5,-24(s0)
    uint64_t sp;
    // Save current stack pointer into debug regsiter
    asm("mv %0, sp" : "=r" (sp));
   10dc4:	00010793          	mv	a5,sp
   10dc8:	fef43023          	sd	a5,-32(s0)
    pnp->fwdbg2 = sp;
   10dcc:	fe843783          	ld	a5,-24(s0)
   10dd0:	fe043703          	ld	a4,-32(s0)
   10dd4:	02e7b823          	sd	a4,48(a5) # 100ff030 <_end+0x100df794>
}
   10dd8:	00000013          	nop
   10ddc:	01813403          	ld	s0,24(sp)
   10de0:	02010113          	addi	sp,sp,32
   10de4:	00008067          	ret

0000000000010de8 <exception_stack_underflow_c>:

void exception_stack_underflow_c() {
   10de8:	fe010113          	addi	sp,sp,-32
   10dec:	00813c23          	sd	s0,24(sp)
   10df0:	02010413          	addi	s0,sp,32
    // CSR_mstackund = 0x351 - non-standard CSR
    pnp_map *pnp = (pnp_map *)ADDR_BUS0_XSLV_PNP;
   10df4:	100ff7b7          	lui	a5,0x100ff
   10df8:	fef43423          	sd	a5,-24(s0)
    uint64_t sp;
    // Save current stack pointer into debug regsiter
    asm("mv %0, sp" : "=r" (sp));
   10dfc:	00010793          	mv	a5,sp
   10e00:	fef43023          	sd	a5,-32(s0)
    pnp->fwdbg2 = sp;
   10e04:	fe843783          	ld	a5,-24(s0)
   10e08:	fe043703          	ld	a4,-32(s0)
   10e0c:	02e7b823          	sd	a4,48(a5) # 100ff030 <_end+0x100df794>
}
   10e10:	00000013          	nop
   10e14:	01813403          	ld	s0,24(sp)
   10e18:	02010113          	addi	sp,sp,32
   10e1c:	00008067          	ret

0000000000010e20 <exception_handler_c>:

void exception_handler_c() {
   10e20:	fe010113          	addi	sp,sp,-32
   10e24:	00113c23          	sd	ra,24(sp)
   10e28:	00813823          	sd	s0,16(sp)
   10e2c:	02010413          	addi	s0,sp,32
    asm("fence.i");
   10e30:	0000100f          	fence.i
    IRQ_HANDLER *tbl = fw_get_ram_data(EXCEPTION_TABLE_NAME);
   10e34:	0001f7b7          	lui	a5,0x1f
   10e38:	f6078513          	addi	a0,a5,-160 # 1ef60 <EXCEPTION_TABLE_NAME>
   10e3c:	00001097          	auipc	ra,0x1
   10e40:	e2c080e7          	jalr	-468(ra) # 11c68 <fw_get_ram_data>
   10e44:	fea43423          	sd	a0,-24(s0)
    int idx = get_mcause();
   10e48:	e15ff0ef          	jal	ra,10c5c <get_mcause>
   10e4c:	00050793          	mv	a5,a0
   10e50:	fef42223          	sw	a5,-28(s0)
    if (tbl[idx] == 0) {
   10e54:	fe442783          	lw	a5,-28(s0)
   10e58:	00379793          	slli	a5,a5,0x3
   10e5c:	fe843703          	ld	a4,-24(s0)
   10e60:	00f707b3          	add	a5,a4,a5
   10e64:	0007b783          	ld	a5,0(a5)
   10e68:	06079463          	bnez	a5,10ed0 <exception_handler_c+0xb0>
       print_uart("mcause:", 7);
   10e6c:	00700593          	li	a1,7
   10e70:	0001a7b7          	lui	a5,0x1a
   10e74:	42078513          	addi	a0,a5,1056 # 1a420 <strnlen+0x1e>
   10e78:	115010ef          	jal	ra,1278c <print_uart>
       print_uart_hex(idx);
   10e7c:	fe442783          	lw	a5,-28(s0)
   10e80:	00078513          	mv	a0,a5
   10e84:	00002097          	auipc	ra,0x2
   10e88:	99c080e7          	jalr	-1636(ra) # 12820 <print_uart_hex>
       print_uart(",mepc:", 6);
   10e8c:	00600593          	li	a1,6
   10e90:	0001a7b7          	lui	a5,0x1a
   10e94:	42878513          	addi	a0,a5,1064 # 1a428 <strnlen+0x26>
   10e98:	0f5010ef          	jal	ra,1278c <print_uart>
       print_uart_hex(get_mepc());
   10e9c:	00000097          	auipc	ra,0x0
   10ea0:	de8080e7          	jalr	-536(ra) # 10c84 <get_mepc>
   10ea4:	00050793          	mv	a5,a0
   10ea8:	00078513          	mv	a0,a5
   10eac:	00002097          	auipc	ra,0x2
   10eb0:	974080e7          	jalr	-1676(ra) # 12820 <print_uart_hex>
       print_uart("\r\n", 2);
   10eb4:	00200593          	li	a1,2
   10eb8:	0001a7b7          	lui	a5,0x1a
   10ebc:	43078513          	addi	a0,a5,1072 # 1a430 <strnlen+0x2e>
   10ec0:	0cd010ef          	jal	ra,1278c <print_uart>
       /// Exception trap
       led_set(0xF0);
   10ec4:	0f000513          	li	a0,240
   10ec8:	090020ef          	jal	ra,12f58 <led_set>
       while (1) {}
   10ecc:	0000006f          	j	10ecc <exception_handler_c+0xac>
    } else {
       tbl[idx]();
   10ed0:	fe442783          	lw	a5,-28(s0)
   10ed4:	00379793          	slli	a5,a5,0x3
   10ed8:	fe843703          	ld	a4,-24(s0)
   10edc:	00f707b3          	add	a5,a4,a5
   10ee0:	0007b783          	ld	a5,0(a5)
   10ee4:	000780e7          	jalr	a5
    }
}
   10ee8:	00000013          	nop
   10eec:	01813083          	ld	ra,24(sp)
   10ef0:	01013403          	ld	s0,16(sp)
   10ef4:	02010113          	addi	sp,sp,32
   10ef8:	00008067          	ret

0000000000010efc <allocate_exception_table>:

void allocate_exception_table() {
   10efc:	fe010113          	addi	sp,sp,-32
   10f00:	00113c23          	sd	ra,24(sp)
   10f04:	00813823          	sd	s0,16(sp)
   10f08:	02010413          	addi	s0,sp,32
    IRQ_HANDLER *extbl = (IRQ_HANDLER *)
   10f0c:	09000513          	li	a0,144
   10f10:	429000ef          	jal	ra,11b38 <fw_malloc>
   10f14:	fea43423          	sd	a0,-24(s0)
        fw_malloc(EXCEPTION_Total * sizeof(IRQ_HANDLER));    
    fw_register_ram_data(EXCEPTION_TABLE_NAME, extbl);
   10f18:	fe843583          	ld	a1,-24(s0)
   10f1c:	0001f7b7          	lui	a5,0x1f
   10f20:	f6078513          	addi	a0,a5,-160 # 1ef60 <EXCEPTION_TABLE_NAME>
   10f24:	00001097          	auipc	ra,0x1
   10f28:	cb4080e7          	jalr	-844(ra) # 11bd8 <fw_register_ram_data>

    extbl[EXCEPTION_InstrFault] = exception_instr_load_fault_c;
   10f2c:	fe843783          	ld	a5,-24(s0)
   10f30:	00878793          	addi	a5,a5,8
   10f34:	00011737          	lui	a4,0x11
   10f38:	cd470713          	addi	a4,a4,-812 # 10cd4 <exception_instr_load_fault_c>
   10f3c:	00e7b023          	sd	a4,0(a5)
    extbl[EXCEPTION_LoadFault] = exception_load_fault_c;
   10f40:	fe843783          	ld	a5,-24(s0)
   10f44:	02878793          	addi	a5,a5,40
   10f48:	00011737          	lui	a4,0x11
   10f4c:	d2c70713          	addi	a4,a4,-724 # 10d2c <exception_load_fault_c>
   10f50:	00e7b023          	sd	a4,0(a5)
    extbl[EXCEPTION_StoreFault] = exception_store_fault_c;
   10f54:	fe843783          	ld	a5,-24(s0)
   10f58:	03878793          	addi	a5,a5,56
   10f5c:	00011737          	lui	a4,0x11
   10f60:	d6c70713          	addi	a4,a4,-660 # 10d6c <exception_store_fault_c>
   10f64:	00e7b023          	sd	a4,0(a5)
    extbl[EXCEPTION_StackOverflow] = exception_stack_overflow_c;
   10f68:	fe843783          	ld	a5,-24(s0)
   10f6c:	08078793          	addi	a5,a5,128
   10f70:	00011737          	lui	a4,0x11
   10f74:	db070713          	addi	a4,a4,-592 # 10db0 <exception_stack_overflow_c>
   10f78:	00e7b023          	sd	a4,0(a5)
    extbl[EXCEPTION_StackUnderflow] = exception_stack_underflow_c;
   10f7c:	fe843783          	ld	a5,-24(s0)
   10f80:	08878793          	addi	a5,a5,136
   10f84:	00011737          	lui	a4,0x11
   10f88:	de870713          	addi	a4,a4,-536 # 10de8 <exception_stack_underflow_c>
   10f8c:	00e7b023          	sd	a4,0(a5)
}
   10f90:	00000013          	nop
   10f94:	01813083          	ld	ra,24(sp)
   10f98:	01013403          	ld	s0,16(sp)
   10f9c:	02010113          	addi	sp,sp,32
   10fa0:	00008067          	ret
   10fa4:	0000                	unimp
	...

0000000000010fa8 <get_dev_bar>:
static uint64_t get_dev_bar(pnp_map *pnp, uint16_t vid, uint16_t did) {
   10fa8:	fb010113          	addi	sp,sp,-80
   10fac:	04813423          	sd	s0,72(sp)
   10fb0:	05010413          	addi	s0,sp,80
   10fb4:	faa43c23          	sd	a0,-72(s0)
   10fb8:	00058793          	mv	a5,a1
   10fbc:	00060713          	mv	a4,a2
   10fc0:	faf41b23          	sh	a5,-74(s0)
   10fc4:	00070793          	mv	a5,a4
   10fc8:	faf41a23          	sh	a5,-76(s0)
    int slots_total = (pnp->cfg >> 8) & 0xFF;
   10fcc:	fb843783          	ld	a5,-72(s0)
   10fd0:	0087a783          	lw	a5,8(a5)
   10fd4:	0087d79b          	srliw	a5,a5,0x8
   10fd8:	0007879b          	sext.w	a5,a5
   10fdc:	0007879b          	sext.w	a5,a5
   10fe0:	0ff7f793          	andi	a5,a5,255
   10fe4:	fef42223          	sw	a5,-28(s0)
    int off = 0;
   10fe8:	fe042623          	sw	zero,-20(s0)
    for (int i = 0; i < slots_total; i++) {
   10fec:	fe042423          	sw	zero,-24(s0)
   10ff0:	09c0006f          	j	1108c <get_dev_bar+0xe4>
        dcfg = *(dev_cfg_type *)&pnp->cfg_table[off];
   10ff4:	fec42783          	lw	a5,-20(s0)
   10ff8:	04078793          	addi	a5,a5,64
   10ffc:	fb843703          	ld	a4,-72(s0)
   11000:	00f707b3          	add	a5,a4,a5
   11004:	0007b703          	ld	a4,0(a5)
   11008:	fce43023          	sd	a4,-64(s0)
   1100c:	0087b703          	ld	a4,8(a5)
   11010:	fce43423          	sd	a4,-56(s0)
   11014:	0107b703          	ld	a4,16(a5)
   11018:	fce43823          	sd	a4,-48(s0)
   1101c:	0187b783          	ld	a5,24(a5)
   11020:	fcf43c23          	sd	a5,-40(s0)
        off += sizeof(dcfg);
   11024:	fec42783          	lw	a5,-20(s0)
   11028:	0207879b          	addiw	a5,a5,32
   1102c:	0007879b          	sext.w	a5,a5
   11030:	fef42623          	sw	a5,-20(s0)
        if (dcfg.u.descrtype != PNP_CFG_TYPE_SLAVE) {
   11034:	fc144783          	lbu	a5,-63(s0)
   11038:	0037f793          	andi	a5,a5,3
   1103c:	0ff7f793          	andi	a5,a5,255
   11040:	00078713          	mv	a4,a5
   11044:	00200793          	li	a5,2
   11048:	02f71a63          	bne	a4,a5,1107c <get_dev_bar+0xd4>
        if (dcfg.u.vid == vid && dcfg.u.did == did) {
   1104c:	fc645783          	lhu	a5,-58(s0)
   11050:	fb645703          	lhu	a4,-74(s0)
   11054:	0007071b          	sext.w	a4,a4
   11058:	0007879b          	sext.w	a5,a5
   1105c:	02f71263          	bne	a4,a5,11080 <get_dev_bar+0xd8>
   11060:	fc445783          	lhu	a5,-60(s0)
   11064:	fb445703          	lhu	a4,-76(s0)
   11068:	0007071b          	sext.w	a4,a4
   1106c:	0007879b          	sext.w	a5,a5
   11070:	00f71863          	bne	a4,a5,11080 <get_dev_bar+0xd8>
            return dcfg.u.addr_start;
   11074:	fd043783          	ld	a5,-48(s0)
   11078:	02c0006f          	j	110a4 <get_dev_bar+0xfc>
            continue;
   1107c:	00000013          	nop
    for (int i = 0; i < slots_total; i++) {
   11080:	fe842783          	lw	a5,-24(s0)
   11084:	0017879b          	addiw	a5,a5,1
   11088:	fef42423          	sw	a5,-24(s0)
   1108c:	fe842703          	lw	a4,-24(s0)
   11090:	fe442783          	lw	a5,-28(s0)
   11094:	0007071b          	sext.w	a4,a4
   11098:	0007879b          	sext.w	a5,a5
   1109c:	f4f74ce3          	blt	a4,a5,10ff4 <get_dev_bar+0x4c>
    return DEV_NONE;
   110a0:	fff00793          	li	a5,-1
}
   110a4:	00078513          	mv	a0,a5
   110a8:	04813403          	ld	s0,72(sp)
   110ac:	05010113          	addi	sp,sp,80
   110b0:	00008067          	ret

00000000000110b4 <mpu_region_total>:
static int mpu_region_total() {
   110b4:	fe010113          	addi	sp,sp,-32
   110b8:	00813c23          	sd	s0,24(sp)
   110bc:	02010413          	addi	s0,sp,32
    uint64_t val = 0;
   110c0:	fe043423          	sd	zero,-24(s0)
    asm("csrr %0, 0xBC4" : "=r" (val));
   110c4:	bc4027f3          	csrr	a5,0xbc4
   110c8:	fef43423          	sd	a5,-24(s0)
    return (int)(val >> 8);
   110cc:	fe843783          	ld	a5,-24(s0)
   110d0:	0087d793          	srli	a5,a5,0x8
   110d4:	0007879b          	sext.w	a5,a5
}
   110d8:	00078513          	mv	a0,a5
   110dc:	01813403          	ld	s0,24(sp)
   110e0:	02010113          	addi	sp,sp,32
   110e4:	00008067          	ret

00000000000110e8 <mpu_disable_region>:
static void mpu_disable_region(int idx) {
   110e8:	fd010113          	addi	sp,sp,-48
   110ec:	02813423          	sd	s0,40(sp)
   110f0:	03010413          	addi	s0,sp,48
   110f4:	00050793          	mv	a5,a0
   110f8:	fcf42e23          	sw	a5,-36(s0)
    ctrl.value = 0;
   110fc:	fe043423          	sd	zero,-24(s0)
    ctrl.bits.IDX = idx;
   11100:	fdc42783          	lw	a5,-36(s0)
   11104:	0ff7f793          	andi	a5,a5,255
   11108:	fef404a3          	sb	a5,-23(s0)
    ctrl.bits.WE = 1;
   1110c:	fe844783          	lbu	a5,-24(s0)
   11110:	f807e793          	ori	a5,a5,-128
   11114:	fef40423          	sb	a5,-24(s0)
    asm("csrw 0xBC4, %0" : :"r"(ctrl.value));
   11118:	fe843783          	ld	a5,-24(s0)
   1111c:	bc479073          	csrw	0xbc4,a5
}
   11120:	00000013          	nop
   11124:	02813403          	ld	s0,40(sp)
   11128:	03010113          	addi	sp,sp,48
   1112c:	00008067          	ret

0000000000011130 <mpu_enable_region>:
                       const char *rwx) {
   11130:	fb010113          	addi	sp,sp,-80
   11134:	04813423          	sd	s0,72(sp)
   11138:	05010413          	addi	s0,sp,80
   1113c:	00050793          	mv	a5,a0
   11140:	fcb43023          	sd	a1,-64(s0)
   11144:	fac43c23          	sd	a2,-72(s0)
   11148:	fae43823          	sd	a4,-80(s0)
   1114c:	fcf42623          	sw	a5,-52(s0)
   11150:	00068793          	mv	a5,a3
   11154:	fcf42423          	sw	a5,-56(s0)
    uint64_t mask = (~0ull) << 10;
   11158:	c0000793          	li	a5,-1024
   1115c:	fef43423          	sd	a5,-24(s0)
    const char *p = rwx;
   11160:	fb043783          	ld	a5,-80(s0)
   11164:	fef43023          	sd	a5,-32(s0)
    asm("csrw 0xBC2, %0" : :"r"(bar));
   11168:	fc043783          	ld	a5,-64(s0)
   1116c:	bc279073          	csrw	0xbc2,a5
    KB >>= 1;
   11170:	fb843783          	ld	a5,-72(s0)
   11174:	0017d793          	srli	a5,a5,0x1
   11178:	faf43c23          	sd	a5,-72(s0)
    while (KB) {
   1117c:	01c0006f          	j	11198 <mpu_enable_region+0x68>
        mask <<= 1;
   11180:	fe843783          	ld	a5,-24(s0)
   11184:	00179793          	slli	a5,a5,0x1
   11188:	fef43423          	sd	a5,-24(s0)
        KB >>= 1;
   1118c:	fb843783          	ld	a5,-72(s0)
   11190:	0017d793          	srli	a5,a5,0x1
   11194:	faf43c23          	sd	a5,-72(s0)
    while (KB) {
   11198:	fb843783          	ld	a5,-72(s0)
   1119c:	fe0792e3          	bnez	a5,11180 <mpu_enable_region+0x50>
    asm("csrw 0xBC3, %0" : :"r"(mask));
   111a0:	fe843783          	ld	a5,-24(s0)
   111a4:	bc379073          	csrw	0xbc3,a5
    ctrl.value = 0;
   111a8:	fc043c23          	sd	zero,-40(s0)
    ctrl.bits.IDX = idx;
   111ac:	fcc42783          	lw	a5,-52(s0)
   111b0:	0ff7f793          	andi	a5,a5,255
   111b4:	fcf40ca3          	sb	a5,-39(s0)
    ctrl.bits.ENA = 1;
   111b8:	fd844783          	lbu	a5,-40(s0)
   111bc:	0107e793          	ori	a5,a5,16
   111c0:	fcf40c23          	sb	a5,-40(s0)
    ctrl.bits.CACHABLE = cached;
   111c4:	fc842783          	lw	a5,-56(s0)
   111c8:	0017f793          	andi	a5,a5,1
   111cc:	0ff7f793          	andi	a5,a5,255
   111d0:	0017f793          	andi	a5,a5,1
   111d4:	0037969b          	slliw	a3,a5,0x3
   111d8:	fd844783          	lbu	a5,-40(s0)
   111dc:	ff77f793          	andi	a5,a5,-9
   111e0:	00078713          	mv	a4,a5
   111e4:	00068793          	mv	a5,a3
   111e8:	00f767b3          	or	a5,a4,a5
   111ec:	fcf40c23          	sb	a5,-40(s0)
    ctrl.bits.WE = 1; // write into MPU
   111f0:	fd844783          	lbu	a5,-40(s0)
   111f4:	f807e793          	ori	a5,a5,-128
   111f8:	fcf40c23          	sb	a5,-40(s0)
    while (*p) {
   111fc:	0700006f          	j	1126c <mpu_enable_region+0x13c>
        if (*p == 'r') {
   11200:	fe043783          	ld	a5,-32(s0)
   11204:	0007c783          	lbu	a5,0(a5)
   11208:	00078713          	mv	a4,a5
   1120c:	07200793          	li	a5,114
   11210:	00f71863          	bne	a4,a5,11220 <mpu_enable_region+0xf0>
            ctrl.bits.RD = 1;
   11214:	fd844783          	lbu	a5,-40(s0)
   11218:	0027e793          	ori	a5,a5,2
   1121c:	fcf40c23          	sb	a5,-40(s0)
        if (*p == 'w') {
   11220:	fe043783          	ld	a5,-32(s0)
   11224:	0007c783          	lbu	a5,0(a5)
   11228:	00078713          	mv	a4,a5
   1122c:	07700793          	li	a5,119
   11230:	00f71863          	bne	a4,a5,11240 <mpu_enable_region+0x110>
            ctrl.bits.WR = 1;
   11234:	fd844783          	lbu	a5,-40(s0)
   11238:	0017e793          	ori	a5,a5,1
   1123c:	fcf40c23          	sb	a5,-40(s0)
        if (*p == 'x') {
   11240:	fe043783          	ld	a5,-32(s0)
   11244:	0007c783          	lbu	a5,0(a5)
   11248:	00078713          	mv	a4,a5
   1124c:	07800793          	li	a5,120
   11250:	00f71863          	bne	a4,a5,11260 <mpu_enable_region+0x130>
            ctrl.bits.EXEC = 1;
   11254:	fd844783          	lbu	a5,-40(s0)
   11258:	0047e793          	ori	a5,a5,4
   1125c:	fcf40c23          	sb	a5,-40(s0)
        p++;
   11260:	fe043783          	ld	a5,-32(s0)
   11264:	00178793          	addi	a5,a5,1
   11268:	fef43023          	sd	a5,-32(s0)
    while (*p) {
   1126c:	fe043783          	ld	a5,-32(s0)
   11270:	0007c783          	lbu	a5,0(a5)
   11274:	f80796e3          	bnez	a5,11200 <mpu_enable_region+0xd0>
    asm("csrw 0xBC4, %0" : :"r"(ctrl.value));
   11278:	fd843783          	ld	a5,-40(s0)
   1127c:	bc479073          	csrw	0xbc4,a5
}
   11280:	00000013          	nop
   11284:	04813403          	ld	s0,72(sp)
   11288:	05010113          	addi	sp,sp,80
   1128c:	00008067          	ret

0000000000011290 <allocate_interrupt_table>:
        uint64_t irq    : 1;
    } bits;
    uint64_t value;
} csr_mcause_type;

void allocate_interrupt_table() {
   11290:	fe010113          	addi	sp,sp,-32
   11294:	00113c23          	sd	ra,24(sp)
   11298:	00813823          	sd	s0,16(sp)
   1129c:	02010413          	addi	s0,sp,32
    IRQ_HANDLER *tbl = (IRQ_HANDLER *)
   112a0:	24800513          	li	a0,584
   112a4:	00001097          	auipc	ra,0x1
   112a8:	894080e7          	jalr	-1900(ra) # 11b38 <fw_malloc>
   112ac:	fea43023          	sd	a0,-32(s0)
        fw_malloc(PLIC_ISR_MAX * sizeof(IRQ_HANDLER));    
    fw_register_ram_data(INTERRUPT_TABLE_NAME, tbl);
   112b0:	fe043583          	ld	a1,-32(s0)
   112b4:	0001f7b7          	lui	a5,0x1f
   112b8:	fd878513          	addi	a0,a5,-40 # 1efd8 <INTERRUPT_TABLE_NAME>
   112bc:	11d000ef          	jal	ra,11bd8 <fw_register_ram_data>
    for (int i = 0; i < PLIC_ISR_MAX; i++) {
   112c0:	fe042623          	sw	zero,-20(s0)
   112c4:	0240006f          	j	112e8 <allocate_interrupt_table+0x58>
        tbl[i] = 0;
   112c8:	fec42783          	lw	a5,-20(s0)
   112cc:	00379793          	slli	a5,a5,0x3
   112d0:	fe043703          	ld	a4,-32(s0)
   112d4:	00f707b3          	add	a5,a4,a5
   112d8:	0007b023          	sd	zero,0(a5)
    for (int i = 0; i < PLIC_ISR_MAX; i++) {
   112dc:	fec42783          	lw	a5,-20(s0)
   112e0:	0017879b          	addiw	a5,a5,1
   112e4:	fef42623          	sw	a5,-20(s0)
   112e8:	fec42783          	lw	a5,-20(s0)
   112ec:	0007871b          	sext.w	a4,a5
   112f0:	04800793          	li	a5,72
   112f4:	fce7dae3          	ble	a4,a5,112c8 <allocate_interrupt_table+0x38>
    }
}
   112f8:	00000013          	nop
   112fc:	01813083          	ld	ra,24(sp)
   11300:	01013403          	ld	s0,16(sp)
   11304:	02010113          	addi	sp,sp,32
   11308:	00008067          	ret

000000000001130c <register_ext_interrupt_handler>:

void register_ext_interrupt_handler(int idx, IRQ_HANDLER f) {
   1130c:	fd010113          	addi	sp,sp,-48
   11310:	02113423          	sd	ra,40(sp)
   11314:	02813023          	sd	s0,32(sp)
   11318:	03010413          	addi	s0,sp,48
   1131c:	00050793          	mv	a5,a0
   11320:	fcb43823          	sd	a1,-48(s0)
   11324:	fcf42e23          	sw	a5,-36(s0)
    IRQ_HANDLER *tbl = 
   11328:	0001f7b7          	lui	a5,0x1f
   1132c:	fd878513          	addi	a0,a5,-40 # 1efd8 <INTERRUPT_TABLE_NAME>
   11330:	139000ef          	jal	ra,11c68 <fw_get_ram_data>
   11334:	fea43423          	sd	a0,-24(s0)
       (IRQ_HANDLER *)fw_get_ram_data(INTERRUPT_TABLE_NAME);
    tbl[idx] = f;
   11338:	fdc42783          	lw	a5,-36(s0)
   1133c:	00379793          	slli	a5,a5,0x3
   11340:	fe843703          	ld	a4,-24(s0)
   11344:	00f707b3          	add	a5,a4,a5
   11348:	fd043703          	ld	a4,-48(s0)
   1134c:	00e7b023          	sd	a4,0(a5)
}
   11350:	00000013          	nop
   11354:	02813083          	ld	ra,40(sp)
   11358:	02013403          	ld	s0,32(sp)
   1135c:	03010113          	addi	sp,sp,48
   11360:	00008067          	ret

0000000000011364 <fatal_error>:


/** Fatal Error Handler can be used to transmit dump image
 *  or trigger watchdog
 */
void fatal_error() {
   11364:	ff010113          	addi	sp,sp,-16
   11368:	00113423          	sd	ra,8(sp)
   1136c:	00813023          	sd	s0,0(sp)
   11370:	01010413          	addi	s0,sp,16
    led_set(0xF0);
   11374:	0f000513          	li	a0,240
   11378:	3e1010ef          	jal	ra,12f58 <led_set>
    printf_uart("fatal_error()\r\n");
   1137c:	0001a7b7          	lui	a5,0x1a
   11380:	43878513          	addi	a0,a5,1080 # 1a438 <strnlen+0x36>
   11384:	00001097          	auipc	ra,0x1
   11388:	5cc080e7          	jalr	1484(ra) # 12950 <printf_uart>
    while (1) {}
   1138c:	0000006f          	j	1138c <fatal_error+0x28>

0000000000011390 <plic_claim>:
}

uint32_t plic_claim(int ctxid) {
   11390:	fd010113          	addi	sp,sp,-48
   11394:	02813423          	sd	s0,40(sp)
   11398:	03010413          	addi	s0,sp,48
   1139c:	00050793          	mv	a5,a0
   113a0:	fcf42e23          	sw	a5,-36(s0)
    plic_map *p = (plic_map *)ADDR_BUS0_XSLV_PLIC;
   113a4:	0c0007b7          	lui	a5,0xc000
   113a8:	fef43423          	sd	a5,-24(s0)
    return p->ctx_prio[ctxid].claim_complete;
   113ac:	fe843703          	ld	a4,-24(s0)
   113b0:	fdc42783          	lw	a5,-36(s0)
   113b4:	20078793          	addi	a5,a5,512 # c000200 <_end+0xbfe0964>
   113b8:	00c79793          	slli	a5,a5,0xc
   113bc:	00f707b3          	add	a5,a4,a5
   113c0:	0047a783          	lw	a5,4(a5)
   113c4:	0007879b          	sext.w	a5,a5
}
   113c8:	00078513          	mv	a0,a5
   113cc:	02813403          	ld	s0,40(sp)
   113d0:	03010113          	addi	sp,sp,48
   113d4:	00008067          	ret

00000000000113d8 <plic_complete>:

void plic_complete(int ctxid, int irqid) {
   113d8:	fd010113          	addi	sp,sp,-48
   113dc:	02813423          	sd	s0,40(sp)
   113e0:	03010413          	addi	s0,sp,48
   113e4:	00050793          	mv	a5,a0
   113e8:	00058713          	mv	a4,a1
   113ec:	fcf42e23          	sw	a5,-36(s0)
   113f0:	00070793          	mv	a5,a4
   113f4:	fcf42c23          	sw	a5,-40(s0)
    plic_map *p = (plic_map *)ADDR_BUS0_XSLV_PLIC;
   113f8:	0c0007b7          	lui	a5,0xc000
   113fc:	fef43423          	sd	a5,-24(s0)
    p->ctx_prio[ctxid].claim_complete = irqid;
   11400:	fd842703          	lw	a4,-40(s0)
   11404:	fe843683          	ld	a3,-24(s0)
   11408:	fdc42783          	lw	a5,-36(s0)
   1140c:	20078793          	addi	a5,a5,512 # c000200 <_end+0xbfe0964>
   11410:	00c79793          	slli	a5,a5,0xc
   11414:	00f687b3          	add	a5,a3,a5
   11418:	00e7a223          	sw	a4,4(a5)
}
   1141c:	00000013          	nop
   11420:	02813403          	ld	s0,40(sp)
   11424:	03010113          	addi	sp,sp,48
   11428:	00008067          	ret

000000000001142c <interrupt_s_software_c>:

void interrupt_s_software_c() {
   1142c:	ff010113          	addi	sp,sp,-16
   11430:	00813423          	sd	s0,8(sp)
   11434:	01010413          	addi	s0,sp,16
}
   11438:	00000013          	nop
   1143c:	00813403          	ld	s0,8(sp)
   11440:	01010113          	addi	sp,sp,16
   11444:	00008067          	ret

0000000000011448 <interrupt_m_software_c>:

void interrupt_m_software_c() {
   11448:	fe010113          	addi	sp,sp,-32
   1144c:	00113c23          	sd	ra,24(sp)
   11450:	00813823          	sd	s0,16(sp)
   11454:	02010413          	addi	s0,sp,32
    pnp_map *pnp = (pnp_map *)ADDR_BUS0_XSLV_PNP;
   11458:	100ff7b7          	lui	a5,0x100ff
   1145c:	fef43423          	sd	a5,-24(s0)
    clint_map *clint = (clint_map *)ADDR_BUS0_XSLV_CLINT;
   11460:	020007b7          	lui	a5,0x2000
   11464:	fef43023          	sd	a5,-32(s0)

    clint->msip[fw_get_cpuid()] = 0x0;     // clear pending bit
   11468:	0ad010ef          	jal	ra,12d14 <fw_get_cpuid>
   1146c:	00050793          	mv	a5,a0
   11470:	fe043703          	ld	a4,-32(s0)
   11474:	00279793          	slli	a5,a5,0x2
   11478:	00f707b3          	add	a5,a4,a5
   1147c:	0007a023          	sw	zero,0(a5) # 2000000 <_end+0x1fe0764>
    if (fw_get_cpuid() == 0) {
   11480:	095010ef          	jal	ra,12d14 <fw_get_cpuid>
   11484:	00050793          	mv	a5,a0
   11488:	00079a63          	bnez	a5,1149c <interrupt_m_software_c+0x54>
        pnp->fwdbg1 = MAGIC_SWIRQ_TEST_NUMBER; // to pass test write this value
   1148c:	fe843783          	ld	a5,-24(s0)
   11490:	0001a737          	lui	a4,0x1a
   11494:	46073703          	ld	a4,1120(a4) # 1a460 <strnlen+0x5e>
   11498:	02e7b423          	sd	a4,40(a5)
    }
}
   1149c:	00000013          	nop
   114a0:	01813083          	ld	ra,24(sp)
   114a4:	01013403          	ld	s0,16(sp)
   114a8:	02010113          	addi	sp,sp,32
   114ac:	00008067          	ret

00000000000114b0 <interrupt_s_timer_c>:

void interrupt_s_timer_c() {
   114b0:	ff010113          	addi	sp,sp,-16
   114b4:	00813423          	sd	s0,8(sp)
   114b8:	01010413          	addi	s0,sp,16
}
   114bc:	00000013          	nop
   114c0:	00813403          	ld	s0,8(sp)
   114c4:	01010113          	addi	sp,sp,16
   114c8:	00008067          	ret

00000000000114cc <interrupt_m_timer_c>:

void interrupt_m_timer_c() {
   114cc:	fd010113          	addi	sp,sp,-48
   114d0:	02113423          	sd	ra,40(sp)
   114d4:	02813023          	sd	s0,32(sp)
   114d8:	00913c23          	sd	s1,24(sp)
   114dc:	03010413          	addi	s0,sp,48
    pnp_map *pnp = (pnp_map *)ADDR_BUS0_XSLV_PNP;
   114e0:	100ff7b7          	lui	a5,0x100ff
   114e4:	fcf43c23          	sd	a5,-40(s0)
    clint_map *clint = (clint_map *)ADDR_BUS0_XSLV_CLINT;
   114e8:	020007b7          	lui	a5,0x2000
   114ec:	fcf43823          	sd	a5,-48(s0)
    pnp->fwdbg1 = clint->mtime;
   114f0:	fd043703          	ld	a4,-48(s0)
   114f4:	0000c7b7          	lui	a5,0xc
   114f8:	00f707b3          	add	a5,a4,a5
   114fc:	ff87b703          	ld	a4,-8(a5) # bff8 <_ftext-0x4008>
   11500:	fd843783          	ld	a5,-40(s0)
   11504:	02e7b423          	sd	a4,40(a5)

    // just to give time before next interrupt
    clint->mtimecmp[fw_get_cpuid()] = clint->mtime + 10000;
   11508:	fd043703          	ld	a4,-48(s0)
   1150c:	0000c7b7          	lui	a5,0xc
   11510:	00f707b3          	add	a5,a4,a5
   11514:	ff87b483          	ld	s1,-8(a5) # bff8 <_ftext-0x4008>
   11518:	7fc010ef          	jal	ra,12d14 <fw_get_cpuid>
   1151c:	00050793          	mv	a5,a0
   11520:	00078613          	mv	a2,a5
   11524:	000027b7          	lui	a5,0x2
   11528:	71078793          	addi	a5,a5,1808 # 2710 <_ftext-0xd8f0>
   1152c:	00f48733          	add	a4,s1,a5
   11530:	fd043683          	ld	a3,-48(s0)
   11534:	000017b7          	lui	a5,0x1
   11538:	80078793          	addi	a5,a5,-2048 # 800 <_ftext-0xf800>
   1153c:	00f607b3          	add	a5,a2,a5
   11540:	00379793          	slli	a5,a5,0x3
   11544:	00f687b3          	add	a5,a3,a5
   11548:	00e7b023          	sd	a4,0(a5)
}
   1154c:	00000013          	nop
   11550:	02813083          	ld	ra,40(sp)
   11554:	02013403          	ld	s0,32(sp)
   11558:	01813483          	ld	s1,24(sp)
   1155c:	03010113          	addi	sp,sp,48
   11560:	00008067          	ret

0000000000011564 <interrupt_s_external_c>:

void interrupt_s_external_c() {
   11564:	fe010113          	addi	sp,sp,-32
   11568:	00113c23          	sd	ra,24(sp)
   1156c:	00813823          	sd	s0,16(sp)
   11570:	02010413          	addi	s0,sp,32
    IRQ_HANDLER *tbl = (IRQ_HANDLER *)fw_get_ram_data(INTERRUPT_TABLE_NAME);
   11574:	0001f7b7          	lui	a5,0x1f
   11578:	fd878513          	addi	a0,a5,-40 # 1efd8 <INTERRUPT_TABLE_NAME>
   1157c:	6ec000ef          	jal	ra,11c68 <fw_get_ram_data>
   11580:	fea43423          	sd	a0,-24(s0)
    uint32_t irqid = plic_claim(CTX_CPU0_S_MODE);
   11584:	00100513          	li	a0,1
   11588:	e09ff0ef          	jal	ra,11390 <plic_claim>
   1158c:	00050793          	mv	a5,a0
   11590:	fef42223          	sw	a5,-28(s0)
    if (tbl[irqid]) {
   11594:	fe446783          	lwu	a5,-28(s0)
   11598:	00379793          	slli	a5,a5,0x3
   1159c:	fe843703          	ld	a4,-24(s0)
   115a0:	00f707b3          	add	a5,a4,a5
   115a4:	0007b783          	ld	a5,0(a5)
   115a8:	02078063          	beqz	a5,115c8 <interrupt_s_external_c+0x64>
        tbl[irqid]();
   115ac:	fe446783          	lwu	a5,-28(s0)
   115b0:	00379793          	slli	a5,a5,0x3
   115b4:	fe843703          	ld	a4,-24(s0)
   115b8:	00f707b3          	add	a5,a4,a5
   115bc:	0007b783          	ld	a5,0(a5)
   115c0:	000780e7          	jalr	a5
   115c4:	00c0006f          	j	115d0 <interrupt_s_external_c+0x6c>
    } else {
        fatal_error();
   115c8:	00000097          	auipc	ra,0x0
   115cc:	d9c080e7          	jalr	-612(ra) # 11364 <fatal_error>
    }
    plic_complete(CTX_CPU0_S_MODE, irqid);
   115d0:	fe442783          	lw	a5,-28(s0)
   115d4:	00078593          	mv	a1,a5
   115d8:	00100513          	li	a0,1
   115dc:	00000097          	auipc	ra,0x0
   115e0:	dfc080e7          	jalr	-516(ra) # 113d8 <plic_complete>
}
   115e4:	00000013          	nop
   115e8:	01813083          	ld	ra,24(sp)
   115ec:	01013403          	ld	s0,16(sp)
   115f0:	02010113          	addi	sp,sp,32
   115f4:	00008067          	ret

00000000000115f8 <interrupt_m_external_c>:

void interrupt_m_external_c() {
   115f8:	fe010113          	addi	sp,sp,-32
   115fc:	00113c23          	sd	ra,24(sp)
   11600:	00813823          	sd	s0,16(sp)
   11604:	02010413          	addi	s0,sp,32
    IRQ_HANDLER *tbl = (IRQ_HANDLER *)fw_get_ram_data(INTERRUPT_TABLE_NAME);
   11608:	0001f7b7          	lui	a5,0x1f
   1160c:	fd878513          	addi	a0,a5,-40 # 1efd8 <INTERRUPT_TABLE_NAME>
   11610:	00000097          	auipc	ra,0x0
   11614:	658080e7          	jalr	1624(ra) # 11c68 <fw_get_ram_data>
   11618:	fea43423          	sd	a0,-24(s0)
    uint32_t irqid = plic_claim(CTX_CPU0_M_MODE);
   1161c:	00000513          	li	a0,0
   11620:	00000097          	auipc	ra,0x0
   11624:	d70080e7          	jalr	-656(ra) # 11390 <plic_claim>
   11628:	00050793          	mv	a5,a0
   1162c:	fef42223          	sw	a5,-28(s0)
    if (tbl[irqid]) {
   11630:	fe446783          	lwu	a5,-28(s0)
   11634:	00379793          	slli	a5,a5,0x3
   11638:	fe843703          	ld	a4,-24(s0)
   1163c:	00f707b3          	add	a5,a4,a5
   11640:	0007b783          	ld	a5,0(a5)
   11644:	02078063          	beqz	a5,11664 <interrupt_m_external_c+0x6c>
        tbl[irqid]();
   11648:	fe446783          	lwu	a5,-28(s0)
   1164c:	00379793          	slli	a5,a5,0x3
   11650:	fe843703          	ld	a4,-24(s0)
   11654:	00f707b3          	add	a5,a4,a5
   11658:	0007b783          	ld	a5,0(a5)
   1165c:	000780e7          	jalr	a5
   11660:	0080006f          	j	11668 <interrupt_m_external_c+0x70>
    } else {
        fatal_error();
   11664:	d01ff0ef          	jal	ra,11364 <fatal_error>
    }
    plic_complete(CTX_CPU0_M_MODE, irqid);
   11668:	fe442783          	lw	a5,-28(s0)
   1166c:	00078593          	mv	a1,a5
   11670:	00000513          	li	a0,0
   11674:	d65ff0ef          	jal	ra,113d8 <plic_complete>
}
   11678:	00000013          	nop
   1167c:	01813083          	ld	ra,24(sp)
   11680:	01013403          	ld	s0,16(sp)
   11684:	02010113          	addi	sp,sp,32
   11688:	00008067          	ret

000000000001168c <interrupt_handler_c>:


/** Interrupt handler in non-vector mode (MODE=0) */
long interrupt_handler_c(long cause, long epc, long long regs[32]) {
   1168c:	fb010113          	addi	sp,sp,-80
   11690:	04113423          	sd	ra,72(sp)
   11694:	04813023          	sd	s0,64(sp)
   11698:	05010413          	addi	s0,sp,80
   1169c:	fca43423          	sd	a0,-56(s0)
   116a0:	fcb43023          	sd	a1,-64(s0)
   116a4:	fac43c23          	sd	a2,-72(s0)
    csr_mcause_type mcause;
    mcause.value = cause;
   116a8:	fc843783          	ld	a5,-56(s0)
   116ac:	fcf43c23          	sd	a5,-40(s0)

    if (mcause.bits.irq == 0x1 && mcause.bits.code == 11) {
   116b0:	fdf44783          	lbu	a5,-33(s0)
   116b4:	f807f793          	andi	a5,a5,-128
   116b8:	0ff7f793          	andi	a5,a5,255
   116bc:	08078863          	beqz	a5,1174c <interrupt_handler_c+0xc0>
   116c0:	fd843703          	ld	a4,-40(s0)
   116c4:	fff00793          	li	a5,-1
   116c8:	0017d793          	srli	a5,a5,0x1
   116cc:	00f77733          	and	a4,a4,a5
   116d0:	00b00793          	li	a5,11
   116d4:	06f71c63          	bne	a4,a5,1174c <interrupt_handler_c+0xc0>
         IRQ_HANDLER *tbl = (IRQ_HANDLER *)fw_get_ram_data(INTERRUPT_TABLE_NAME);
   116d8:	0001f7b7          	lui	a5,0x1f
   116dc:	fd878513          	addi	a0,a5,-40 # 1efd8 <INTERRUPT_TABLE_NAME>
   116e0:	588000ef          	jal	ra,11c68 <fw_get_ram_data>
   116e4:	fea43423          	sd	a0,-24(s0)
         uint32_t irqid = plic_claim(CTX_CPU0_M_MODE);
   116e8:	00000513          	li	a0,0
   116ec:	ca5ff0ef          	jal	ra,11390 <plic_claim>
   116f0:	00050793          	mv	a5,a0
   116f4:	fef42223          	sw	a5,-28(s0)
         if (tbl[irqid]) {
   116f8:	fe446783          	lwu	a5,-28(s0)
   116fc:	00379793          	slli	a5,a5,0x3
   11700:	fe843703          	ld	a4,-24(s0)
   11704:	00f707b3          	add	a5,a4,a5
   11708:	0007b783          	ld	a5,0(a5)
   1170c:	02078063          	beqz	a5,1172c <interrupt_handler_c+0xa0>
             tbl[irqid]();
   11710:	fe446783          	lwu	a5,-28(s0)
   11714:	00379793          	slli	a5,a5,0x3
   11718:	fe843703          	ld	a4,-24(s0)
   1171c:	00f707b3          	add	a5,a4,a5
   11720:	0007b783          	ld	a5,0(a5)
   11724:	000780e7          	jalr	a5
   11728:	00c0006f          	j	11734 <interrupt_handler_c+0xa8>
         } else {
             fatal_error();
   1172c:	00000097          	auipc	ra,0x0
   11730:	c38080e7          	jalr	-968(ra) # 11364 <fatal_error>
         }
         plic_complete(CTX_CPU0_M_MODE, irqid);
   11734:	fe442783          	lw	a5,-28(s0)
   11738:	00078593          	mv	a1,a5
   1173c:	00000513          	li	a0,0
   11740:	00000097          	auipc	ra,0x0
   11744:	c98080e7          	jalr	-872(ra) # 113d8 <plic_complete>
    if (mcause.bits.irq == 0x1 && mcause.bits.code == 11) {
   11748:	0680006f          	j	117b0 <interrupt_handler_c+0x124>
    } else {
       print_uart("mcause:", 7);
   1174c:	00700593          	li	a1,7
   11750:	0001a7b7          	lui	a5,0x1a
   11754:	44878513          	addi	a0,a5,1096 # 1a448 <strnlen+0x46>
   11758:	00001097          	auipc	ra,0x1
   1175c:	034080e7          	jalr	52(ra) # 1278c <print_uart>
       print_uart_hex(cause);
   11760:	fc843783          	ld	a5,-56(s0)
   11764:	00078513          	mv	a0,a5
   11768:	0b8010ef          	jal	ra,12820 <print_uart_hex>
       print_uart(",mepc:", 6);
   1176c:	00600593          	li	a1,6
   11770:	0001a7b7          	lui	a5,0x1a
   11774:	45078513          	addi	a0,a5,1104 # 1a450 <strnlen+0x4e>
   11778:	00001097          	auipc	ra,0x1
   1177c:	014080e7          	jalr	20(ra) # 1278c <print_uart>
       print_uart_hex(epc);
   11780:	fc043783          	ld	a5,-64(s0)
   11784:	00078513          	mv	a0,a5
   11788:	098010ef          	jal	ra,12820 <print_uart_hex>
       print_uart("\r\n", 2);
   1178c:	00200593          	li	a1,2
   11790:	0001a7b7          	lui	a5,0x1a
   11794:	45878513          	addi	a0,a5,1112 # 1a458 <strnlen+0x56>
   11798:	00001097          	auipc	ra,0x1
   1179c:	ff4080e7          	jalr	-12(ra) # 1278c <print_uart>
       /// Exception trap
       led_set(0xF0);
   117a0:	0f000513          	li	a0,240
   117a4:	00001097          	auipc	ra,0x1
   117a8:	7b4080e7          	jalr	1972(ra) # 12f58 <led_set>
       while (1) {}
   117ac:	0000006f          	j	117ac <interrupt_handler_c+0x120>
    }

    return epc;
   117b0:	fc043783          	ld	a5,-64(s0)
}
   117b4:	00078513          	mv	a0,a5
   117b8:	04813083          	ld	ra,72(sp)
   117bc:	04013403          	ld	s0,64(sp)
   117c0:	05010113          	addi	sp,sp,80
   117c4:	00008067          	ret

00000000000117c8 <get_dev_bar>:
static uint64_t get_dev_bar(pnp_map *pnp, uint16_t vid, uint16_t did) {
   117c8:	fb010113          	addi	sp,sp,-80
   117cc:	04813423          	sd	s0,72(sp)
   117d0:	05010413          	addi	s0,sp,80
   117d4:	faa43c23          	sd	a0,-72(s0)
   117d8:	00058793          	mv	a5,a1
   117dc:	00060713          	mv	a4,a2
   117e0:	faf41b23          	sh	a5,-74(s0)
   117e4:	00070793          	mv	a5,a4
   117e8:	faf41a23          	sh	a5,-76(s0)
    int slots_total = (pnp->cfg >> 8) & 0xFF;
   117ec:	fb843783          	ld	a5,-72(s0)
   117f0:	0087a783          	lw	a5,8(a5)
   117f4:	0087d79b          	srliw	a5,a5,0x8
   117f8:	0007879b          	sext.w	a5,a5
   117fc:	0007879b          	sext.w	a5,a5
   11800:	0ff7f793          	andi	a5,a5,255
   11804:	fef42223          	sw	a5,-28(s0)
    int off = 0;
   11808:	fe042623          	sw	zero,-20(s0)
    for (int i = 0; i < slots_total; i++) {
   1180c:	fe042423          	sw	zero,-24(s0)
   11810:	09c0006f          	j	118ac <get_dev_bar+0xe4>
        dcfg = *(dev_cfg_type *)&pnp->cfg_table[off];
   11814:	fec42783          	lw	a5,-20(s0)
   11818:	04078793          	addi	a5,a5,64
   1181c:	fb843703          	ld	a4,-72(s0)
   11820:	00f707b3          	add	a5,a4,a5
   11824:	0007b703          	ld	a4,0(a5)
   11828:	fce43023          	sd	a4,-64(s0)
   1182c:	0087b703          	ld	a4,8(a5)
   11830:	fce43423          	sd	a4,-56(s0)
   11834:	0107b703          	ld	a4,16(a5)
   11838:	fce43823          	sd	a4,-48(s0)
   1183c:	0187b783          	ld	a5,24(a5)
   11840:	fcf43c23          	sd	a5,-40(s0)
        off += sizeof(dcfg);
   11844:	fec42783          	lw	a5,-20(s0)
   11848:	0207879b          	addiw	a5,a5,32
   1184c:	0007879b          	sext.w	a5,a5
   11850:	fef42623          	sw	a5,-20(s0)
        if (dcfg.u.descrtype != PNP_CFG_TYPE_SLAVE) {
   11854:	fc144783          	lbu	a5,-63(s0)
   11858:	0037f793          	andi	a5,a5,3
   1185c:	0ff7f793          	andi	a5,a5,255
   11860:	00078713          	mv	a4,a5
   11864:	00200793          	li	a5,2
   11868:	02f71a63          	bne	a4,a5,1189c <get_dev_bar+0xd4>
        if (dcfg.u.vid == vid && dcfg.u.did == did) {
   1186c:	fc645783          	lhu	a5,-58(s0)
   11870:	fb645703          	lhu	a4,-74(s0)
   11874:	0007071b          	sext.w	a4,a4
   11878:	0007879b          	sext.w	a5,a5
   1187c:	02f71263          	bne	a4,a5,118a0 <get_dev_bar+0xd8>
   11880:	fc445783          	lhu	a5,-60(s0)
   11884:	fb445703          	lhu	a4,-76(s0)
   11888:	0007071b          	sext.w	a4,a4
   1188c:	0007879b          	sext.w	a5,a5
   11890:	00f71863          	bne	a4,a5,118a0 <get_dev_bar+0xd8>
            return dcfg.u.addr_start;
   11894:	fd043783          	ld	a5,-48(s0)
   11898:	02c0006f          	j	118c4 <get_dev_bar+0xfc>
            continue;
   1189c:	00000013          	nop
    for (int i = 0; i < slots_total; i++) {
   118a0:	fe842783          	lw	a5,-24(s0)
   118a4:	0017879b          	addiw	a5,a5,1
   118a8:	fef42423          	sw	a5,-24(s0)
   118ac:	fe842703          	lw	a4,-24(s0)
   118b0:	fe442783          	lw	a5,-28(s0)
   118b4:	0007071b          	sext.w	a4,a4
   118b8:	0007879b          	sext.w	a5,a5
   118bc:	f4f74ce3          	blt	a4,a5,11814 <get_dev_bar+0x4c>
    return DEV_NONE;
   118c0:	fff00793          	li	a5,-1
}
   118c4:	00078513          	mv	a0,a5
   118c8:	04813403          	ld	s0,72(sp)
   118cc:	05010113          	addi	sp,sp,80
   118d0:	00008067          	ret

00000000000118d4 <mpu_region_total>:
static int mpu_region_total() {
   118d4:	fe010113          	addi	sp,sp,-32
   118d8:	00813c23          	sd	s0,24(sp)
   118dc:	02010413          	addi	s0,sp,32
    uint64_t val = 0;
   118e0:	fe043423          	sd	zero,-24(s0)
    asm("csrr %0, 0xBC4" : "=r" (val));
   118e4:	bc4027f3          	csrr	a5,0xbc4
   118e8:	fef43423          	sd	a5,-24(s0)
    return (int)(val >> 8);
   118ec:	fe843783          	ld	a5,-24(s0)
   118f0:	0087d793          	srli	a5,a5,0x8
   118f4:	0007879b          	sext.w	a5,a5
}
   118f8:	00078513          	mv	a0,a5
   118fc:	01813403          	ld	s0,24(sp)
   11900:	02010113          	addi	sp,sp,32
   11904:	00008067          	ret

0000000000011908 <mpu_disable_region>:
static void mpu_disable_region(int idx) {
   11908:	fd010113          	addi	sp,sp,-48
   1190c:	02813423          	sd	s0,40(sp)
   11910:	03010413          	addi	s0,sp,48
   11914:	00050793          	mv	a5,a0
   11918:	fcf42e23          	sw	a5,-36(s0)
    ctrl.value = 0;
   1191c:	fe043423          	sd	zero,-24(s0)
    ctrl.bits.IDX = idx;
   11920:	fdc42783          	lw	a5,-36(s0)
   11924:	0ff7f793          	andi	a5,a5,255
   11928:	fef404a3          	sb	a5,-23(s0)
    ctrl.bits.WE = 1;
   1192c:	fe844783          	lbu	a5,-24(s0)
   11930:	f807e793          	ori	a5,a5,-128
   11934:	fef40423          	sb	a5,-24(s0)
    asm("csrw 0xBC4, %0" : :"r"(ctrl.value));
   11938:	fe843783          	ld	a5,-24(s0)
   1193c:	bc479073          	csrw	0xbc4,a5
}
   11940:	00000013          	nop
   11944:	02813403          	ld	s0,40(sp)
   11948:	03010113          	addi	sp,sp,48
   1194c:	00008067          	ret

0000000000011950 <mpu_enable_region>:
                       const char *rwx) {
   11950:	fb010113          	addi	sp,sp,-80
   11954:	04813423          	sd	s0,72(sp)
   11958:	05010413          	addi	s0,sp,80
   1195c:	00050793          	mv	a5,a0
   11960:	fcb43023          	sd	a1,-64(s0)
   11964:	fac43c23          	sd	a2,-72(s0)
   11968:	fae43823          	sd	a4,-80(s0)
   1196c:	fcf42623          	sw	a5,-52(s0)
   11970:	00068793          	mv	a5,a3
   11974:	fcf42423          	sw	a5,-56(s0)
    uint64_t mask = (~0ull) << 10;
   11978:	c0000793          	li	a5,-1024
   1197c:	fef43423          	sd	a5,-24(s0)
    const char *p = rwx;
   11980:	fb043783          	ld	a5,-80(s0)
   11984:	fef43023          	sd	a5,-32(s0)
    asm("csrw 0xBC2, %0" : :"r"(bar));
   11988:	fc043783          	ld	a5,-64(s0)
   1198c:	bc279073          	csrw	0xbc2,a5
    KB >>= 1;
   11990:	fb843783          	ld	a5,-72(s0)
   11994:	0017d793          	srli	a5,a5,0x1
   11998:	faf43c23          	sd	a5,-72(s0)
    while (KB) {
   1199c:	01c0006f          	j	119b8 <mpu_enable_region+0x68>
        mask <<= 1;
   119a0:	fe843783          	ld	a5,-24(s0)
   119a4:	00179793          	slli	a5,a5,0x1
   119a8:	fef43423          	sd	a5,-24(s0)
        KB >>= 1;
   119ac:	fb843783          	ld	a5,-72(s0)
   119b0:	0017d793          	srli	a5,a5,0x1
   119b4:	faf43c23          	sd	a5,-72(s0)
    while (KB) {
   119b8:	fb843783          	ld	a5,-72(s0)
   119bc:	fe0792e3          	bnez	a5,119a0 <mpu_enable_region+0x50>
    asm("csrw 0xBC3, %0" : :"r"(mask));
   119c0:	fe843783          	ld	a5,-24(s0)
   119c4:	bc379073          	csrw	0xbc3,a5
    ctrl.value = 0;
   119c8:	fc043c23          	sd	zero,-40(s0)
    ctrl.bits.IDX = idx;
   119cc:	fcc42783          	lw	a5,-52(s0)
   119d0:	0ff7f793          	andi	a5,a5,255
   119d4:	fcf40ca3          	sb	a5,-39(s0)
    ctrl.bits.ENA = 1;
   119d8:	fd844783          	lbu	a5,-40(s0)
   119dc:	0107e793          	ori	a5,a5,16
   119e0:	fcf40c23          	sb	a5,-40(s0)
    ctrl.bits.CACHABLE = cached;
   119e4:	fc842783          	lw	a5,-56(s0)
   119e8:	0017f793          	andi	a5,a5,1
   119ec:	0ff7f793          	andi	a5,a5,255
   119f0:	0017f793          	andi	a5,a5,1
   119f4:	0037969b          	slliw	a3,a5,0x3
   119f8:	fd844783          	lbu	a5,-40(s0)
   119fc:	ff77f793          	andi	a5,a5,-9
   11a00:	00078713          	mv	a4,a5
   11a04:	00068793          	mv	a5,a3
   11a08:	00f767b3          	or	a5,a4,a5
   11a0c:	fcf40c23          	sb	a5,-40(s0)
    ctrl.bits.WE = 1; // write into MPU
   11a10:	fd844783          	lbu	a5,-40(s0)
   11a14:	f807e793          	ori	a5,a5,-128
   11a18:	fcf40c23          	sb	a5,-40(s0)
    while (*p) {
   11a1c:	0700006f          	j	11a8c <mpu_enable_region+0x13c>
        if (*p == 'r') {
   11a20:	fe043783          	ld	a5,-32(s0)
   11a24:	0007c783          	lbu	a5,0(a5)
   11a28:	00078713          	mv	a4,a5
   11a2c:	07200793          	li	a5,114
   11a30:	00f71863          	bne	a4,a5,11a40 <mpu_enable_region+0xf0>
            ctrl.bits.RD = 1;
   11a34:	fd844783          	lbu	a5,-40(s0)
   11a38:	0027e793          	ori	a5,a5,2
   11a3c:	fcf40c23          	sb	a5,-40(s0)
        if (*p == 'w') {
   11a40:	fe043783          	ld	a5,-32(s0)
   11a44:	0007c783          	lbu	a5,0(a5)
   11a48:	00078713          	mv	a4,a5
   11a4c:	07700793          	li	a5,119
   11a50:	00f71863          	bne	a4,a5,11a60 <mpu_enable_region+0x110>
            ctrl.bits.WR = 1;
   11a54:	fd844783          	lbu	a5,-40(s0)
   11a58:	0017e793          	ori	a5,a5,1
   11a5c:	fcf40c23          	sb	a5,-40(s0)
        if (*p == 'x') {
   11a60:	fe043783          	ld	a5,-32(s0)
   11a64:	0007c783          	lbu	a5,0(a5)
   11a68:	00078713          	mv	a4,a5
   11a6c:	07800793          	li	a5,120
   11a70:	00f71863          	bne	a4,a5,11a80 <mpu_enable_region+0x130>
            ctrl.bits.EXEC = 1;
   11a74:	fd844783          	lbu	a5,-40(s0)
   11a78:	0047e793          	ori	a5,a5,4
   11a7c:	fcf40c23          	sb	a5,-40(s0)
        p++;
   11a80:	fe043783          	ld	a5,-32(s0)
   11a84:	00178793          	addi	a5,a5,1
   11a88:	fef43023          	sd	a5,-32(s0)
    while (*p) {
   11a8c:	fe043783          	ld	a5,-32(s0)
   11a90:	0007c783          	lbu	a5,0(a5)
   11a94:	f80796e3          	bnez	a5,11a20 <mpu_enable_region+0xd0>
    asm("csrw 0xBC4, %0" : :"r"(ctrl.value));
   11a98:	fd843783          	ld	a5,-40(s0)
   11a9c:	bc479073          	csrw	0xbc4,a5
}
   11aa0:	00000013          	nop
   11aa4:	04813403          	ld	s0,72(sp)
   11aa8:	05010113          	addi	sp,sp,80
   11aac:	00008067          	ret

0000000000011ab0 <fw_malloc_init>:

#include <string.h>
#include <axi_maps.h>
#include "fw_api.h"

void fw_malloc_init() {
   11ab0:	fe010113          	addi	sp,sp,-32
   11ab4:	00813c23          	sd	s0,24(sp)
   11ab8:	02010413          	addi	s0,sp,32
    malloc_type *pool = (malloc_type *)ADDR_BUS0_XSLV_SRAM;
   11abc:	080007b7          	lui	a5,0x8000
   11ac0:	fef43423          	sd	a5,-24(s0)
    pnp_map *pnp = (pnp_map *)ADDR_BUS0_XSLV_PNP;
   11ac4:	100ff7b7          	lui	a5,0x100ff
   11ac8:	fef43023          	sd	a5,-32(s0)
   // 8-bytes alignment
    pool->allocated_sz = (sizeof(malloc_type) + 7) & ~0x7ull;
   11acc:	fe843783          	ld	a5,-24(s0)
   11ad0:	00001737          	lui	a4,0x1
   11ad4:	81870713          	addi	a4,a4,-2024 # 818 <_ftext-0xf7e8>
   11ad8:	00e7b423          	sd	a4,8(a5) # 100ff008 <_end+0x100df76c>
    pool->end = (ADDR_BUS0_XSLV_SRAM + pool->allocated_sz);
   11adc:	fe843783          	ld	a5,-24(s0)
   11ae0:	0087b703          	ld	a4,8(a5)
   11ae4:	080007b7          	lui	a5,0x8000
   11ae8:	00f70733          	add	a4,a4,a5
   11aec:	fe843783          	ld	a5,-24(s0)
   11af0:	00e7b023          	sd	a4,0(a5) # 8000000 <_end+0x7fe0764>
    pool->data_cnt = 0;
   11af4:	fe843703          	ld	a4,-24(s0)
   11af8:	000017b7          	lui	a5,0x1
   11afc:	00f707b3          	add	a5,a4,a5
   11b00:	8007a823          	sw	zero,-2032(a5) # 810 <_ftext-0xf7f0>
    __sync_synchronize();   // gcc mem barrier to avoi re-ordering
   11b04:	0ff0000f          	fence

    // RTL Simulation Debug purpose
    pnp->malloc_addr = pool->end;
   11b08:	fe843783          	ld	a5,-24(s0)
   11b0c:	0007b703          	ld	a4,0(a5)
   11b10:	fe043783          	ld	a5,-32(s0)
   11b14:	00e7bc23          	sd	a4,24(a5)
    pnp->malloc_size = pool->allocated_sz;
   11b18:	fe843783          	ld	a5,-24(s0)
   11b1c:	0087b703          	ld	a4,8(a5)
   11b20:	fe043783          	ld	a5,-32(s0)
   11b24:	02e7b023          	sd	a4,32(a5)
}
   11b28:	00000013          	nop
   11b2c:	01813403          	ld	s0,24(sp)
   11b30:	02010113          	addi	sp,sp,32
   11b34:	00008067          	ret

0000000000011b38 <fw_malloc>:

void *fw_malloc(int size) {
   11b38:	fc010113          	addi	sp,sp,-64
   11b3c:	02813c23          	sd	s0,56(sp)
   11b40:	04010413          	addi	s0,sp,64
   11b44:	00050793          	mv	a5,a0
   11b48:	fcf42623          	sw	a5,-52(s0)
    malloc_type *pool = (malloc_type *)ADDR_BUS0_XSLV_SRAM;
   11b4c:	080007b7          	lui	a5,0x8000
   11b50:	fef43423          	sd	a5,-24(s0)
    pnp_map *pnp = (pnp_map *)ADDR_BUS0_XSLV_PNP;
   11b54:	100ff7b7          	lui	a5,0x100ff
   11b58:	fef43023          	sd	a5,-32(s0)
    void *ret = (void *)pool->end;
   11b5c:	fe843783          	ld	a5,-24(s0)
   11b60:	0007b783          	ld	a5,0(a5) # 100ff000 <_end+0x100df764>
   11b64:	fcf43c23          	sd	a5,-40(s0)
    pool->allocated_sz += (size + 7) & ~0x7ull;
   11b68:	fe843783          	ld	a5,-24(s0)
   11b6c:	0087b703          	ld	a4,8(a5)
   11b70:	fcc42783          	lw	a5,-52(s0)
   11b74:	0077879b          	addiw	a5,a5,7
   11b78:	0007879b          	sext.w	a5,a5
   11b7c:	ff87f793          	andi	a5,a5,-8
   11b80:	00f70733          	add	a4,a4,a5
   11b84:	fe843783          	ld	a5,-24(s0)
   11b88:	00e7b423          	sd	a4,8(a5)
    pool->end = (ADDR_BUS0_XSLV_SRAM + pool->allocated_sz);
   11b8c:	fe843783          	ld	a5,-24(s0)
   11b90:	0087b703          	ld	a4,8(a5)
   11b94:	080007b7          	lui	a5,0x8000
   11b98:	00f70733          	add	a4,a4,a5
   11b9c:	fe843783          	ld	a5,-24(s0)
   11ba0:	00e7b023          	sd	a4,0(a5) # 8000000 <_end+0x7fe0764>

    // RTL Simulation Debug purpose
    pnp->malloc_addr = pool->end;
   11ba4:	fe843783          	ld	a5,-24(s0)
   11ba8:	0007b703          	ld	a4,0(a5)
   11bac:	fe043783          	ld	a5,-32(s0)
   11bb0:	00e7bc23          	sd	a4,24(a5)
    pnp->malloc_size = pool->allocated_sz;
   11bb4:	fe843783          	ld	a5,-24(s0)
   11bb8:	0087b703          	ld	a4,8(a5)
   11bbc:	fe043783          	ld	a5,-32(s0)
   11bc0:	02e7b023          	sd	a4,32(a5)
    return ret;  
   11bc4:	fd843783          	ld	a5,-40(s0)
}
   11bc8:	00078513          	mv	a0,a5
   11bcc:	03813403          	ld	s0,56(sp)
   11bd0:	04010113          	addi	sp,sp,64
   11bd4:	00008067          	ret

0000000000011bd8 <fw_register_ram_data>:

void fw_register_ram_data(const char *name, void *data) {
   11bd8:	fd010113          	addi	sp,sp,-48
   11bdc:	02113423          	sd	ra,40(sp)
   11be0:	02813023          	sd	s0,32(sp)
   11be4:	03010413          	addi	s0,sp,48
   11be8:	fca43c23          	sd	a0,-40(s0)
   11bec:	fcb43823          	sd	a1,-48(s0)
    malloc_type *pool = (malloc_type *)ADDR_BUS0_XSLV_SRAM;
   11bf0:	080007b7          	lui	a5,0x8000
   11bf4:	fef43423          	sd	a5,-24(s0)
    ram_data_type *p = &pool->data[pool->data_cnt++];
   11bf8:	fe843703          	ld	a4,-24(s0)
   11bfc:	000017b7          	lui	a5,0x1
   11c00:	00f707b3          	add	a5,a4,a5
   11c04:	8107a783          	lw	a5,-2032(a5) # 810 <_ftext-0xf7f0>
   11c08:	0017871b          	addiw	a4,a5,1
   11c0c:	0007069b          	sext.w	a3,a4
   11c10:	fe843603          	ld	a2,-24(s0)
   11c14:	00001737          	lui	a4,0x1
   11c18:	00e60733          	add	a4,a2,a4
   11c1c:	80d72823          	sw	a3,-2032(a4) # 810 <_ftext-0xf7f0>
   11c20:	00178793          	addi	a5,a5,1
   11c24:	00479793          	slli	a5,a5,0x4
   11c28:	fe843703          	ld	a4,-24(s0)
   11c2c:	00f707b3          	add	a5,a4,a5
   11c30:	fef43023          	sd	a5,-32(s0)
    memcpy(p->name, name, 8);
   11c34:	fe043783          	ld	a5,-32(s0)
   11c38:	00800613          	li	a2,8
   11c3c:	fd843583          	ld	a1,-40(s0)
   11c40:	00078513          	mv	a0,a5
   11c44:	56a080ef          	jal	ra,1a1ae <memcpy>
    p->pattern = data;
   11c48:	fe043783          	ld	a5,-32(s0)
   11c4c:	fd043703          	ld	a4,-48(s0)
   11c50:	00e7b423          	sd	a4,8(a5)
}
   11c54:	00000013          	nop
   11c58:	02813083          	ld	ra,40(sp)
   11c5c:	02013403          	ld	s0,32(sp)
   11c60:	03010113          	addi	sp,sp,48
   11c64:	00008067          	ret

0000000000011c68 <fw_get_ram_data>:

void *fw_get_ram_data(const char *name) {
   11c68:	fc010113          	addi	sp,sp,-64
   11c6c:	02113c23          	sd	ra,56(sp)
   11c70:	02813823          	sd	s0,48(sp)
   11c74:	04010413          	addi	s0,sp,64
   11c78:	fca43423          	sd	a0,-56(s0)
    malloc_type *pool = (malloc_type *)ADDR_BUS0_XSLV_SRAM;
   11c7c:	080007b7          	lui	a5,0x8000
   11c80:	fef43023          	sd	a5,-32(s0)
    ram_data_type *p;
    for (int i = 0; i < pool->data_cnt; i++) {
   11c84:	fe042623          	sw	zero,-20(s0)
   11c88:	04c0006f          	j	11cd4 <fw_get_ram_data+0x6c>
        p = &pool->data[i];
   11c8c:	fec42783          	lw	a5,-20(s0)
   11c90:	00178793          	addi	a5,a5,1 # 8000001 <_end+0x7fe0765>
   11c94:	00479793          	slli	a5,a5,0x4
   11c98:	fe043703          	ld	a4,-32(s0)
   11c9c:	00f707b3          	add	a5,a4,a5
   11ca0:	fcf43c23          	sd	a5,-40(s0)
        if (strcmp(name, p->name) == 0) {
   11ca4:	fd843783          	ld	a5,-40(s0)
   11ca8:	00078593          	mv	a1,a5
   11cac:	fc843503          	ld	a0,-56(s0)
   11cb0:	668080ef          	jal	ra,1a318 <strcmp>
   11cb4:	00050793          	mv	a5,a0
   11cb8:	00079863          	bnez	a5,11cc8 <fw_get_ram_data+0x60>
            return p->pattern;
   11cbc:	fd843783          	ld	a5,-40(s0)
   11cc0:	0087b783          	ld	a5,8(a5)
   11cc4:	0300006f          	j	11cf4 <fw_get_ram_data+0x8c>
    for (int i = 0; i < pool->data_cnt; i++) {
   11cc8:	fec42783          	lw	a5,-20(s0)
   11ccc:	0017879b          	addiw	a5,a5,1
   11cd0:	fef42623          	sw	a5,-20(s0)
   11cd4:	fe043703          	ld	a4,-32(s0)
   11cd8:	000017b7          	lui	a5,0x1
   11cdc:	00f707b3          	add	a5,a4,a5
   11ce0:	8107a703          	lw	a4,-2032(a5) # 810 <_ftext-0xf7f0>
   11ce4:	fec42783          	lw	a5,-20(s0)
   11ce8:	0007879b          	sext.w	a5,a5
   11cec:	fae7c0e3          	blt	a5,a4,11c8c <fw_get_ram_data+0x24>
        }
    }
    return 0;
   11cf0:	00000793          	li	a5,0
}
   11cf4:	00078513          	mv	a0,a5
   11cf8:	03813083          	ld	ra,56(sp)
   11cfc:	03013403          	ld	s0,48(sp)
   11d00:	04010113          	addi	sp,sp,64
   11d04:	00008067          	ret

0000000000011d08 <get_dev_bar>:
static uint64_t get_dev_bar(pnp_map *pnp, uint16_t vid, uint16_t did) {
   11d08:	fb010113          	addi	sp,sp,-80
   11d0c:	04813423          	sd	s0,72(sp)
   11d10:	05010413          	addi	s0,sp,80
   11d14:	faa43c23          	sd	a0,-72(s0)
   11d18:	00058793          	mv	a5,a1
   11d1c:	00060713          	mv	a4,a2
   11d20:	faf41b23          	sh	a5,-74(s0)
   11d24:	00070793          	mv	a5,a4
   11d28:	faf41a23          	sh	a5,-76(s0)
    int slots_total = (pnp->cfg >> 8) & 0xFF;
   11d2c:	fb843783          	ld	a5,-72(s0)
   11d30:	0087a783          	lw	a5,8(a5)
   11d34:	0087d79b          	srliw	a5,a5,0x8
   11d38:	0007879b          	sext.w	a5,a5
   11d3c:	0007879b          	sext.w	a5,a5
   11d40:	0ff7f793          	andi	a5,a5,255
   11d44:	fef42223          	sw	a5,-28(s0)
    int off = 0;
   11d48:	fe042623          	sw	zero,-20(s0)
    for (int i = 0; i < slots_total; i++) {
   11d4c:	fe042423          	sw	zero,-24(s0)
   11d50:	09c0006f          	j	11dec <get_dev_bar+0xe4>
        dcfg = *(dev_cfg_type *)&pnp->cfg_table[off];
   11d54:	fec42783          	lw	a5,-20(s0)
   11d58:	04078793          	addi	a5,a5,64
   11d5c:	fb843703          	ld	a4,-72(s0)
   11d60:	00f707b3          	add	a5,a4,a5
   11d64:	0007b703          	ld	a4,0(a5)
   11d68:	fce43023          	sd	a4,-64(s0)
   11d6c:	0087b703          	ld	a4,8(a5)
   11d70:	fce43423          	sd	a4,-56(s0)
   11d74:	0107b703          	ld	a4,16(a5)
   11d78:	fce43823          	sd	a4,-48(s0)
   11d7c:	0187b783          	ld	a5,24(a5)
   11d80:	fcf43c23          	sd	a5,-40(s0)
        off += sizeof(dcfg);
   11d84:	fec42783          	lw	a5,-20(s0)
   11d88:	0207879b          	addiw	a5,a5,32
   11d8c:	0007879b          	sext.w	a5,a5
   11d90:	fef42623          	sw	a5,-20(s0)
        if (dcfg.u.descrtype != PNP_CFG_TYPE_SLAVE) {
   11d94:	fc144783          	lbu	a5,-63(s0)
   11d98:	0037f793          	andi	a5,a5,3
   11d9c:	0ff7f793          	andi	a5,a5,255
   11da0:	00078713          	mv	a4,a5
   11da4:	00200793          	li	a5,2
   11da8:	02f71a63          	bne	a4,a5,11ddc <get_dev_bar+0xd4>
        if (dcfg.u.vid == vid && dcfg.u.did == did) {
   11dac:	fc645783          	lhu	a5,-58(s0)
   11db0:	fb645703          	lhu	a4,-74(s0)
   11db4:	0007071b          	sext.w	a4,a4
   11db8:	0007879b          	sext.w	a5,a5
   11dbc:	02f71263          	bne	a4,a5,11de0 <get_dev_bar+0xd8>
   11dc0:	fc445783          	lhu	a5,-60(s0)
   11dc4:	fb445703          	lhu	a4,-76(s0)
   11dc8:	0007071b          	sext.w	a4,a4
   11dcc:	0007879b          	sext.w	a5,a5
   11dd0:	00f71863          	bne	a4,a5,11de0 <get_dev_bar+0xd8>
            return dcfg.u.addr_start;
   11dd4:	fd043783          	ld	a5,-48(s0)
   11dd8:	02c0006f          	j	11e04 <get_dev_bar+0xfc>
            continue;
   11ddc:	00000013          	nop
    for (int i = 0; i < slots_total; i++) {
   11de0:	fe842783          	lw	a5,-24(s0)
   11de4:	0017879b          	addiw	a5,a5,1
   11de8:	fef42423          	sw	a5,-24(s0)
   11dec:	fe842703          	lw	a4,-24(s0)
   11df0:	fe442783          	lw	a5,-28(s0)
   11df4:	0007071b          	sext.w	a4,a4
   11df8:	0007879b          	sext.w	a5,a5
   11dfc:	f4f74ce3          	blt	a4,a5,11d54 <get_dev_bar+0x4c>
    return DEV_NONE;
   11e00:	fff00793          	li	a5,-1
}
   11e04:	00078513          	mv	a0,a5
   11e08:	04813403          	ld	s0,72(sp)
   11e0c:	05010113          	addi	sp,sp,80
   11e10:	00008067          	ret

0000000000011e14 <mpu_region_total>:
static int mpu_region_total() {
   11e14:	fe010113          	addi	sp,sp,-32
   11e18:	00813c23          	sd	s0,24(sp)
   11e1c:	02010413          	addi	s0,sp,32
    uint64_t val = 0;
   11e20:	fe043423          	sd	zero,-24(s0)
    asm("csrr %0, 0xBC4" : "=r" (val));
   11e24:	bc4027f3          	csrr	a5,0xbc4
   11e28:	fef43423          	sd	a5,-24(s0)
    return (int)(val >> 8);
   11e2c:	fe843783          	ld	a5,-24(s0)
   11e30:	0087d793          	srli	a5,a5,0x8
   11e34:	0007879b          	sext.w	a5,a5
}
   11e38:	00078513          	mv	a0,a5
   11e3c:	01813403          	ld	s0,24(sp)
   11e40:	02010113          	addi	sp,sp,32
   11e44:	00008067          	ret

0000000000011e48 <mpu_disable_region>:
static void mpu_disable_region(int idx) {
   11e48:	fd010113          	addi	sp,sp,-48
   11e4c:	02813423          	sd	s0,40(sp)
   11e50:	03010413          	addi	s0,sp,48
   11e54:	00050793          	mv	a5,a0
   11e58:	fcf42e23          	sw	a5,-36(s0)
    ctrl.value = 0;
   11e5c:	fe043423          	sd	zero,-24(s0)
    ctrl.bits.IDX = idx;
   11e60:	fdc42783          	lw	a5,-36(s0)
   11e64:	0ff7f793          	andi	a5,a5,255
   11e68:	fef404a3          	sb	a5,-23(s0)
    ctrl.bits.WE = 1;
   11e6c:	fe844783          	lbu	a5,-24(s0)
   11e70:	f807e793          	ori	a5,a5,-128
   11e74:	fef40423          	sb	a5,-24(s0)
    asm("csrw 0xBC4, %0" : :"r"(ctrl.value));
   11e78:	fe843783          	ld	a5,-24(s0)
   11e7c:	bc479073          	csrw	0xbc4,a5
}
   11e80:	00000013          	nop
   11e84:	02813403          	ld	s0,40(sp)
   11e88:	03010113          	addi	sp,sp,48
   11e8c:	00008067          	ret

0000000000011e90 <mpu_enable_region>:
                       const char *rwx) {
   11e90:	fb010113          	addi	sp,sp,-80
   11e94:	04813423          	sd	s0,72(sp)
   11e98:	05010413          	addi	s0,sp,80
   11e9c:	00050793          	mv	a5,a0
   11ea0:	fcb43023          	sd	a1,-64(s0)
   11ea4:	fac43c23          	sd	a2,-72(s0)
   11ea8:	fae43823          	sd	a4,-80(s0)
   11eac:	fcf42623          	sw	a5,-52(s0)
   11eb0:	00068793          	mv	a5,a3
   11eb4:	fcf42423          	sw	a5,-56(s0)
    uint64_t mask = (~0ull) << 10;
   11eb8:	c0000793          	li	a5,-1024
   11ebc:	fef43423          	sd	a5,-24(s0)
    const char *p = rwx;
   11ec0:	fb043783          	ld	a5,-80(s0)
   11ec4:	fef43023          	sd	a5,-32(s0)
    asm("csrw 0xBC2, %0" : :"r"(bar));
   11ec8:	fc043783          	ld	a5,-64(s0)
   11ecc:	bc279073          	csrw	0xbc2,a5
    KB >>= 1;
   11ed0:	fb843783          	ld	a5,-72(s0)
   11ed4:	0017d793          	srli	a5,a5,0x1
   11ed8:	faf43c23          	sd	a5,-72(s0)
    while (KB) {
   11edc:	01c0006f          	j	11ef8 <mpu_enable_region+0x68>
        mask <<= 1;
   11ee0:	fe843783          	ld	a5,-24(s0)
   11ee4:	00179793          	slli	a5,a5,0x1
   11ee8:	fef43423          	sd	a5,-24(s0)
        KB >>= 1;
   11eec:	fb843783          	ld	a5,-72(s0)
   11ef0:	0017d793          	srli	a5,a5,0x1
   11ef4:	faf43c23          	sd	a5,-72(s0)
    while (KB) {
   11ef8:	fb843783          	ld	a5,-72(s0)
   11efc:	fe0792e3          	bnez	a5,11ee0 <mpu_enable_region+0x50>
    asm("csrw 0xBC3, %0" : :"r"(mask));
   11f00:	fe843783          	ld	a5,-24(s0)
   11f04:	bc379073          	csrw	0xbc3,a5
    ctrl.value = 0;
   11f08:	fc043c23          	sd	zero,-40(s0)
    ctrl.bits.IDX = idx;
   11f0c:	fcc42783          	lw	a5,-52(s0)
   11f10:	0ff7f793          	andi	a5,a5,255
   11f14:	fcf40ca3          	sb	a5,-39(s0)
    ctrl.bits.ENA = 1;
   11f18:	fd844783          	lbu	a5,-40(s0)
   11f1c:	0107e793          	ori	a5,a5,16
   11f20:	fcf40c23          	sb	a5,-40(s0)
    ctrl.bits.CACHABLE = cached;
   11f24:	fc842783          	lw	a5,-56(s0)
   11f28:	0017f793          	andi	a5,a5,1
   11f2c:	0ff7f793          	andi	a5,a5,255
   11f30:	0017f793          	andi	a5,a5,1
   11f34:	0037969b          	slliw	a3,a5,0x3
   11f38:	fd844783          	lbu	a5,-40(s0)
   11f3c:	ff77f793          	andi	a5,a5,-9
   11f40:	00078713          	mv	a4,a5
   11f44:	00068793          	mv	a5,a3
   11f48:	00f767b3          	or	a5,a4,a5
   11f4c:	fcf40c23          	sb	a5,-40(s0)
    ctrl.bits.WE = 1; // write into MPU
   11f50:	fd844783          	lbu	a5,-40(s0)
   11f54:	f807e793          	ori	a5,a5,-128
   11f58:	fcf40c23          	sb	a5,-40(s0)
    while (*p) {
   11f5c:	0700006f          	j	11fcc <mpu_enable_region+0x13c>
        if (*p == 'r') {
   11f60:	fe043783          	ld	a5,-32(s0)
   11f64:	0007c783          	lbu	a5,0(a5)
   11f68:	00078713          	mv	a4,a5
   11f6c:	07200793          	li	a5,114
   11f70:	00f71863          	bne	a4,a5,11f80 <mpu_enable_region+0xf0>
            ctrl.bits.RD = 1;
   11f74:	fd844783          	lbu	a5,-40(s0)
   11f78:	0027e793          	ori	a5,a5,2
   11f7c:	fcf40c23          	sb	a5,-40(s0)
        if (*p == 'w') {
   11f80:	fe043783          	ld	a5,-32(s0)
   11f84:	0007c783          	lbu	a5,0(a5)
   11f88:	00078713          	mv	a4,a5
   11f8c:	07700793          	li	a5,119
   11f90:	00f71863          	bne	a4,a5,11fa0 <mpu_enable_region+0x110>
            ctrl.bits.WR = 1;
   11f94:	fd844783          	lbu	a5,-40(s0)
   11f98:	0017e793          	ori	a5,a5,1
   11f9c:	fcf40c23          	sb	a5,-40(s0)
        if (*p == 'x') {
   11fa0:	fe043783          	ld	a5,-32(s0)
   11fa4:	0007c783          	lbu	a5,0(a5)
   11fa8:	00078713          	mv	a4,a5
   11fac:	07800793          	li	a5,120
   11fb0:	00f71863          	bne	a4,a5,11fc0 <mpu_enable_region+0x130>
            ctrl.bits.EXEC = 1;
   11fb4:	fd844783          	lbu	a5,-40(s0)
   11fb8:	0047e793          	ori	a5,a5,4
   11fbc:	fcf40c23          	sb	a5,-40(s0)
        p++;
   11fc0:	fe043783          	ld	a5,-32(s0)
   11fc4:	00178793          	addi	a5,a5,1
   11fc8:	fef43023          	sd	a5,-32(s0)
    while (*p) {
   11fcc:	fe043783          	ld	a5,-32(s0)
   11fd0:	0007c783          	lbu	a5,0(a5)
   11fd4:	f80796e3          	bnez	a5,11f60 <mpu_enable_region+0xd0>
    asm("csrw 0xBC4, %0" : :"r"(ctrl.value));
   11fd8:	fd843783          	ld	a5,-40(s0)
   11fdc:	bc479073          	csrw	0xbc4,a5
}
   11fe0:	00000013          	nop
   11fe4:	04813403          	ld	s0,72(sp)
   11fe8:	05010113          	addi	sp,sp,80
   11fec:	00008067          	ret

0000000000011ff0 <isr_uart0_tx>:
        p->wrcnt = 0;
    }
}
#endif

void isr_uart0_tx() {
   11ff0:	fe010113          	addi	sp,sp,-32
   11ff4:	00113c23          	sd	ra,24(sp)
   11ff8:	00813823          	sd	s0,16(sp)
   11ffc:	02010413          	addi	s0,sp,32
    uart_data_type *pdata = fw_get_ram_data(UART0_NAME);
   12000:	0001f7b7          	lui	a5,0x1f
   12004:	0c078513          	addi	a0,a5,192 # 1f0c0 <UART0_NAME>
   12008:	00000097          	auipc	ra,0x0
   1200c:	c60080e7          	jalr	-928(ra) # 11c68 <fw_get_ram_data>
   12010:	fea43423          	sd	a0,-24(s0)
    uart_map *uart = (uart_map *)ADDR_BUS0_XSLV_UART0;
   12014:	100107b7          	lui	a5,0x10010
   12018:	fef43023          	sd	a5,-32(s0)
             break;
        }
        uart->txdata = buf_get(pdata);
    }
#endif
}
   1201c:	00000013          	nop
   12020:	01813083          	ld	ra,24(sp)
   12024:	01013403          	ld	s0,16(sp)
   12028:	02010113          	addi	sp,sp,32
   1202c:	00008067          	ret

0000000000012030 <uart_isr_init>:
    uart_data_type *pdata = fw_get_ram_data(UART0_NAME);
    return buf_total(pdata);
}
#endif

void uart_isr_init(void) {
   12030:	fd010113          	addi	sp,sp,-48
   12034:	02113423          	sd	ra,40(sp)
   12038:	02813023          	sd	s0,32(sp)
   1203c:	03010413          	addi	s0,sp,48
    uart_map *uart = (uart_map *)ADDR_BUS0_XSLV_UART0;
   12040:	100107b7          	lui	a5,0x10010
   12044:	fef43423          	sd	a5,-24(s0)
    uart_data_type *pdata;

    register_ext_interrupt_handler(CFG_IRQ_UART0, isr_uart0_tx);
   12048:	000127b7          	lui	a5,0x12
   1204c:	ff078593          	addi	a1,a5,-16 # 11ff0 <isr_uart0_tx>
   12050:	02700513          	li	a0,39
   12054:	ab8ff0ef          	jal	ra,1130c <register_ext_interrupt_handler>

    pdata = fw_malloc(sizeof(uart_data_type));
   12058:	09000513          	li	a0,144
   1205c:	addff0ef          	jal	ra,11b38 <fw_malloc>
   12060:	fea43023          	sd	a0,-32(s0)
#ifdef UART_BUF_ENABLE    
    pdata->fifo = fw_malloc(UART_BUF_SZ);
    pdata->wrcnt = 1;
    pdata->rdcnt = 0;
#else
    pdata->fifo = 0;
   12064:	fe043783          	ld	a5,-32(s0)
   12068:	0007b023          	sd	zero,0(a5)
    pdata->wrcnt = 0;
   1206c:	fe043783          	ld	a5,-32(s0)
   12070:	0807a423          	sw	zero,136(a5)
    pdata->rdcnt = 0;
   12074:	fe043783          	ld	a5,-32(s0)
   12078:	0807a623          	sw	zero,140(a5)
#endif
    fw_register_ram_data(UART0_NAME, pdata);
   1207c:	fe043583          	ld	a1,-32(s0)
   12080:	0001f7b7          	lui	a5,0x1f
   12084:	0c078513          	addi	a0,a5,192 # 1f0c0 <UART0_NAME>
   12088:	00000097          	auipc	ra,0x0
   1208c:	b50080e7          	jalr	-1200(ra) # 11bd8 <fw_register_ram_data>

    // scaler is enabled in SRAM self test, duplicate it here
    uart->scaler = SYS_HZ / 115200 / 2;
   12090:	fe843783          	ld	a5,-24(s0)
   12094:	0ad00713          	li	a4,173
   12098:	00e7ac23          	sw	a4,24(a5)
    uart->txctrl = 0x1;  // txen=1
   1209c:	fe843783          	ld	a5,-24(s0)
   120a0:	00100713          	li	a4,1
   120a4:	00e7a423          	sw	a4,8(a5)
    uart->rxctrl = 0x1;  // rxen=1
   120a8:	fe843783          	ld	a5,-24(s0)
   120ac:	00100713          	li	a4,1
   120b0:	00e7a623          	sw	a4,12(a5)
    uart_irq_type ie;
    ie.v = 0;
   120b4:	fc042c23          	sw	zero,-40(s0)
#ifdef UART_BUF_ENABLE    
    ie.b.txwm = 1;
    ie.b.rxwm = 0;
#endif
    uart->ie = ie.v;
   120b8:	fd842783          	lw	a5,-40(s0)
   120bc:	0007871b          	sext.w	a4,a5
   120c0:	fe843783          	ld	a5,-24(s0)
   120c4:	00e7a823          	sw	a4,16(a5)

    fw_enable_plic_irq(CTX_CPU0_M_MODE, CFG_IRQ_UART0);
   120c8:	02700593          	li	a1,39
   120cc:	00000513          	li	a0,0
   120d0:	00001097          	auipc	ra,0x1
   120d4:	d5c080e7          	jalr	-676(ra) # 12e2c <fw_enable_plic_irq>
}
   120d8:	00000013          	nop
   120dc:	02813083          	ld	ra,40(sp)
   120e0:	02013403          	ld	s0,32(sp)
   120e4:	03010113          	addi	sp,sp,48
   120e8:	00008067          	ret

00000000000120ec <printnum>:
static void printnum(f_putch putch,
                     void **putdat,
                     uint64_t num,
                     unsigned base,
                     int width,
                     int padc) {
   120ec:	fb010113          	addi	sp,sp,-80
   120f0:	04113423          	sd	ra,72(sp)
   120f4:	04813023          	sd	s0,64(sp)
   120f8:	05010413          	addi	s0,sp,80
   120fc:	fca43c23          	sd	a0,-40(s0)
   12100:	fcb43823          	sd	a1,-48(s0)
   12104:	fcc43423          	sd	a2,-56(s0)
   12108:	00068613          	mv	a2,a3
   1210c:	00070693          	mv	a3,a4
   12110:	00078713          	mv	a4,a5
   12114:	00060793          	mv	a5,a2
   12118:	fcf42223          	sw	a5,-60(s0)
   1211c:	00068793          	mv	a5,a3
   12120:	fcf42023          	sw	a5,-64(s0)
   12124:	00070793          	mv	a5,a4
   12128:	faf42e23          	sw	a5,-68(s0)
    uart_data_type *p = fw_get_ram_data(UART0_NAME);
   1212c:	0001f7b7          	lui	a5,0x1f
   12130:	0c078513          	addi	a0,a5,192 # 1f0c0 <UART0_NAME>
   12134:	00000097          	auipc	ra,0x0
   12138:	b34080e7          	jalr	-1228(ra) # 11c68 <fw_get_ram_data>
   1213c:	fea43023          	sd	a0,-32(s0)
    int pos = 0;
   12140:	fe042623          	sw	zero,-20(s0)

    while (1) {
        p->digs[pos++] = num % base;
   12144:	fc446783          	lwu	a5,-60(s0)
   12148:	fc843703          	ld	a4,-56(s0)
   1214c:	02f776b3          	remu	a3,a4,a5
   12150:	fec42783          	lw	a5,-20(s0)
   12154:	0017871b          	addiw	a4,a5,1
   12158:	fee42623          	sw	a4,-20(s0)
   1215c:	0006871b          	sext.w	a4,a3
   12160:	fe043683          	ld	a3,-32(s0)
   12164:	00279793          	slli	a5,a5,0x2
   12168:	00f687b3          	add	a5,a3,a5
   1216c:	00e7a423          	sw	a4,8(a5)
        if (num < base) {
   12170:	fc446783          	lwu	a5,-60(s0)
   12174:	fc843703          	ld	a4,-56(s0)
   12178:	00f76c63          	bltu	a4,a5,12190 <printnum+0xa4>
            break;
        }
        num /= base;
   1217c:	fc446783          	lwu	a5,-60(s0)
   12180:	fc843703          	ld	a4,-56(s0)
   12184:	02f757b3          	divu	a5,a4,a5
   12188:	fcf43423          	sd	a5,-56(s0)
        p->digs[pos++] = num % base;
   1218c:	fb9ff06f          	j	12144 <printnum+0x58>
            break;
   12190:	00000013          	nop
    }

    while (width-- > pos) {
   12194:	0180006f          	j	121ac <printnum+0xc0>
        putch(padc, putdat);
   12198:	fbc42783          	lw	a5,-68(s0)
   1219c:	fd843703          	ld	a4,-40(s0)
   121a0:	fd043583          	ld	a1,-48(s0)
   121a4:	00078513          	mv	a0,a5
   121a8:	000700e7          	jalr	a4
    while (width-- > pos) {
   121ac:	fc042783          	lw	a5,-64(s0)
   121b0:	fff7871b          	addiw	a4,a5,-1
   121b4:	fce42023          	sw	a4,-64(s0)
   121b8:	fec42703          	lw	a4,-20(s0)
   121bc:	0007071b          	sext.w	a4,a4
   121c0:	fcf74ce3          	blt	a4,a5,12198 <printnum+0xac>
    }

    while (pos-- > 0) {
   121c4:	0600006f          	j	12224 <printnum+0x138>
        putch(p->digs[pos] + (p->digs[pos] >= 10 ? 'a' - 10 : '0'), putdat);
   121c8:	fe043703          	ld	a4,-32(s0)
   121cc:	fec42783          	lw	a5,-20(s0)
   121d0:	00279793          	slli	a5,a5,0x2
   121d4:	00f707b3          	add	a5,a4,a5
   121d8:	0087a703          	lw	a4,8(a5)
   121dc:	fe043683          	ld	a3,-32(s0)
   121e0:	fec42783          	lw	a5,-20(s0)
   121e4:	00279793          	slli	a5,a5,0x2
   121e8:	00f687b3          	add	a5,a3,a5
   121ec:	0087a783          	lw	a5,8(a5)
   121f0:	00078693          	mv	a3,a5
   121f4:	00900793          	li	a5,9
   121f8:	00d7f663          	bleu	a3,a5,12204 <printnum+0x118>
   121fc:	05700793          	li	a5,87
   12200:	0080006f          	j	12208 <printnum+0x11c>
   12204:	03000793          	li	a5,48
   12208:	00e787bb          	addw	a5,a5,a4
   1220c:	0007879b          	sext.w	a5,a5
   12210:	0007879b          	sext.w	a5,a5
   12214:	fd843703          	ld	a4,-40(s0)
   12218:	fd043583          	ld	a1,-48(s0)
   1221c:	00078513          	mv	a0,a5
   12220:	000700e7          	jalr	a4
    while (pos-- > 0) {
   12224:	fec42783          	lw	a5,-20(s0)
   12228:	fff7871b          	addiw	a4,a5,-1
   1222c:	fee42623          	sw	a4,-20(s0)
   12230:	f8f04ce3          	bgtz	a5,121c8 <printnum+0xdc>
    }
}
   12234:	00000013          	nop
   12238:	04813083          	ld	ra,72(sp)
   1223c:	04013403          	ld	s0,64(sp)
   12240:	05010113          	addi	sp,sp,80
   12244:	00008067          	ret

0000000000012248 <getuint>:

static uint64_t getuint(va_list *ap, int lflag) {
   12248:	fe010113          	addi	sp,sp,-32
   1224c:	00813c23          	sd	s0,24(sp)
   12250:	02010413          	addi	s0,sp,32
   12254:	fea43423          	sd	a0,-24(s0)
   12258:	00058793          	mv	a5,a1
   1225c:	fef42223          	sw	a5,-28(s0)
    if (lflag >= 2) {
   12260:	fe442783          	lw	a5,-28(s0)
   12264:	0007871b          	sext.w	a4,a5
   12268:	00100793          	li	a5,1
   1226c:	02e7d063          	ble	a4,a5,1228c <getuint+0x44>
        return va_arg(*ap, unsigned long long);
   12270:	fe843783          	ld	a5,-24(s0)
   12274:	0007b783          	ld	a5,0(a5)
   12278:	00878693          	addi	a3,a5,8
   1227c:	fe843703          	ld	a4,-24(s0)
   12280:	00d73023          	sd	a3,0(a4)
   12284:	0007b783          	ld	a5,0(a5)
   12288:	04c0006f          	j	122d4 <getuint+0x8c>
    } else if (lflag) {
   1228c:	fe442783          	lw	a5,-28(s0)
   12290:	0007879b          	sext.w	a5,a5
   12294:	02078063          	beqz	a5,122b4 <getuint+0x6c>
        return va_arg(*ap, unsigned long);
   12298:	fe843783          	ld	a5,-24(s0)
   1229c:	0007b783          	ld	a5,0(a5)
   122a0:	00878693          	addi	a3,a5,8
   122a4:	fe843703          	ld	a4,-24(s0)
   122a8:	00d73023          	sd	a3,0(a4)
   122ac:	0007b783          	ld	a5,0(a5)
   122b0:	0240006f          	j	122d4 <getuint+0x8c>
    }
    return va_arg(*ap, unsigned int);
   122b4:	fe843783          	ld	a5,-24(s0)
   122b8:	0007b783          	ld	a5,0(a5)
   122bc:	00878693          	addi	a3,a5,8
   122c0:	fe843703          	ld	a4,-24(s0)
   122c4:	00d73023          	sd	a3,0(a4)
   122c8:	0007a783          	lw	a5,0(a5)
   122cc:	02079793          	slli	a5,a5,0x20
   122d0:	0207d793          	srli	a5,a5,0x20
}
   122d4:	00078513          	mv	a0,a5
   122d8:	01813403          	ld	s0,24(sp)
   122dc:	02010113          	addi	sp,sp,32
   122e0:	00008067          	ret

00000000000122e4 <getint>:

static int64_t getint(va_list *ap, int lflag) {
   122e4:	fe010113          	addi	sp,sp,-32
   122e8:	00813c23          	sd	s0,24(sp)
   122ec:	02010413          	addi	s0,sp,32
   122f0:	fea43423          	sd	a0,-24(s0)
   122f4:	00058793          	mv	a5,a1
   122f8:	fef42223          	sw	a5,-28(s0)
    if (lflag >= 2) {
   122fc:	fe442783          	lw	a5,-28(s0)
   12300:	0007871b          	sext.w	a4,a5
   12304:	00100793          	li	a5,1
   12308:	02e7d063          	ble	a4,a5,12328 <getint+0x44>
        return va_arg(*ap, long long);
   1230c:	fe843783          	ld	a5,-24(s0)
   12310:	0007b783          	ld	a5,0(a5)
   12314:	00878693          	addi	a3,a5,8
   12318:	fe843703          	ld	a4,-24(s0)
   1231c:	00d73023          	sd	a3,0(a4)
   12320:	0007b783          	ld	a5,0(a5)
   12324:	0440006f          	j	12368 <getint+0x84>
    } else if (lflag) {
   12328:	fe442783          	lw	a5,-28(s0)
   1232c:	0007879b          	sext.w	a5,a5
   12330:	02078063          	beqz	a5,12350 <getint+0x6c>
        return va_arg(*ap, long);
   12334:	fe843783          	ld	a5,-24(s0)
   12338:	0007b783          	ld	a5,0(a5)
   1233c:	00878693          	addi	a3,a5,8
   12340:	fe843703          	ld	a4,-24(s0)
   12344:	00d73023          	sd	a3,0(a4)
   12348:	0007b783          	ld	a5,0(a5)
   1234c:	01c0006f          	j	12368 <getint+0x84>
    }
    return va_arg(*ap, int);
   12350:	fe843783          	ld	a5,-24(s0)
   12354:	0007b783          	ld	a5,0(a5)
   12358:	00878693          	addi	a3,a5,8
   1235c:	fe843703          	ld	a4,-24(s0)
   12360:	00d73023          	sd	a3,0(a4)
   12364:	0007a783          	lw	a5,0(a5)
}
   12368:	00078513          	mv	a0,a5
   1236c:	01813403          	ld	s0,24(sp)
   12370:	02010113          	addi	sp,sp,32
   12374:	00008067          	ret

0000000000012378 <vprintfmt_lib>:

void vprintfmt_lib(f_putch putch,
                   void **putdat,
                   const char *fmt,
                   va_list ap) {
   12378:	f9010113          	addi	sp,sp,-112
   1237c:	06113423          	sd	ra,104(sp)
   12380:	06813023          	sd	s0,96(sp)
   12384:	04913c23          	sd	s1,88(sp)
   12388:	05213823          	sd	s2,80(sp)
   1238c:	07010413          	addi	s0,sp,112
   12390:	faa43423          	sd	a0,-88(s0)
   12394:	fab43023          	sd	a1,-96(s0)
   12398:	f8c43c23          	sd	a2,-104(s0)
   1239c:	f8d43823          	sd	a3,-112(s0)
    unsigned long long num;
    int base, lflag, width, precision;// altflag;
    char padc;

    while (1) {
        while ((ch = *(unsigned char *) fmt) != '%') {
   123a0:	0240006f          	j	123c4 <vprintfmt_lib+0x4c>
            if (ch == '\0') {
   123a4:	3c048663          	beqz	s1,12770 <vprintfmt_lib+0x3f8>
                return;
            }
            fmt++;
   123a8:	f9843783          	ld	a5,-104(s0)
   123ac:	00178793          	addi	a5,a5,1
   123b0:	f8f43c23          	sd	a5,-104(s0)
            putch(ch, putdat);
   123b4:	fa843783          	ld	a5,-88(s0)
   123b8:	fa043583          	ld	a1,-96(s0)
   123bc:	00048513          	mv	a0,s1
   123c0:	000780e7          	jalr	a5
        while ((ch = *(unsigned char *) fmt) != '%') {
   123c4:	f9843783          	ld	a5,-104(s0)
   123c8:	0007c783          	lbu	a5,0(a5)
   123cc:	0007849b          	sext.w	s1,a5
   123d0:	00048713          	mv	a4,s1
   123d4:	02500793          	li	a5,37
   123d8:	fcf716e3          	bne	a4,a5,123a4 <vprintfmt_lib+0x2c>
        }
        fmt++;
   123dc:	f9843783          	ld	a5,-104(s0)
   123e0:	00178793          	addi	a5,a5,1
   123e4:	f8f43c23          	sd	a5,-104(s0)

        // Process a %-escape sequence
        last_fmt = fmt;
   123e8:	f9843783          	ld	a5,-104(s0)
   123ec:	faf43c23          	sd	a5,-72(s0)
        padc = ' ';
   123f0:	02000793          	li	a5,32
   123f4:	fcf403a3          	sb	a5,-57(s0)
        width = -1;
   123f8:	fff00793          	li	a5,-1
   123fc:	fcf42623          	sw	a5,-52(s0)
        precision = -1;
   12400:	fff00793          	li	a5,-1
   12404:	fcf42423          	sw	a5,-56(s0)
        lflag = 0;
   12408:	fc042823          	sw	zero,-48(s0)
        //altflag = 0;
reswitch:
        switch (ch = *(unsigned char *) fmt++) {
   1240c:	f9843783          	ld	a5,-104(s0)
   12410:	00178713          	addi	a4,a5,1
   12414:	f8e43c23          	sd	a4,-104(s0)
   12418:	0007c783          	lbu	a5,0(a5)
   1241c:	0007849b          	sext.w	s1,a5
   12420:	fdd4869b          	addiw	a3,s1,-35
   12424:	0006871b          	sext.w	a4,a3
   12428:	05500793          	li	a5,85
   1242c:	32e7e263          	bltu	a5,a4,12750 <vprintfmt_lib+0x3d8>
   12430:	02069793          	slli	a5,a3,0x20
   12434:	0207d793          	srli	a5,a5,0x20
   12438:	00279713          	slli	a4,a5,0x2
   1243c:	0001a7b7          	lui	a5,0x1a
   12440:	47078793          	addi	a5,a5,1136 # 1a470 <strnlen+0x6e>
   12444:	00f707b3          	add	a5,a4,a5
   12448:	0007a783          	lw	a5,0(a5)
   1244c:	00078067          	jr	a5
        // flag to pad on the right
        case '-':
            padc = '-';
   12450:	02d00793          	li	a5,45
   12454:	fcf403a3          	sb	a5,-57(s0)
            goto reswitch;
   12458:	fb5ff06f          	j	1240c <vprintfmt_lib+0x94>
      
        // flag to pad with 0's instead of spaces
        case '0':
            padc = '0';
   1245c:	03000793          	li	a5,48
   12460:	fcf403a3          	sb	a5,-57(s0)
            goto reswitch;
   12464:	fa9ff06f          	j	1240c <vprintfmt_lib+0x94>
        case '5':
        case '6':
        case '7':
        case '8':
        case '9':
            for (precision = 0; ; ++fmt) {
   12468:	fc042423          	sw	zero,-56(s0)
                precision = precision * 10 + ch - '0';
   1246c:	fc842703          	lw	a4,-56(s0)
   12470:	00070793          	mv	a5,a4
   12474:	0027979b          	slliw	a5,a5,0x2
   12478:	00e787bb          	addw	a5,a5,a4
   1247c:	0017979b          	slliw	a5,a5,0x1
   12480:	0007879b          	sext.w	a5,a5
   12484:	00f487bb          	addw	a5,s1,a5
   12488:	0007879b          	sext.w	a5,a5
   1248c:	fd07879b          	addiw	a5,a5,-48
   12490:	fcf42423          	sw	a5,-56(s0)
                ch = *fmt;
   12494:	f9843783          	ld	a5,-104(s0)
   12498:	0007c783          	lbu	a5,0(a5)
   1249c:	0007849b          	sext.w	s1,a5
                if (ch < '0' || ch > '9') {
   124a0:	00048713          	mv	a4,s1
   124a4:	02f00793          	li	a5,47
   124a8:	04e7d663          	ble	a4,a5,124f4 <vprintfmt_lib+0x17c>
   124ac:	00048713          	mv	a4,s1
   124b0:	03900793          	li	a5,57
   124b4:	04e7c063          	blt	a5,a4,124f4 <vprintfmt_lib+0x17c>
            for (precision = 0; ; ++fmt) {
   124b8:	f9843783          	ld	a5,-104(s0)
   124bc:	00178793          	addi	a5,a5,1
   124c0:	f8f43c23          	sd	a5,-104(s0)
                precision = precision * 10 + ch - '0';
   124c4:	fa9ff06f          	j	1246c <vprintfmt_lib+0xf4>
                }
            }
            goto process_precision;

        case '*':
            precision = va_arg(ap, int);
   124c8:	f9043783          	ld	a5,-112(s0)
   124cc:	00878713          	addi	a4,a5,8
   124d0:	f8e43823          	sd	a4,-112(s0)
   124d4:	0007a783          	lw	a5,0(a5)
   124d8:	fcf42423          	sw	a5,-56(s0)
            goto process_precision;
   124dc:	01c0006f          	j	124f8 <vprintfmt_lib+0x180>

        case '.':
            if (width < 0) {
   124e0:	fcc42783          	lw	a5,-52(s0)
   124e4:	0007879b          	sext.w	a5,a5
   124e8:	f207d2e3          	bgez	a5,1240c <vprintfmt_lib+0x94>
                width = 0;
   124ec:	fc042623          	sw	zero,-52(s0)
            }
            goto reswitch;
   124f0:	f1dff06f          	j	1240c <vprintfmt_lib+0x94>
            goto process_precision;
   124f4:	00000013          	nop
        case '#':
            //altflag = 1;
            goto reswitch;

process_precision:
            if (width < 0) {
   124f8:	fcc42783          	lw	a5,-52(s0)
   124fc:	0007879b          	sext.w	a5,a5
   12500:	f007d6e3          	bgez	a5,1240c <vprintfmt_lib+0x94>
                width = precision, precision = -1;
   12504:	fc842783          	lw	a5,-56(s0)
   12508:	fcf42623          	sw	a5,-52(s0)
   1250c:	fff00793          	li	a5,-1
   12510:	fcf42423          	sw	a5,-56(s0)
            }
            goto reswitch;
   12514:	ef9ff06f          	j	1240c <vprintfmt_lib+0x94>

        // long flag (doubled for long long)
        case 'l':
            lflag++;
   12518:	fd042783          	lw	a5,-48(s0)
   1251c:	0017879b          	addiw	a5,a5,1
   12520:	fcf42823          	sw	a5,-48(s0)
            goto reswitch;
   12524:	ee9ff06f          	j	1240c <vprintfmt_lib+0x94>

        // character
        case 'c':
            putch(va_arg(ap, int), putdat);
   12528:	f9043783          	ld	a5,-112(s0)
   1252c:	00878713          	addi	a4,a5,8
   12530:	f8e43823          	sd	a4,-112(s0)
   12534:	0007a783          	lw	a5,0(a5)
   12538:	fa843703          	ld	a4,-88(s0)
   1253c:	fa043583          	ld	a1,-96(s0)
   12540:	00078513          	mv	a0,a5
   12544:	000700e7          	jalr	a4
            break;
   12548:	2240006f          	j	1276c <vprintfmt_lib+0x3f4>

        // string
        case 's':
            if ((p = va_arg(ap, char *)) == 0) {
   1254c:	f9043783          	ld	a5,-112(s0)
   12550:	00878713          	addi	a4,a5,8
   12554:	f8e43823          	sd	a4,-112(s0)
   12558:	0007b903          	ld	s2,0(a5)
   1255c:	00091663          	bnez	s2,12568 <vprintfmt_lib+0x1f0>
                p = "(null)";
   12560:	0001a7b7          	lui	a5,0x1a
   12564:	46878913          	addi	s2,a5,1128 # 1a468 <strnlen+0x66>
            }
            if (width > 0 && padc != '-') {
   12568:	fcc42783          	lw	a5,-52(s0)
   1256c:	0007879b          	sext.w	a5,a5
   12570:	08f05a63          	blez	a5,12604 <vprintfmt_lib+0x28c>
   12574:	fc744783          	lbu	a5,-57(s0)
   12578:	0ff7f713          	andi	a4,a5,255
   1257c:	02d00793          	li	a5,45
   12580:	08f70263          	beq	a4,a5,12604 <vprintfmt_lib+0x28c>
                for (width -= (int)strnlen(p, precision); width > 0; width--) {
   12584:	fc842783          	lw	a5,-56(s0)
   12588:	00078593          	mv	a1,a5
   1258c:	00090513          	mv	a0,s2
   12590:	00008097          	auipc	ra,0x8
   12594:	e72080e7          	jalr	-398(ra) # 1a402 <strnlen>
   12598:	00050793          	mv	a5,a0
   1259c:	0007879b          	sext.w	a5,a5
   125a0:	fcc42703          	lw	a4,-52(s0)
   125a4:	40f707bb          	subw	a5,a4,a5
   125a8:	fcf42623          	sw	a5,-52(s0)
   125ac:	0280006f          	j	125d4 <vprintfmt_lib+0x25c>
                    putch(padc, putdat);
   125b0:	fc744783          	lbu	a5,-57(s0)
   125b4:	0007879b          	sext.w	a5,a5
   125b8:	fa843703          	ld	a4,-88(s0)
   125bc:	fa043583          	ld	a1,-96(s0)
   125c0:	00078513          	mv	a0,a5
   125c4:	000700e7          	jalr	a4
                for (width -= (int)strnlen(p, precision); width > 0; width--) {
   125c8:	fcc42783          	lw	a5,-52(s0)
   125cc:	fff7879b          	addiw	a5,a5,-1
   125d0:	fcf42623          	sw	a5,-52(s0)
   125d4:	fcc42783          	lw	a5,-52(s0)
   125d8:	0007879b          	sext.w	a5,a5
   125dc:	fcf04ae3          	bgtz	a5,125b0 <vprintfmt_lib+0x238>
                }
            }
            for (; (ch = *p) != '\0' && (precision < 0 || --precision >= 0); width--) {
   125e0:	0240006f          	j	12604 <vprintfmt_lib+0x28c>
                putch(ch, putdat);
   125e4:	fa843783          	ld	a5,-88(s0)
   125e8:	fa043583          	ld	a1,-96(s0)
   125ec:	00048513          	mv	a0,s1
   125f0:	000780e7          	jalr	a5
                p++;
   125f4:	00190913          	addi	s2,s2,1
            for (; (ch = *p) != '\0' && (precision < 0 || --precision >= 0); width--) {
   125f8:	fcc42783          	lw	a5,-52(s0)
   125fc:	fff7879b          	addiw	a5,a5,-1
   12600:	fcf42623          	sw	a5,-52(s0)
   12604:	00094783          	lbu	a5,0(s2)
   12608:	0007849b          	sext.w	s1,a5
   1260c:	04048463          	beqz	s1,12654 <vprintfmt_lib+0x2dc>
   12610:	fc842783          	lw	a5,-56(s0)
   12614:	0007879b          	sext.w	a5,a5
   12618:	fc07c6e3          	bltz	a5,125e4 <vprintfmt_lib+0x26c>
   1261c:	fc842783          	lw	a5,-56(s0)
   12620:	fff7879b          	addiw	a5,a5,-1
   12624:	fcf42423          	sw	a5,-56(s0)
   12628:	fc842783          	lw	a5,-56(s0)
   1262c:	0007879b          	sext.w	a5,a5
   12630:	fa07dae3          	bgez	a5,125e4 <vprintfmt_lib+0x26c>
            }
            for (; width > 0; width--) {
   12634:	0200006f          	j	12654 <vprintfmt_lib+0x2dc>
                putch(' ', putdat);
   12638:	fa843783          	ld	a5,-88(s0)
   1263c:	fa043583          	ld	a1,-96(s0)
   12640:	02000513          	li	a0,32
   12644:	000780e7          	jalr	a5
            for (; width > 0; width--) {
   12648:	fcc42783          	lw	a5,-52(s0)
   1264c:	fff7879b          	addiw	a5,a5,-1
   12650:	fcf42623          	sw	a5,-52(s0)
   12654:	fcc42783          	lw	a5,-52(s0)
   12658:	0007879b          	sext.w	a5,a5
   1265c:	fcf04ee3          	bgtz	a5,12638 <vprintfmt_lib+0x2c0>
            }
            break;
   12660:	10c0006f          	j	1276c <vprintfmt_lib+0x3f4>

        // (signed) decimal
        case 'd':
            num = getint(&ap, lflag);
   12664:	fd042703          	lw	a4,-48(s0)
   12668:	f9040793          	addi	a5,s0,-112
   1266c:	00070593          	mv	a1,a4
   12670:	00078513          	mv	a0,a5
   12674:	00000097          	auipc	ra,0x0
   12678:	c70080e7          	jalr	-912(ra) # 122e4 <getint>
   1267c:	00050793          	mv	a5,a0
   12680:	fcf43c23          	sd	a5,-40(s0)
            if ((long long) num < 0) {
   12684:	fd843783          	ld	a5,-40(s0)
   12688:	0207d063          	bgez	a5,126a8 <vprintfmt_lib+0x330>
                putch('-', putdat);
   1268c:	fa843783          	ld	a5,-88(s0)
   12690:	fa043583          	ld	a1,-96(s0)
   12694:	02d00513          	li	a0,45
   12698:	000780e7          	jalr	a5
                num = -(long long) num;
   1269c:	fd843783          	ld	a5,-40(s0)
   126a0:	40f007b3          	neg	a5,a5
   126a4:	fcf43c23          	sd	a5,-40(s0)
            }
            base = 10;
   126a8:	00a00793          	li	a5,10
   126ac:	fcf42a23          	sw	a5,-44(s0)
            goto signed_number;
   126b0:	0640006f          	j	12714 <vprintfmt_lib+0x39c>

        // unsigned decimal
        case 'u':
            base = 10;
   126b4:	00a00793          	li	a5,10
   126b8:	fcf42a23          	sw	a5,-44(s0)
            goto unsigned_number;
   126bc:	0400006f          	j	126fc <vprintfmt_lib+0x384>

        // (unsigned) octal
        case 'o':
            // should do something with padding so it's always 3 octits
            base = 8;
   126c0:	00800793          	li	a5,8
   126c4:	fcf42a23          	sw	a5,-44(s0)
            goto unsigned_number;
   126c8:	0340006f          	j	126fc <vprintfmt_lib+0x384>

        // pointer
        case 'p':
            //static_assert(sizeof(long) == sizeof(void*));
            lflag = 1;
   126cc:	00100793          	li	a5,1
   126d0:	fcf42823          	sw	a5,-48(s0)
            putch('0', putdat);
   126d4:	fa843783          	ld	a5,-88(s0)
   126d8:	fa043583          	ld	a1,-96(s0)
   126dc:	03000513          	li	a0,48
   126e0:	000780e7          	jalr	a5
            putch('x', putdat);
   126e4:	fa843783          	ld	a5,-88(s0)
   126e8:	fa043583          	ld	a1,-96(s0)
   126ec:	07800513          	li	a0,120
   126f0:	000780e7          	jalr	a5
            /* fall through to 'x' */

        // (unsigned) hexadecimal
        case 'x':
            base = 16;
   126f4:	01000793          	li	a5,16
   126f8:	fcf42a23          	sw	a5,-44(s0)
unsigned_number:
            num = getuint(&ap, lflag);
   126fc:	fd042703          	lw	a4,-48(s0)
   12700:	f9040793          	addi	a5,s0,-112
   12704:	00070593          	mv	a1,a4
   12708:	00078513          	mv	a0,a5
   1270c:	b3dff0ef          	jal	ra,12248 <getuint>
   12710:	fca43c23          	sd	a0,-40(s0)
signed_number:
            printnum(putch, putdat, num, base, width, padc);
   12714:	fd442683          	lw	a3,-44(s0)
   12718:	fc744783          	lbu	a5,-57(s0)
   1271c:	0007879b          	sext.w	a5,a5
   12720:	fcc42703          	lw	a4,-52(s0)
   12724:	fd843603          	ld	a2,-40(s0)
   12728:	fa043583          	ld	a1,-96(s0)
   1272c:	fa843503          	ld	a0,-88(s0)
   12730:	00000097          	auipc	ra,0x0
   12734:	9bc080e7          	jalr	-1604(ra) # 120ec <printnum>
            break;
   12738:	0340006f          	j	1276c <vprintfmt_lib+0x3f4>

        // escaped '%' character
        case '%':
            putch(ch, putdat);
   1273c:	fa843783          	ld	a5,-88(s0)
   12740:	fa043583          	ld	a1,-96(s0)
   12744:	00048513          	mv	a0,s1
   12748:	000780e7          	jalr	a5
            break;
   1274c:	0200006f          	j	1276c <vprintfmt_lib+0x3f4>
      
        // unrecognized escape sequence - just print it literally
        default:
            putch('%', putdat);
   12750:	fa843783          	ld	a5,-88(s0)
   12754:	fa043583          	ld	a1,-96(s0)
   12758:	02500513          	li	a0,37
   1275c:	000780e7          	jalr	a5
            fmt = last_fmt;
   12760:	fb843783          	ld	a5,-72(s0)
   12764:	f8f43c23          	sd	a5,-104(s0)
            break;
   12768:	00000013          	nop
        while ((ch = *(unsigned char *) fmt) != '%') {
   1276c:	c59ff06f          	j	123c4 <vprintfmt_lib+0x4c>
                return;
   12770:	00000013          	nop
        }
    }
}
   12774:	06813083          	ld	ra,104(sp)
   12778:	06013403          	ld	s0,96(sp)
   1277c:	05813483          	ld	s1,88(sp)
   12780:	05013903          	ld	s2,80(sp)
   12784:	07010113          	addi	sp,sp,112
   12788:	00008067          	ret

000000000001278c <print_uart>:

void print_uart(const char *buf, int sz) {
   1278c:	fc010113          	addi	sp,sp,-64
   12790:	02813c23          	sd	s0,56(sp)
   12794:	04010413          	addi	s0,sp,64
   12798:	fca43423          	sd	a0,-56(s0)
   1279c:	00058793          	mv	a5,a1
   127a0:	fcf42223          	sw	a5,-60(s0)
    uart_map *uart = (uart_map *)ADDR_BUS0_XSLV_UART0;
   127a4:	100107b7          	lui	a5,0x10010
   127a8:	fef43023          	sd	a5,-32(s0)
    uart_txdata_type txdata;
    for (int i = 0; i < sz; i++) {
   127ac:	fe042623          	sw	zero,-20(s0)
   127b0:	04c0006f          	j	127fc <print_uart+0x70>
        do {
            txdata.v = uart->txdata;
   127b4:	fe043783          	ld	a5,-32(s0)
   127b8:	0007a783          	lw	a5,0(a5) # 10010000 <_end+0xfff0764>
   127bc:	0007879b          	sext.w	a5,a5
   127c0:	fcf42c23          	sw	a5,-40(s0)
        } while (txdata.b.full);
   127c4:	fdb44783          	lbu	a5,-37(s0)
   127c8:	f807f793          	andi	a5,a5,-128
   127cc:	0ff7f793          	andi	a5,a5,255
   127d0:	fe0792e3          	bnez	a5,127b4 <print_uart+0x28>
        uart->txdata = buf[i];
   127d4:	fec42783          	lw	a5,-20(s0)
   127d8:	fc843703          	ld	a4,-56(s0)
   127dc:	00f707b3          	add	a5,a4,a5
   127e0:	0007c783          	lbu	a5,0(a5)
   127e4:	0007871b          	sext.w	a4,a5
   127e8:	fe043783          	ld	a5,-32(s0)
   127ec:	00e7a023          	sw	a4,0(a5)
    for (int i = 0; i < sz; i++) {
   127f0:	fec42783          	lw	a5,-20(s0)
   127f4:	0017879b          	addiw	a5,a5,1
   127f8:	fef42623          	sw	a5,-20(s0)
   127fc:	fec42703          	lw	a4,-20(s0)
   12800:	fc442783          	lw	a5,-60(s0)
   12804:	0007071b          	sext.w	a4,a4
   12808:	0007879b          	sext.w	a5,a5
   1280c:	faf744e3          	blt	a4,a5,127b4 <print_uart+0x28>
    }
}
   12810:	00000013          	nop
   12814:	03813403          	ld	s0,56(sp)
   12818:	04010113          	addi	sp,sp,64
   1281c:	00008067          	ret

0000000000012820 <print_uart_hex>:

void print_uart_hex(uint64_t val) {
   12820:	fc010113          	addi	sp,sp,-64
   12824:	02813c23          	sd	s0,56(sp)
   12828:	04010413          	addi	s0,sp,64
   1282c:	fca43423          	sd	a0,-56(s0)
    unsigned char t, s;
    uart_map *uart = (uart_map *)ADDR_BUS0_XSLV_UART0;
   12830:	100107b7          	lui	a5,0x10010
   12834:	fef43023          	sd	a5,-32(s0)
    uart_txdata_type txdata;

    for (int i = 0; i < 16; i++) {
   12838:	fe042423          	sw	zero,-24(s0)
   1283c:	0980006f          	j	128d4 <print_uart_hex+0xb4>
        do {
            txdata.v = uart->txdata;
   12840:	fe043783          	ld	a5,-32(s0)
   12844:	0007a783          	lw	a5,0(a5) # 10010000 <_end+0xfff0764>
   12848:	0007879b          	sext.w	a5,a5
   1284c:	fcf42c23          	sw	a5,-40(s0)
        } while (txdata.b.full);
   12850:	fdb44783          	lbu	a5,-37(s0)
   12854:	f807f793          	andi	a5,a5,-128
   12858:	0ff7f793          	andi	a5,a5,255
   1285c:	fe0792e3          	bnez	a5,12840 <print_uart_hex+0x20>
        
        t = (unsigned char)((val >> ((15 - i) * 4)) & 0xf);
   12860:	00f00713          	li	a4,15
   12864:	fe842783          	lw	a5,-24(s0)
   12868:	40f707bb          	subw	a5,a4,a5
   1286c:	0007879b          	sext.w	a5,a5
   12870:	0027979b          	slliw	a5,a5,0x2
   12874:	0007879b          	sext.w	a5,a5
   12878:	fc843703          	ld	a4,-56(s0)
   1287c:	00f757b3          	srl	a5,a4,a5
   12880:	0ff7f793          	andi	a5,a5,255
   12884:	00f7f793          	andi	a5,a5,15
   12888:	fcf40fa3          	sb	a5,-33(s0)
        if (t < 10) {
   1288c:	fdf44783          	lbu	a5,-33(s0)
   12890:	0ff7f713          	andi	a4,a5,255
   12894:	00900793          	li	a5,9
   12898:	00e7ea63          	bltu	a5,a4,128ac <print_uart_hex+0x8c>
            s = t + '0';
   1289c:	fdf44783          	lbu	a5,-33(s0)
   128a0:	0307879b          	addiw	a5,a5,48
   128a4:	fef407a3          	sb	a5,-17(s0)
   128a8:	0100006f          	j	128b8 <print_uart_hex+0x98>
        } else {
            s = (t - 10) + 'a';
   128ac:	fdf44783          	lbu	a5,-33(s0)
   128b0:	0577879b          	addiw	a5,a5,87
   128b4:	fef407a3          	sb	a5,-17(s0)
        }
        uart->txdata = s;
   128b8:	fef44783          	lbu	a5,-17(s0)
   128bc:	0007871b          	sext.w	a4,a5
   128c0:	fe043783          	ld	a5,-32(s0)
   128c4:	00e7a023          	sw	a4,0(a5)
    for (int i = 0; i < 16; i++) {
   128c8:	fe842783          	lw	a5,-24(s0)
   128cc:	0017879b          	addiw	a5,a5,1
   128d0:	fef42423          	sw	a5,-24(s0)
   128d4:	fe842783          	lw	a5,-24(s0)
   128d8:	0007871b          	sext.w	a4,a5
   128dc:	00f00793          	li	a5,15
   128e0:	f6e7d0e3          	ble	a4,a5,12840 <print_uart_hex+0x20>
    }
}
   128e4:	00000013          	nop
   128e8:	03813403          	ld	s0,56(sp)
   128ec:	04010113          	addi	sp,sp,64
   128f0:	00008067          	ret

00000000000128f4 <putchar>:

#undef putchar
int putchar(int ch) {
   128f4:	fd010113          	addi	sp,sp,-48
   128f8:	02813423          	sd	s0,40(sp)
   128fc:	03010413          	addi	s0,sp,48
   12900:	00050793          	mv	a5,a0
   12904:	fcf42e23          	sw	a5,-36(s0)
#ifdef UART_BUF_ENABLE    
    uart_data_type *p = fw_get_ram_data(UART0_NAME);
    buf_put(p, ch);
#else
    uart_map *uart = (uart_map *)ADDR_BUS0_XSLV_UART0;
   12908:	100107b7          	lui	a5,0x10010
   1290c:	fef43423          	sd	a5,-24(s0)
    uart_txdata_type txdata;

    // No need to lock UART because we transmit only one symbol
    do {
        txdata.v = uart->txdata;
   12910:	fe843783          	ld	a5,-24(s0)
   12914:	0007a783          	lw	a5,0(a5) # 10010000 <_end+0xfff0764>
   12918:	0007879b          	sext.w	a5,a5
   1291c:	fef42023          	sw	a5,-32(s0)
    } while (txdata.b.full);
   12920:	fe344783          	lbu	a5,-29(s0)
   12924:	f807f793          	andi	a5,a5,-128
   12928:	0ff7f793          	andi	a5,a5,255
   1292c:	fe0792e3          	bnez	a5,12910 <putchar+0x1c>
    uart->txdata = ch;
   12930:	fdc42703          	lw	a4,-36(s0)
   12934:	fe843783          	ld	a5,-24(s0)
   12938:	00e7a023          	sw	a4,0(a5)
#endif
    return 0;
   1293c:	00000793          	li	a5,0
}
   12940:	00078513          	mv	a0,a5
   12944:	02813403          	ld	s0,40(sp)
   12948:	03010113          	addi	sp,sp,48
   1294c:	00008067          	ret

0000000000012950 <printf_uart>:

void printf_uart(const char *fmt, ... ) {
   12950:	f8010113          	addi	sp,sp,-128
   12954:	02113c23          	sd	ra,56(sp)
   12958:	02813823          	sd	s0,48(sp)
   1295c:	04010413          	addi	s0,sp,64
   12960:	fca43423          	sd	a0,-56(s0)
   12964:	00b43423          	sd	a1,8(s0)
   12968:	00c43823          	sd	a2,16(s0)
   1296c:	00d43c23          	sd	a3,24(s0)
   12970:	02e43023          	sd	a4,32(s0)
   12974:	02f43423          	sd	a5,40(s0)
   12978:	03043823          	sd	a6,48(s0)
   1297c:	03143c23          	sd	a7,56(s0)
    uart_data_type *pdata = fw_get_ram_data(UART0_NAME);
   12980:	0001f7b7          	lui	a5,0x1f
   12984:	0c078513          	addi	a0,a5,192 # 1f0c0 <UART0_NAME>
   12988:	ae0ff0ef          	jal	ra,11c68 <fw_get_ram_data>
   1298c:	fea43423          	sd	a0,-24(s0)
    uart_map *uart = (uart_map *)ADDR_BUS0_XSLV_UART0;
   12990:	100107b7          	lui	a5,0x10010
   12994:	fef43023          	sd	a5,-32(s0)
    int id = fw_get_cpuid() + 1;
   12998:	00000097          	auipc	ra,0x0
   1299c:	37c080e7          	jalr	892(ra) # 12d14 <fw_get_cpuid>
   129a0:	00050793          	mv	a5,a0
   129a4:	0017879b          	addiw	a5,a5,1
   129a8:	fcf42e23          	sw	a5,-36(s0)

    // lock UART to current CPU
    while (uart->fwcpuid != id) {
   129ac:	0240006f          	j	129d0 <printf_uart+0x80>
        if (uart->fwcpuid != 0) {
   129b0:	fe043783          	ld	a5,-32(s0)
   129b4:	01c7a783          	lw	a5,28(a5) # 1001001c <_end+0xfff0780>
   129b8:	0007879b          	sext.w	a5,a5
   129bc:	00078463          	beqz	a5,129c4 <printf_uart+0x74>
            continue;
   129c0:	0100006f          	j	129d0 <printf_uart+0x80>
        }
        uart->fwcpuid = id;
   129c4:	fdc42703          	lw	a4,-36(s0)
   129c8:	fe043783          	ld	a5,-32(s0)
   129cc:	00e7ae23          	sw	a4,28(a5)
    while (uart->fwcpuid != id) {
   129d0:	fe043783          	ld	a5,-32(s0)
   129d4:	01c7a783          	lw	a5,28(a5)
   129d8:	0007871b          	sext.w	a4,a5
   129dc:	fdc42783          	lw	a5,-36(s0)
   129e0:	fcf718e3          	bne	a4,a5,129b0 <printf_uart+0x60>
    }

    va_list arg;
    va_start(arg, fmt);
   129e4:	04040793          	addi	a5,s0,64
   129e8:	fc878793          	addi	a5,a5,-56
   129ec:	fcf43823          	sd	a5,-48(s0)
    vprintfmt_lib((f_putch)putchar, 0, fmt, arg);
   129f0:	fd043783          	ld	a5,-48(s0)
   129f4:	00078693          	mv	a3,a5
   129f8:	fc843603          	ld	a2,-56(s0)
   129fc:	00000593          	li	a1,0
   12a00:	000137b7          	lui	a5,0x13
   12a04:	8f478513          	addi	a0,a5,-1804 # 128f4 <putchar>
   12a08:	971ff0ef          	jal	ra,12378 <vprintfmt_lib>
        uart->txdata = buf_get(pdata);
        txdata.v = uart->txdata;
    }
#endif
    // free UART lock
    uart->fwcpuid = 0;
   12a0c:	fe043783          	ld	a5,-32(s0)
   12a10:	0007ae23          	sw	zero,28(a5)
}
   12a14:	00000013          	nop
   12a18:	03813083          	ld	ra,56(sp)
   12a1c:	03013403          	ld	s0,48(sp)
   12a20:	08010113          	addi	sp,sp,128
   12a24:	00008067          	ret
   12a28:	0000                	unimp
	...

0000000000012a2c <get_dev_bar>:
static uint64_t get_dev_bar(pnp_map *pnp, uint16_t vid, uint16_t did) {
   12a2c:	fb010113          	addi	sp,sp,-80
   12a30:	04813423          	sd	s0,72(sp)
   12a34:	05010413          	addi	s0,sp,80
   12a38:	faa43c23          	sd	a0,-72(s0)
   12a3c:	00058793          	mv	a5,a1
   12a40:	00060713          	mv	a4,a2
   12a44:	faf41b23          	sh	a5,-74(s0)
   12a48:	00070793          	mv	a5,a4
   12a4c:	faf41a23          	sh	a5,-76(s0)
    int slots_total = (pnp->cfg >> 8) & 0xFF;
   12a50:	fb843783          	ld	a5,-72(s0)
   12a54:	0087a783          	lw	a5,8(a5)
   12a58:	0087d79b          	srliw	a5,a5,0x8
   12a5c:	0007879b          	sext.w	a5,a5
   12a60:	0007879b          	sext.w	a5,a5
   12a64:	0ff7f793          	andi	a5,a5,255
   12a68:	fef42223          	sw	a5,-28(s0)
    int off = 0;
   12a6c:	fe042623          	sw	zero,-20(s0)
    for (int i = 0; i < slots_total; i++) {
   12a70:	fe042423          	sw	zero,-24(s0)
   12a74:	09c0006f          	j	12b10 <get_dev_bar+0xe4>
        dcfg = *(dev_cfg_type *)&pnp->cfg_table[off];
   12a78:	fec42783          	lw	a5,-20(s0)
   12a7c:	04078793          	addi	a5,a5,64
   12a80:	fb843703          	ld	a4,-72(s0)
   12a84:	00f707b3          	add	a5,a4,a5
   12a88:	0007b703          	ld	a4,0(a5)
   12a8c:	fce43023          	sd	a4,-64(s0)
   12a90:	0087b703          	ld	a4,8(a5)
   12a94:	fce43423          	sd	a4,-56(s0)
   12a98:	0107b703          	ld	a4,16(a5)
   12a9c:	fce43823          	sd	a4,-48(s0)
   12aa0:	0187b783          	ld	a5,24(a5)
   12aa4:	fcf43c23          	sd	a5,-40(s0)
        off += sizeof(dcfg);
   12aa8:	fec42783          	lw	a5,-20(s0)
   12aac:	0207879b          	addiw	a5,a5,32
   12ab0:	0007879b          	sext.w	a5,a5
   12ab4:	fef42623          	sw	a5,-20(s0)
        if (dcfg.u.descrtype != PNP_CFG_TYPE_SLAVE) {
   12ab8:	fc144783          	lbu	a5,-63(s0)
   12abc:	0037f793          	andi	a5,a5,3
   12ac0:	0ff7f793          	andi	a5,a5,255
   12ac4:	00078713          	mv	a4,a5
   12ac8:	00200793          	li	a5,2
   12acc:	02f71a63          	bne	a4,a5,12b00 <get_dev_bar+0xd4>
        if (dcfg.u.vid == vid && dcfg.u.did == did) {
   12ad0:	fc645783          	lhu	a5,-58(s0)
   12ad4:	fb645703          	lhu	a4,-74(s0)
   12ad8:	0007071b          	sext.w	a4,a4
   12adc:	0007879b          	sext.w	a5,a5
   12ae0:	02f71263          	bne	a4,a5,12b04 <get_dev_bar+0xd8>
   12ae4:	fc445783          	lhu	a5,-60(s0)
   12ae8:	fb445703          	lhu	a4,-76(s0)
   12aec:	0007071b          	sext.w	a4,a4
   12af0:	0007879b          	sext.w	a5,a5
   12af4:	00f71863          	bne	a4,a5,12b04 <get_dev_bar+0xd8>
            return dcfg.u.addr_start;
   12af8:	fd043783          	ld	a5,-48(s0)
   12afc:	02c0006f          	j	12b28 <get_dev_bar+0xfc>
            continue;
   12b00:	00000013          	nop
    for (int i = 0; i < slots_total; i++) {
   12b04:	fe842783          	lw	a5,-24(s0)
   12b08:	0017879b          	addiw	a5,a5,1
   12b0c:	fef42423          	sw	a5,-24(s0)
   12b10:	fe842703          	lw	a4,-24(s0)
   12b14:	fe442783          	lw	a5,-28(s0)
   12b18:	0007071b          	sext.w	a4,a4
   12b1c:	0007879b          	sext.w	a5,a5
   12b20:	f4f74ce3          	blt	a4,a5,12a78 <get_dev_bar+0x4c>
    return DEV_NONE;
   12b24:	fff00793          	li	a5,-1
}
   12b28:	00078513          	mv	a0,a5
   12b2c:	04813403          	ld	s0,72(sp)
   12b30:	05010113          	addi	sp,sp,80
   12b34:	00008067          	ret

0000000000012b38 <mpu_region_total>:
static int mpu_region_total() {
   12b38:	fe010113          	addi	sp,sp,-32
   12b3c:	00813c23          	sd	s0,24(sp)
   12b40:	02010413          	addi	s0,sp,32
    uint64_t val = 0;
   12b44:	fe043423          	sd	zero,-24(s0)
    asm("csrr %0, 0xBC4" : "=r" (val));
   12b48:	bc4027f3          	csrr	a5,0xbc4
   12b4c:	fef43423          	sd	a5,-24(s0)
    return (int)(val >> 8);
   12b50:	fe843783          	ld	a5,-24(s0)
   12b54:	0087d793          	srli	a5,a5,0x8
   12b58:	0007879b          	sext.w	a5,a5
}
   12b5c:	00078513          	mv	a0,a5
   12b60:	01813403          	ld	s0,24(sp)
   12b64:	02010113          	addi	sp,sp,32
   12b68:	00008067          	ret

0000000000012b6c <mpu_disable_region>:
static void mpu_disable_region(int idx) {
   12b6c:	fd010113          	addi	sp,sp,-48
   12b70:	02813423          	sd	s0,40(sp)
   12b74:	03010413          	addi	s0,sp,48
   12b78:	00050793          	mv	a5,a0
   12b7c:	fcf42e23          	sw	a5,-36(s0)
    ctrl.value = 0;
   12b80:	fe043423          	sd	zero,-24(s0)
    ctrl.bits.IDX = idx;
   12b84:	fdc42783          	lw	a5,-36(s0)
   12b88:	0ff7f793          	andi	a5,a5,255
   12b8c:	fef404a3          	sb	a5,-23(s0)
    ctrl.bits.WE = 1;
   12b90:	fe844783          	lbu	a5,-24(s0)
   12b94:	f807e793          	ori	a5,a5,-128
   12b98:	fef40423          	sb	a5,-24(s0)
    asm("csrw 0xBC4, %0" : :"r"(ctrl.value));
   12b9c:	fe843783          	ld	a5,-24(s0)
   12ba0:	bc479073          	csrw	0xbc4,a5
}
   12ba4:	00000013          	nop
   12ba8:	02813403          	ld	s0,40(sp)
   12bac:	03010113          	addi	sp,sp,48
   12bb0:	00008067          	ret

0000000000012bb4 <mpu_enable_region>:
                       const char *rwx) {
   12bb4:	fb010113          	addi	sp,sp,-80
   12bb8:	04813423          	sd	s0,72(sp)
   12bbc:	05010413          	addi	s0,sp,80
   12bc0:	00050793          	mv	a5,a0
   12bc4:	fcb43023          	sd	a1,-64(s0)
   12bc8:	fac43c23          	sd	a2,-72(s0)
   12bcc:	fae43823          	sd	a4,-80(s0)
   12bd0:	fcf42623          	sw	a5,-52(s0)
   12bd4:	00068793          	mv	a5,a3
   12bd8:	fcf42423          	sw	a5,-56(s0)
    uint64_t mask = (~0ull) << 10;
   12bdc:	c0000793          	li	a5,-1024
   12be0:	fef43423          	sd	a5,-24(s0)
    const char *p = rwx;
   12be4:	fb043783          	ld	a5,-80(s0)
   12be8:	fef43023          	sd	a5,-32(s0)
    asm("csrw 0xBC2, %0" : :"r"(bar));
   12bec:	fc043783          	ld	a5,-64(s0)
   12bf0:	bc279073          	csrw	0xbc2,a5
    KB >>= 1;
   12bf4:	fb843783          	ld	a5,-72(s0)
   12bf8:	0017d793          	srli	a5,a5,0x1
   12bfc:	faf43c23          	sd	a5,-72(s0)
    while (KB) {
   12c00:	01c0006f          	j	12c1c <mpu_enable_region+0x68>
        mask <<= 1;
   12c04:	fe843783          	ld	a5,-24(s0)
   12c08:	00179793          	slli	a5,a5,0x1
   12c0c:	fef43423          	sd	a5,-24(s0)
        KB >>= 1;
   12c10:	fb843783          	ld	a5,-72(s0)
   12c14:	0017d793          	srli	a5,a5,0x1
   12c18:	faf43c23          	sd	a5,-72(s0)
    while (KB) {
   12c1c:	fb843783          	ld	a5,-72(s0)
   12c20:	fe0792e3          	bnez	a5,12c04 <mpu_enable_region+0x50>
    asm("csrw 0xBC3, %0" : :"r"(mask));
   12c24:	fe843783          	ld	a5,-24(s0)
   12c28:	bc379073          	csrw	0xbc3,a5
    ctrl.value = 0;
   12c2c:	fc043c23          	sd	zero,-40(s0)
    ctrl.bits.IDX = idx;
   12c30:	fcc42783          	lw	a5,-52(s0)
   12c34:	0ff7f793          	andi	a5,a5,255
   12c38:	fcf40ca3          	sb	a5,-39(s0)
    ctrl.bits.ENA = 1;
   12c3c:	fd844783          	lbu	a5,-40(s0)
   12c40:	0107e793          	ori	a5,a5,16
   12c44:	fcf40c23          	sb	a5,-40(s0)
    ctrl.bits.CACHABLE = cached;
   12c48:	fc842783          	lw	a5,-56(s0)
   12c4c:	0017f793          	andi	a5,a5,1
   12c50:	0ff7f793          	andi	a5,a5,255
   12c54:	0017f793          	andi	a5,a5,1
   12c58:	0037969b          	slliw	a3,a5,0x3
   12c5c:	fd844783          	lbu	a5,-40(s0)
   12c60:	ff77f793          	andi	a5,a5,-9
   12c64:	00078713          	mv	a4,a5
   12c68:	00068793          	mv	a5,a3
   12c6c:	00f767b3          	or	a5,a4,a5
   12c70:	fcf40c23          	sb	a5,-40(s0)
    ctrl.bits.WE = 1; // write into MPU
   12c74:	fd844783          	lbu	a5,-40(s0)
   12c78:	f807e793          	ori	a5,a5,-128
   12c7c:	fcf40c23          	sb	a5,-40(s0)
    while (*p) {
   12c80:	0700006f          	j	12cf0 <mpu_enable_region+0x13c>
        if (*p == 'r') {
   12c84:	fe043783          	ld	a5,-32(s0)
   12c88:	0007c783          	lbu	a5,0(a5)
   12c8c:	00078713          	mv	a4,a5
   12c90:	07200793          	li	a5,114
   12c94:	00f71863          	bne	a4,a5,12ca4 <mpu_enable_region+0xf0>
            ctrl.bits.RD = 1;
   12c98:	fd844783          	lbu	a5,-40(s0)
   12c9c:	0027e793          	ori	a5,a5,2
   12ca0:	fcf40c23          	sb	a5,-40(s0)
        if (*p == 'w') {
   12ca4:	fe043783          	ld	a5,-32(s0)
   12ca8:	0007c783          	lbu	a5,0(a5)
   12cac:	00078713          	mv	a4,a5
   12cb0:	07700793          	li	a5,119
   12cb4:	00f71863          	bne	a4,a5,12cc4 <mpu_enable_region+0x110>
            ctrl.bits.WR = 1;
   12cb8:	fd844783          	lbu	a5,-40(s0)
   12cbc:	0017e793          	ori	a5,a5,1
   12cc0:	fcf40c23          	sb	a5,-40(s0)
        if (*p == 'x') {
   12cc4:	fe043783          	ld	a5,-32(s0)
   12cc8:	0007c783          	lbu	a5,0(a5)
   12ccc:	00078713          	mv	a4,a5
   12cd0:	07800793          	li	a5,120
   12cd4:	00f71863          	bne	a4,a5,12ce4 <mpu_enable_region+0x130>
            ctrl.bits.EXEC = 1;
   12cd8:	fd844783          	lbu	a5,-40(s0)
   12cdc:	0047e793          	ori	a5,a5,4
   12ce0:	fcf40c23          	sb	a5,-40(s0)
        p++;
   12ce4:	fe043783          	ld	a5,-32(s0)
   12ce8:	00178793          	addi	a5,a5,1
   12cec:	fef43023          	sd	a5,-32(s0)
    while (*p) {
   12cf0:	fe043783          	ld	a5,-32(s0)
   12cf4:	0007c783          	lbu	a5,0(a5)
   12cf8:	f80796e3          	bnez	a5,12c84 <mpu_enable_region+0xd0>
    asm("csrw 0xBC4, %0" : :"r"(ctrl.value));
   12cfc:	fd843783          	ld	a5,-40(s0)
   12d00:	bc479073          	csrw	0xbc4,a5
}
   12d04:	00000013          	nop
   12d08:	04813403          	ld	s0,72(sp)
   12d0c:	05010113          	addi	sp,sp,80
   12d10:	00008067          	ret

0000000000012d14 <fw_get_cpuid>:
#include <string.h>
#include "axi_maps.h"
#include "encoding.h"
#include "fw_api.h"

int fw_get_cpuid() {
   12d14:	fe010113          	addi	sp,sp,-32
   12d18:	00813c23          	sd	s0,24(sp)
   12d1c:	02010413          	addi	s0,sp,32
    int ret;
    asm("csrr %0, mhartid" : "=r" (ret));
   12d20:	f14027f3          	csrr	a5,mhartid
   12d24:	fef42623          	sw	a5,-20(s0)
    return ret;
   12d28:	fec42783          	lw	a5,-20(s0)
}
   12d2c:	00078513          	mv	a0,a5
   12d30:	01813403          	ld	s0,24(sp)
   12d34:	02010113          	addi	sp,sp,32
   12d38:	00008067          	ret

0000000000012d3c <flush_tlb>:

void flush_tlb()
{
   12d3c:	ff010113          	addi	sp,sp,-16
   12d40:	00813423          	sd	s0,8(sp)
   12d44:	01010413          	addi	s0,sp,16
    asm volatile ("sfence.vma");
   12d48:	12000073          	sfence.vma
}
   12d4c:	00000013          	nop
   12d50:	00813403          	ld	s0,8(sp)
   12d54:	01010113          	addi	sp,sp,16
   12d58:	00008067          	ret

0000000000012d5c <fw_enable_m_interrupts>:

// external interrupts
void fw_enable_m_interrupts() {
   12d5c:	fe010113          	addi	sp,sp,-32
   12d60:	00813c23          	sd	s0,24(sp)
   12d64:	02010413          	addi	s0,sp,32
    uint64_t t1 = 0x00000008;
   12d68:	00800793          	li	a5,8
   12d6c:	fef43423          	sd	a5,-24(s0)
    asm("csrs mstatus, %0" : :"r"(t1));  // set mie
   12d70:	fe843783          	ld	a5,-24(s0)
   12d74:	3007a073          	csrs	mstatus,a5
}
   12d78:	00000013          	nop
   12d7c:	01813403          	ld	s0,24(sp)
   12d80:	02010113          	addi	sp,sp,32
   12d84:	00008067          	ret

0000000000012d88 <fw_disable_m_interrupts>:

void fw_disable_m_interrupts() {
   12d88:	fe010113          	addi	sp,sp,-32
   12d8c:	00813c23          	sd	s0,24(sp)
   12d90:	02010413          	addi	s0,sp,32
    uint64_t t1 = 0x00000008;
   12d94:	00800793          	li	a5,8
   12d98:	fef43423          	sd	a5,-24(s0)
    asm("csrc mstatus, %0" : :"r"(t1));  // clear mie
   12d9c:	fe843783          	ld	a5,-24(s0)
   12da0:	3007b073          	csrc	mstatus,a5
}
   12da4:	00000013          	nop
   12da8:	01813403          	ld	s0,24(sp)
   12dac:	02010113          	addi	sp,sp,32
   12db0:	00008067          	ret

0000000000012db4 <fw_mie_enable>:

void fw_mie_enable(int idx) {
   12db4:	fd010113          	addi	sp,sp,-48
   12db8:	02813423          	sd	s0,40(sp)
   12dbc:	03010413          	addi	s0,sp,48
   12dc0:	00050793          	mv	a5,a0
   12dc4:	fcf42e23          	sw	a5,-36(s0)
    int xie = 1ull << idx;
   12dc8:	fdc46783          	lwu	a5,-36(s0)
   12dcc:	00100713          	li	a4,1
   12dd0:	00f717b3          	sll	a5,a4,a5
   12dd4:	fef42623          	sw	a5,-20(s0)
    asm("csrs mie, %0" : :"r"(xie));
   12dd8:	fec42783          	lw	a5,-20(s0)
   12ddc:	3047a073          	csrs	mie,a5
}
   12de0:	00000013          	nop
   12de4:	02813403          	ld	s0,40(sp)
   12de8:	03010113          	addi	sp,sp,48
   12dec:	00008067          	ret

0000000000012df0 <fw_mie_disable>:

void fw_mie_disable(int idx) {
   12df0:	fd010113          	addi	sp,sp,-48
   12df4:	02813423          	sd	s0,40(sp)
   12df8:	03010413          	addi	s0,sp,48
   12dfc:	00050793          	mv	a5,a0
   12e00:	fcf42e23          	sw	a5,-36(s0)
    int xie = 1ull << idx;
   12e04:	fdc46783          	lwu	a5,-36(s0)
   12e08:	00100713          	li	a4,1
   12e0c:	00f717b3          	sll	a5,a4,a5
   12e10:	fef42623          	sw	a5,-20(s0)
    asm("csrc mie, %0" : :"r"(xie));
   12e14:	fec42783          	lw	a5,-20(s0)
   12e18:	3047b073          	csrc	mie,a5
}
   12e1c:	00000013          	nop
   12e20:	02813403          	ld	s0,40(sp)
   12e24:	03010113          	addi	sp,sp,48
   12e28:	00008067          	ret

0000000000012e2c <fw_enable_plic_irq>:

void fw_enable_plic_irq(int ctxid, int irqidx) {
   12e2c:	fd010113          	addi	sp,sp,-48
   12e30:	02813423          	sd	s0,40(sp)
   12e34:	03010413          	addi	s0,sp,48
   12e38:	00050793          	mv	a5,a0
   12e3c:	00058713          	mv	a4,a1
   12e40:	fcf42e23          	sw	a5,-36(s0)
   12e44:	00070793          	mv	a5,a4
   12e48:	fcf42c23          	sw	a5,-40(s0)
    plic_map *p = (plic_map *)ADDR_BUS0_XSLV_PLIC;
   12e4c:	0c0007b7          	lui	a5,0xc000
   12e50:	fef43423          	sd	a5,-24(s0)
    p->src_prioirty[irqidx] = 0x1;    // 1=lowest prioirty; 0 = disabled
   12e54:	fe843703          	ld	a4,-24(s0)
   12e58:	fd842783          	lw	a5,-40(s0)
   12e5c:	00279793          	slli	a5,a5,0x2
   12e60:	00f707b3          	add	a5,a4,a5
   12e64:	00100713          	li	a4,1
   12e68:	00e7a023          	sw	a4,0(a5) # c000000 <_end+0xbfe0764>
#ifdef PLIC_MODE_ENABLED
    p->src_mode[irqidx] = PLIC_MODE_RISING_EDGE;
   12e6c:	00300713          	li	a4,3
   12e70:	fe843683          	ld	a3,-24(s0)
   12e74:	fd842603          	lw	a2,-40(s0)
   12e78:	0007c7b7          	lui	a5,0x7c
   12e7c:	00f607b3          	add	a5,a2,a5
   12e80:	00279793          	slli	a5,a5,0x2
   12e84:	00f687b3          	add	a5,a3,a5
   12e88:	00e7a023          	sw	a4,0(a5) # 7c000 <_end+0x5c764>
#endif
    p->ctx_prio[ctxid].priority = 0;
   12e8c:	fe843703          	ld	a4,-24(s0)
   12e90:	fdc42783          	lw	a5,-36(s0)
   12e94:	20078793          	addi	a5,a5,512
   12e98:	00c79793          	slli	a5,a5,0xc
   12e9c:	00f707b3          	add	a5,a4,a5
   12ea0:	0007a023          	sw	zero,0(a5)
    p->ctx_ie[ctxid].irq_enable[irqidx/32] = 1ul << (irqidx & 0x1F);
   12ea4:	fd842783          	lw	a5,-40(s0)
   12ea8:	01f7f793          	andi	a5,a5,31
   12eac:	0007879b          	sext.w	a5,a5
   12eb0:	00100713          	li	a4,1
   12eb4:	00f716b3          	sll	a3,a4,a5
   12eb8:	fd842783          	lw	a5,-40(s0)
   12ebc:	41f7d71b          	sraiw	a4,a5,0x1f
   12ec0:	01b7571b          	srliw	a4,a4,0x1b
   12ec4:	00f707bb          	addw	a5,a4,a5
   12ec8:	4057d79b          	sraiw	a5,a5,0x5
   12ecc:	0007879b          	sext.w	a5,a5
   12ed0:	0006871b          	sext.w	a4,a3
   12ed4:	fe843683          	ld	a3,-24(s0)
   12ed8:	fdc42603          	lw	a2,-36(s0)
   12edc:	00561613          	slli	a2,a2,0x5
   12ee0:	00f60633          	add	a2,a2,a5
   12ee4:	000017b7          	lui	a5,0x1
   12ee8:	80078793          	addi	a5,a5,-2048 # 800 <_ftext-0xf800>
   12eec:	00f607b3          	add	a5,a2,a5
   12ef0:	00279793          	slli	a5,a5,0x2
   12ef4:	00f687b3          	add	a5,a3,a5
   12ef8:	00e7a023          	sw	a4,0(a5)
}
   12efc:	00000013          	nop
   12f00:	02813403          	ld	s0,40(sp)
   12f04:	03010113          	addi	sp,sp,48
   12f08:	00008067          	ret

0000000000012f0c <fw_disable_plic_irq>:

void fw_disable_plic_irq(int ctxid, int irqidx) {
   12f0c:	fd010113          	addi	sp,sp,-48
   12f10:	02813423          	sd	s0,40(sp)
   12f14:	03010413          	addi	s0,sp,48
   12f18:	00050793          	mv	a5,a0
   12f1c:	00058713          	mv	a4,a1
   12f20:	fcf42e23          	sw	a5,-36(s0)
   12f24:	00070793          	mv	a5,a4
   12f28:	fcf42c23          	sw	a5,-40(s0)
    plic_map *p = (plic_map *)ADDR_BUS0_XSLV_PLIC;
   12f2c:	0c0007b7          	lui	a5,0xc000
   12f30:	fef43423          	sd	a5,-24(s0)
    p->src_prioirty[irqidx] = 0;    // 1=lowest prioirty; 0 = disabled
   12f34:	fe843703          	ld	a4,-24(s0)
   12f38:	fd842783          	lw	a5,-40(s0)
   12f3c:	00279793          	slli	a5,a5,0x2
   12f40:	00f707b3          	add	a5,a4,a5
   12f44:	0007a023          	sw	zero,0(a5) # c000000 <_end+0xbfe0764>
}
   12f48:	00000013          	nop
   12f4c:	02813403          	ld	s0,40(sp)
   12f50:	03010113          	addi	sp,sp,48
   12f54:	00008067          	ret

0000000000012f58 <led_set>:

void led_set(int output) {
   12f58:	fe010113          	addi	sp,sp,-32
   12f5c:	00813c23          	sd	s0,24(sp)
   12f60:	02010413          	addi	s0,sp,32
   12f64:	00050793          	mv	a5,a0
   12f68:	fef42623          	sw	a5,-20(s0)
    // [3:0] DIP pins
    ((gpio_map *)ADDR_BUS0_XSLV_GPIO)->output_val = (output << 4);
   12f6c:	fec42783          	lw	a5,-20(s0)
   12f70:	0047979b          	slliw	a5,a5,0x4
   12f74:	0007871b          	sext.w	a4,a5
   12f78:	100607b7          	lui	a5,0x10060
   12f7c:	0007071b          	sext.w	a4,a4
   12f80:	00e7a623          	sw	a4,12(a5) # 1006000c <_end+0x10040770>
}
   12f84:	00000013          	nop
   12f88:	01813403          	ld	s0,24(sp)
   12f8c:	02010113          	addi	sp,sp,32
   12f90:	00008067          	ret
	...

0000000000013000 <_mbist_ram>:
.align 8
.globl _mbist_ram

_mbist_ram:
  // Read 'tech' value from PNP module
  lui	a5,0x100
   13000:	001007b7          	lui	a5,0x100
  addi	a5,a5,-1    # fffff
   13004:	fff78793          	addi	a5,a5,-1 # fffff <_end+0xe0763>
  slli	a5,a5,0xc   # a5 = PNP base address
   13008:	00c79793          	slli	a5,a5,0xc
  lw	a4,8(a5)
   1300c:	0087a703          	lw	a4,8(a5)
  andi	a4,a4,255             # a4 = tech & 0xFF
   13010:	0ff77713          	andi	a4,a4,255
  beqz	a4,scaler_inferred    # a4 == inferred
   13014:	00070663          	beqz	a4,13020 <scaler_inferred>
  li	a4,(SYS_HZ/115200/2)
   13018:	0ad00713          	li	a4,173
  j	uart_scaler_end
   1301c:	0080006f          	j	13024 <uart_scaler_end>

0000000000013020 <scaler_inferred>:
scaler_inferred:
  li	a4,3             # fast rtl simulation
   13020:	00300713          	li	a4,3

0000000000013024 <uart_scaler_end>:
uart_scaler_end:

   //      uart_map *uart = (uart_map *)ADDR_NASTI_SLAVE_UART1;
  lui	a5,0x80
   13024:	000807b7          	lui	a5,0x80
  addi	a5,a5,1 # 80001
   13028:	00178793          	addi	a5,a5,1 # 80001 <_end+0x60765>
  slli	a5,a5,0xc
   1302c:	00c79793          	slli	a5,a5,0xc
  sw	a4,4(a5)    # scaler = a4
   13030:	00e7a223          	sw	a4,4(a5)

0000000000013034 <mbist_waitempty1>:
  // Wait while Tx FIFO becomes empty
mbist_waitempty1:
  lw	a4,0(a5)
   13034:	0007a703          	lw	a4,0(a5)
  li	a3,2
   13038:	00200693          	li	a3,2
  and	a4,a4,a3
   1303c:	00d77733          	and	a4,a4,a3
  beqz	a4,mbist_waitempty1
   13040:	fe070ae3          	beqz	a4,13034 <mbist_waitempty1>

  //  output "SRAM . . . . . .PASS/FAIL\r\n";
  li	a4,83    # 'S'
   13044:	05300713          	li	a4,83
  sw	a4,16(a5)
   13048:	00e7a823          	sw	a4,16(a5)
  li	a4,82    # 'R'
   1304c:	05200713          	li	a4,82
  sw	a4,16(a5)
   13050:	00e7a823          	sw	a4,16(a5)
  li	a4,65    # 'A'
   13054:	04100713          	li	a4,65
  sw	a4,16(a5)
   13058:	00e7a823          	sw	a4,16(a5)
  li	a4,77    # 'M'
   1305c:	04d00713          	li	a4,77
  sw	a4,16(a5)
   13060:	00e7a823          	sw	a4,16(a5)
  li	a4,32    # ' '
   13064:	02000713          	li	a4,32
  sw	a4,16(a5)
   13068:	00e7a823          	sw	a4,16(a5)
  li	a4,46    # '.'
   1306c:	02e00713          	li	a4,46
  sw	a4,16(a5)
   13070:	00e7a823          	sw	a4,16(a5)
  li	a4,32    # ' '
   13074:	02000713          	li	a4,32
  sw	a4,16(a5)
   13078:	00e7a823          	sw	a4,16(a5)
  li	a4,46    # '.'
   1307c:	02e00713          	li	a4,46
  sw	a4,16(a5)
   13080:	00e7a823          	sw	a4,16(a5)
  li	a4,32    # ' '
   13084:	02000713          	li	a4,32
  sw	a4,16(a5)
   13088:	00e7a823          	sw	a4,16(a5)
  li	a4,46    # '.'
   1308c:	02e00713          	li	a4,46
  sw	a4,16(a5)
   13090:	00e7a823          	sw	a4,16(a5)
  li	a4,32    # ' '
   13094:	02000713          	li	a4,32
  sw	a4,16(a5)
   13098:	00e7a823          	sw	a4,16(a5)
  li	a4,46    # '.'
   1309c:	02e00713          	li	a4,46
  sw	a4,16(a5)
   130a0:	00e7a823          	sw	a4,16(a5)
  li	a4,32    # ' '
   130a4:	02000713          	li	a4,32
  sw	a4,16(a5)
   130a8:	00e7a823          	sw	a4,16(a5)
  li	a4,46    # '.'
   130ac:	02e00713          	li	a4,46
  sw	a4,16(a5)
   130b0:	00e7a823          	sw	a4,16(a5)
  li	a4,32    # ' '
   130b4:	02000713          	li	a4,32
  sw	a4,16(a5)
   130b8:	00e7a823          	sw	a4,16(a5)
  li	a4,46    # '.'
   130bc:	02e00713          	li	a4,46
  sw	a4,16(a5)
   130c0:	00e7a823          	sw	a4,16(a5)

  // Check SRAM full range:
  //    write -1, read, compare
  //    write  0, read, compare

  li    a2,0        # error counter
   130c4:	00000613          	li	a2,0
  lui	a3,0x10000  # a3 = SRAM base
   130c8:	100006b7          	lui	a3,0x10000
  li    a4,0        # i = 0
   130cc:	00000713          	li	a4,0
  j	mbist_check1
   130d0:	0380006f          	j	13108 <mbist_check1>

00000000000130d4 <mbist_cycle_start>:
mbist_cycle_start:
  slli	t0,a4,0x3   # t0 = 8*i
   130d4:	00371293          	slli	t0,a4,0x3
  add	a0,a3,t0    # a0 = &SRAM[i]
   130d8:	00568533          	add	a0,a3,t0

  // Check  write/read ~0ull
  li	t1,-1
   130dc:	fff00313          	li	t1,-1
  sd	t1,0(a0)    # SRAM[i] = -1
   130e0:	00653023          	sd	t1,0(a0)
  ld    t2,0(a0)    
   130e4:	00053383          	ld	t2,0(a0)
  beq	t1,t2,mbist_noerr1
   130e8:	00730463          	beq	t1,t2,130f0 <mbist_noerr1>
  // increment error counter
  addiw	a2,a2,1
   130ec:	0016061b          	addiw	a2,a2,1

00000000000130f0 <mbist_noerr1>:
mbist_noerr1:

  // Check  write/read 0ull
  li	t1,0
   130f0:	00000313          	li	t1,0
  sd	t1,0(a0)    # SRAM[i] = -1
   130f4:	00653023          	sd	t1,0(a0)
  ld    t2,0(a0)    
   130f8:	00053383          	ld	t2,0(a0)
  beq	t1,t2,mbist_noerr2
   130fc:	00730463          	beq	t1,t2,13104 <mbist_noerr2>
  // increment error counter
  addiw	a2,a2,1
   13100:	0016061b          	addiw	a2,a2,1

0000000000013104 <mbist_noerr2>:
mbist_noerr2:

  addiw	a4,a4,1     # i++
   13104:	0017071b          	addiw	a4,a4,1

0000000000013108 <mbist_check1>:
mbist_check1:
  lui	a0,0x1      # 4096 qwords (uint64_t) total
   13108:	00001537          	lui	a0,0x1
  blt	a4,a0,mbist_cycle_start
   1310c:	fca744e3          	blt	a4,a0,130d4 <mbist_cycle_start>

0000000000013110 <mbist_waitempty2>:

  // Wait while Tx FIFO becomes empty
mbist_waitempty2:
  lw	a4,0(a5)
   13110:	0007a703          	lw	a4,0(a5)
  li	a3,2
   13114:	00200693          	li	a3,2
  and	a4,a4,a3
   13118:	00d77733          	and	a4,a4,a3
  beqz	a4,mbist_waitempty2
   1311c:	fe070ae3          	beqz	a4,13110 <mbist_waitempty2>

  // Check error counter: a2
  beqz	a2,mbist_ok
   13120:	02060463          	beqz	a2,13148 <mbist_ok>
  li	a4,70    # 'F'
   13124:	04600713          	li	a4,70
  sw	a4,16(a5)
   13128:	00e7a823          	sw	a4,16(a5)
  li	a4,65    # 'A'
   1312c:	04100713          	li	a4,65
  sw	a4,16(a5)
   13130:	00e7a823          	sw	a4,16(a5)
  li	a4,73    # 'I'
   13134:	04900713          	li	a4,73
  sw	a4,16(a5)
   13138:	00e7a823          	sw	a4,16(a5)
  li	a4,76    # 'L'
   1313c:	04c00713          	li	a4,76
  sw	a4,16(a5)
   13140:	00e7a823          	sw	a4,16(a5)
  j	mbist_sram_end
   13144:	0240006f          	j	13168 <mbist_sram_end>

0000000000013148 <mbist_ok>:
mbist_ok:
  li	a4,80    # 'P'
   13148:	05000713          	li	a4,80
  sw	a4,16(a5)
   1314c:	00e7a823          	sw	a4,16(a5)
  li	a4,65    # 'A'
   13150:	04100713          	li	a4,65
  sw	a4,16(a5)
   13154:	00e7a823          	sw	a4,16(a5)
  li	a4,83    # 'S'
   13158:	05300713          	li	a4,83
  sw	a4,16(a5)
   1315c:	00e7a823          	sw	a4,16(a5)
  li	a4,83    # 'S'
   13160:	05300713          	li	a4,83
  sw	a4,16(a5)
   13164:	00e7a823          	sw	a4,16(a5)

0000000000013168 <mbist_sram_end>:
mbist_sram_end:

  li	a4,13    # '\r'
   13168:	00d00713          	li	a4,13
  sw	a4,16(a5)
   1316c:	00e7a823          	sw	a4,16(a5)
  li	a4,10    # '\n'
   13170:	00a00713          	li	a4,10
  sw	a4,16(a5)
   13174:	00e7a823          	sw	a4,16(a5)

  jal   _mbist_ram_exit
   13178:	808fd0ef          	jal	ra,10180 <_mbist_ram_exit>
	...

0000000000013204 <get_dev_bar>:
static uint64_t get_dev_bar(pnp_map *pnp, uint16_t vid, uint16_t did) {
   13204:	fb010113          	addi	sp,sp,-80
   13208:	04813423          	sd	s0,72(sp)
   1320c:	05010413          	addi	s0,sp,80
   13210:	faa43c23          	sd	a0,-72(s0)
   13214:	00058793          	mv	a5,a1
   13218:	00060713          	mv	a4,a2
   1321c:	faf41b23          	sh	a5,-74(s0)
   13220:	00070793          	mv	a5,a4
   13224:	faf41a23          	sh	a5,-76(s0)
    int slots_total = (pnp->cfg >> 8) & 0xFF;
   13228:	fb843783          	ld	a5,-72(s0)
   1322c:	0087a783          	lw	a5,8(a5)
   13230:	0087d79b          	srliw	a5,a5,0x8
   13234:	0007879b          	sext.w	a5,a5
   13238:	0007879b          	sext.w	a5,a5
   1323c:	0ff7f793          	andi	a5,a5,255
   13240:	fef42223          	sw	a5,-28(s0)
    int off = 0;
   13244:	fe042623          	sw	zero,-20(s0)
    for (int i = 0; i < slots_total; i++) {
   13248:	fe042423          	sw	zero,-24(s0)
   1324c:	09c0006f          	j	132e8 <get_dev_bar+0xe4>
        dcfg = *(dev_cfg_type *)&pnp->cfg_table[off];
   13250:	fec42783          	lw	a5,-20(s0)
   13254:	04078793          	addi	a5,a5,64
   13258:	fb843703          	ld	a4,-72(s0)
   1325c:	00f707b3          	add	a5,a4,a5
   13260:	0007b703          	ld	a4,0(a5)
   13264:	fce43023          	sd	a4,-64(s0)
   13268:	0087b703          	ld	a4,8(a5)
   1326c:	fce43423          	sd	a4,-56(s0)
   13270:	0107b703          	ld	a4,16(a5)
   13274:	fce43823          	sd	a4,-48(s0)
   13278:	0187b783          	ld	a5,24(a5)
   1327c:	fcf43c23          	sd	a5,-40(s0)
        off += sizeof(dcfg);
   13280:	fec42783          	lw	a5,-20(s0)
   13284:	0207879b          	addiw	a5,a5,32
   13288:	0007879b          	sext.w	a5,a5
   1328c:	fef42623          	sw	a5,-20(s0)
        if (dcfg.u.descrtype != PNP_CFG_TYPE_SLAVE) {
   13290:	fc144783          	lbu	a5,-63(s0)
   13294:	0037f793          	andi	a5,a5,3
   13298:	0ff7f793          	andi	a5,a5,255
   1329c:	00078713          	mv	a4,a5
   132a0:	00200793          	li	a5,2
   132a4:	02f71a63          	bne	a4,a5,132d8 <get_dev_bar+0xd4>
        if (dcfg.u.vid == vid && dcfg.u.did == did) {
   132a8:	fc645783          	lhu	a5,-58(s0)
   132ac:	fb645703          	lhu	a4,-74(s0)
   132b0:	0007071b          	sext.w	a4,a4
   132b4:	0007879b          	sext.w	a5,a5
   132b8:	02f71263          	bne	a4,a5,132dc <get_dev_bar+0xd8>
   132bc:	fc445783          	lhu	a5,-60(s0)
   132c0:	fb445703          	lhu	a4,-76(s0)
   132c4:	0007071b          	sext.w	a4,a4
   132c8:	0007879b          	sext.w	a5,a5
   132cc:	00f71863          	bne	a4,a5,132dc <get_dev_bar+0xd8>
            return dcfg.u.addr_start;
   132d0:	fd043783          	ld	a5,-48(s0)
   132d4:	02c0006f          	j	13300 <get_dev_bar+0xfc>
            continue;
   132d8:	00000013          	nop
    for (int i = 0; i < slots_total; i++) {
   132dc:	fe842783          	lw	a5,-24(s0)
   132e0:	0017879b          	addiw	a5,a5,1
   132e4:	fef42423          	sw	a5,-24(s0)
   132e8:	fe842703          	lw	a4,-24(s0)
   132ec:	fe442783          	lw	a5,-28(s0)
   132f0:	0007071b          	sext.w	a4,a4
   132f4:	0007879b          	sext.w	a5,a5
   132f8:	f4f74ce3          	blt	a4,a5,13250 <get_dev_bar+0x4c>
    return DEV_NONE;
   132fc:	fff00793          	li	a5,-1
}
   13300:	00078513          	mv	a0,a5
   13304:	04813403          	ld	s0,72(sp)
   13308:	05010113          	addi	sp,sp,80
   1330c:	00008067          	ret

0000000000013310 <mpu_region_total>:
static int mpu_region_total() {
   13310:	fe010113          	addi	sp,sp,-32
   13314:	00813c23          	sd	s0,24(sp)
   13318:	02010413          	addi	s0,sp,32
    uint64_t val = 0;
   1331c:	fe043423          	sd	zero,-24(s0)
    asm("csrr %0, 0xBC4" : "=r" (val));
   13320:	bc4027f3          	csrr	a5,0xbc4
   13324:	fef43423          	sd	a5,-24(s0)
    return (int)(val >> 8);
   13328:	fe843783          	ld	a5,-24(s0)
   1332c:	0087d793          	srli	a5,a5,0x8
   13330:	0007879b          	sext.w	a5,a5
}
   13334:	00078513          	mv	a0,a5
   13338:	01813403          	ld	s0,24(sp)
   1333c:	02010113          	addi	sp,sp,32
   13340:	00008067          	ret

0000000000013344 <mpu_disable_region>:
static void mpu_disable_region(int idx) {
   13344:	fd010113          	addi	sp,sp,-48
   13348:	02813423          	sd	s0,40(sp)
   1334c:	03010413          	addi	s0,sp,48
   13350:	00050793          	mv	a5,a0
   13354:	fcf42e23          	sw	a5,-36(s0)
    ctrl.value = 0;
   13358:	fe043423          	sd	zero,-24(s0)
    ctrl.bits.IDX = idx;
   1335c:	fdc42783          	lw	a5,-36(s0)
   13360:	0ff7f793          	andi	a5,a5,255
   13364:	fef404a3          	sb	a5,-23(s0)
    ctrl.bits.WE = 1;
   13368:	fe844783          	lbu	a5,-24(s0)
   1336c:	f807e793          	ori	a5,a5,-128
   13370:	fef40423          	sb	a5,-24(s0)
    asm("csrw 0xBC4, %0" : :"r"(ctrl.value));
   13374:	fe843783          	ld	a5,-24(s0)
   13378:	bc479073          	csrw	0xbc4,a5
}
   1337c:	00000013          	nop
   13380:	02813403          	ld	s0,40(sp)
   13384:	03010113          	addi	sp,sp,48
   13388:	00008067          	ret

000000000001338c <mpu_enable_region>:
                       const char *rwx) {
   1338c:	fb010113          	addi	sp,sp,-80
   13390:	04813423          	sd	s0,72(sp)
   13394:	05010413          	addi	s0,sp,80
   13398:	00050793          	mv	a5,a0
   1339c:	fcb43023          	sd	a1,-64(s0)
   133a0:	fac43c23          	sd	a2,-72(s0)
   133a4:	fae43823          	sd	a4,-80(s0)
   133a8:	fcf42623          	sw	a5,-52(s0)
   133ac:	00068793          	mv	a5,a3
   133b0:	fcf42423          	sw	a5,-56(s0)
    uint64_t mask = (~0ull) << 10;
   133b4:	c0000793          	li	a5,-1024
   133b8:	fef43423          	sd	a5,-24(s0)
    const char *p = rwx;
   133bc:	fb043783          	ld	a5,-80(s0)
   133c0:	fef43023          	sd	a5,-32(s0)
    asm("csrw 0xBC2, %0" : :"r"(bar));
   133c4:	fc043783          	ld	a5,-64(s0)
   133c8:	bc279073          	csrw	0xbc2,a5
    KB >>= 1;
   133cc:	fb843783          	ld	a5,-72(s0)
   133d0:	0017d793          	srli	a5,a5,0x1
   133d4:	faf43c23          	sd	a5,-72(s0)
    while (KB) {
   133d8:	01c0006f          	j	133f4 <mpu_enable_region+0x68>
        mask <<= 1;
   133dc:	fe843783          	ld	a5,-24(s0)
   133e0:	00179793          	slli	a5,a5,0x1
   133e4:	fef43423          	sd	a5,-24(s0)
        KB >>= 1;
   133e8:	fb843783          	ld	a5,-72(s0)
   133ec:	0017d793          	srli	a5,a5,0x1
   133f0:	faf43c23          	sd	a5,-72(s0)
    while (KB) {
   133f4:	fb843783          	ld	a5,-72(s0)
   133f8:	fe0792e3          	bnez	a5,133dc <mpu_enable_region+0x50>
    asm("csrw 0xBC3, %0" : :"r"(mask));
   133fc:	fe843783          	ld	a5,-24(s0)
   13400:	bc379073          	csrw	0xbc3,a5
    ctrl.value = 0;
   13404:	fc043c23          	sd	zero,-40(s0)
    ctrl.bits.IDX = idx;
   13408:	fcc42783          	lw	a5,-52(s0)
   1340c:	0ff7f793          	andi	a5,a5,255
   13410:	fcf40ca3          	sb	a5,-39(s0)
    ctrl.bits.ENA = 1;
   13414:	fd844783          	lbu	a5,-40(s0)
   13418:	0107e793          	ori	a5,a5,16
   1341c:	fcf40c23          	sb	a5,-40(s0)
    ctrl.bits.CACHABLE = cached;
   13420:	fc842783          	lw	a5,-56(s0)
   13424:	0017f793          	andi	a5,a5,1
   13428:	0ff7f793          	andi	a5,a5,255
   1342c:	0017f793          	andi	a5,a5,1
   13430:	0037969b          	slliw	a3,a5,0x3
   13434:	fd844783          	lbu	a5,-40(s0)
   13438:	ff77f793          	andi	a5,a5,-9
   1343c:	00078713          	mv	a4,a5
   13440:	00068793          	mv	a5,a3
   13444:	00f767b3          	or	a5,a4,a5
   13448:	fcf40c23          	sb	a5,-40(s0)
    ctrl.bits.WE = 1; // write into MPU
   1344c:	fd844783          	lbu	a5,-40(s0)
   13450:	f807e793          	ori	a5,a5,-128
   13454:	fcf40c23          	sb	a5,-40(s0)
    while (*p) {
   13458:	0700006f          	j	134c8 <mpu_enable_region+0x13c>
        if (*p == 'r') {
   1345c:	fe043783          	ld	a5,-32(s0)
   13460:	0007c783          	lbu	a5,0(a5)
   13464:	00078713          	mv	a4,a5
   13468:	07200793          	li	a5,114
   1346c:	00f71863          	bne	a4,a5,1347c <mpu_enable_region+0xf0>
            ctrl.bits.RD = 1;
   13470:	fd844783          	lbu	a5,-40(s0)
   13474:	0027e793          	ori	a5,a5,2
   13478:	fcf40c23          	sb	a5,-40(s0)
        if (*p == 'w') {
   1347c:	fe043783          	ld	a5,-32(s0)
   13480:	0007c783          	lbu	a5,0(a5)
   13484:	00078713          	mv	a4,a5
   13488:	07700793          	li	a5,119
   1348c:	00f71863          	bne	a4,a5,1349c <mpu_enable_region+0x110>
            ctrl.bits.WR = 1;
   13490:	fd844783          	lbu	a5,-40(s0)
   13494:	0017e793          	ori	a5,a5,1
   13498:	fcf40c23          	sb	a5,-40(s0)
        if (*p == 'x') {
   1349c:	fe043783          	ld	a5,-32(s0)
   134a0:	0007c783          	lbu	a5,0(a5)
   134a4:	00078713          	mv	a4,a5
   134a8:	07800793          	li	a5,120
   134ac:	00f71863          	bne	a4,a5,134bc <mpu_enable_region+0x130>
            ctrl.bits.EXEC = 1;
   134b0:	fd844783          	lbu	a5,-40(s0)
   134b4:	0047e793          	ori	a5,a5,4
   134b8:	fcf40c23          	sb	a5,-40(s0)
        p++;
   134bc:	fe043783          	ld	a5,-32(s0)
   134c0:	00178793          	addi	a5,a5,1
   134c4:	fef43023          	sd	a5,-32(s0)
    while (*p) {
   134c8:	fe043783          	ld	a5,-32(s0)
   134cc:	0007c783          	lbu	a5,0(a5)
   134d0:	f80796e3          	bnez	a5,1345c <mpu_enable_region+0xd0>
    asm("csrw 0xBC4, %0" : :"r"(ctrl.value));
   134d4:	fd843783          	ld	a5,-40(s0)
   134d8:	bc479073          	csrw	0xbc4,a5
}
   134dc:	00000013          	nop
   134e0:	04813403          	ld	s0,72(sp)
   134e4:	05010113          	addi	sp,sp,80
   134e8:	00008067          	ret

00000000000134ec <get_vendor_name>:
};

/**
 * @brief Get device Vendor name by its ID
 */
static const char *get_vendor_name(uint16_t vid) {
   134ec:	fe010113          	addi	sp,sp,-32
   134f0:	00813c23          	sd	s0,24(sp)
   134f4:	02010413          	addi	s0,sp,32
   134f8:	00050793          	mv	a5,a0
   134fc:	fef41723          	sh	a5,-18(s0)
    if (vid == VENDOR_GNSSSENSOR || vid == VENDOR_OPTIMITECH) {
   13500:	fee45783          	lhu	a5,-18(s0)
   13504:	0007871b          	sext.w	a4,a5
   13508:	0f100793          	li	a5,241
   1350c:	00f70a63          	beq	a4,a5,13520 <get_vendor_name+0x34>
   13510:	fee45783          	lhu	a5,-18(s0)
   13514:	0007871b          	sext.w	a4,a5
   13518:	0f200793          	li	a5,242
   1351c:	00f71863          	bne	a4,a5,1352c <get_vendor_name+0x40>
        return VENDOR_NAME;
   13520:	0001a7b7          	lui	a5,0x1a
   13524:	5c878793          	addi	a5,a5,1480 # 1a5c8 <strnlen+0x1c6>
   13528:	02c0006f          	j	13554 <get_vendor_name+0x68>
    }
    if (vid == 0xABCD) {
   1352c:	fee45783          	lhu	a5,-18(s0)
   13530:	0007871b          	sext.w	a4,a5
   13534:	0000b7b7          	lui	a5,0xb
   13538:	bcd78793          	addi	a5,a5,-1075 # abcd <_ftext-0x5433>
   1353c:	00f71863          	bne	a4,a5,1354c <get_vendor_name+0x60>
        return MIKRON_NAME;
   13540:	0001a7b7          	lui	a5,0x1a
   13544:	5e878793          	addi	a5,a5,1512 # 1a5e8 <strnlen+0x1e6>
   13548:	00c0006f          	j	13554 <get_vendor_name+0x68>
    }
    return UNKOWN_ID_NAME;
   1354c:	0001a7b7          	lui	a5,0x1a
   13550:	62078793          	addi	a5,a5,1568 # 1a620 <strnlen+0x21e>
}
   13554:	00078513          	mv	a0,a5
   13558:	01813403          	ld	s0,24(sp)
   1355c:	02010113          	addi	sp,sp,32
   13560:	00008067          	ret

0000000000013564 <get_device_name>:

/**
 * @brief Get device Name by Vendor ID and Device ID
 */
static const char *get_device_name(uint16_t vid, uint16_t did)
{
   13564:	fe010113          	addi	sp,sp,-32
   13568:	00813c23          	sd	s0,24(sp)
   1356c:	02010413          	addi	s0,sp,32
   13570:	00050793          	mv	a5,a0
   13574:	00058713          	mv	a4,a1
   13578:	fef41723          	sh	a5,-18(s0)
   1357c:	00070793          	mv	a5,a4
   13580:	fef41623          	sh	a5,-20(s0)
    if (vid != VENDOR_GNSSSENSOR && vid != VENDOR_OPTIMITECH) {
   13584:	fee45783          	lhu	a5,-18(s0)
   13588:	0007871b          	sext.w	a4,a5
   1358c:	0f100793          	li	a5,241
   13590:	04f70063          	beq	a4,a5,135d0 <get_device_name+0x6c>
   13594:	fee45783          	lhu	a5,-18(s0)
   13598:	0007871b          	sext.w	a4,a5
   1359c:	0f200793          	li	a5,242
   135a0:	02f70863          	beq	a4,a5,135d0 <get_device_name+0x6c>
        if (did == 0x1234) {
   135a4:	fec45783          	lhu	a5,-20(s0)
   135a8:	0007871b          	sext.w	a4,a5
   135ac:	000017b7          	lui	a5,0x1
   135b0:	23478793          	addi	a5,a5,564 # 1234 <_ftext-0xedcc>
   135b4:	00f71863          	bne	a4,a5,135c4 <get_device_name+0x60>
            return MIKRON_SLV_DEVICE_NAMES[0];
   135b8:	0001b7b7          	lui	a5,0x1b
   135bc:	a5878793          	addi	a5,a5,-1448 # 1aa58 <XSLV_DEVICE_NAMES+0x120>
   135c0:	0e80006f          	j	136a8 <get_device_name+0x144>
        }
        return UNKOWN_ID_NAME;
   135c4:	0001a7b7          	lui	a5,0x1a
   135c8:	62078793          	addi	a5,a5,1568 # 1a620 <strnlen+0x21e>
   135cc:	0dc0006f          	j	136a8 <get_device_name+0x144>
    }
    if (did == MST_DID_EMPTY) {
   135d0:	fec45783          	lhu	a5,-20(s0)
   135d4:	0007871b          	sext.w	a4,a5
   135d8:	000077b7          	lui	a5,0x7
   135dc:	75578793          	addi	a5,a5,1877 # 7755 <_ftext-0x88ab>
   135e0:	00f71863          	bne	a4,a5,135f0 <get_device_name+0x8c>
        return MST_DID_EMPTY_NAME;
   135e4:	0001a7b7          	lui	a5,0x1a
   135e8:	5f078793          	addi	a5,a5,1520 # 1a5f0 <strnlen+0x1ee>
   135ec:	0bc0006f          	j	136a8 <get_device_name+0x144>
    }
    if (did == SLV_DID_EMPTY) {
   135f0:	fec45783          	lhu	a5,-20(s0)
   135f4:	0007871b          	sext.w	a4,a5
   135f8:	000057b7          	lui	a5,0x5
   135fc:	57778793          	addi	a5,a5,1399 # 5577 <_ftext-0xaa89>
   13600:	00f71863          	bne	a4,a5,13610 <get_device_name+0xac>
        return SLV_DID_EMPTY_NAME;
   13604:	0001a7b7          	lui	a5,0x1a
   13608:	60878793          	addi	a5,a5,1544 # 1a608 <strnlen+0x206>
   1360c:	09c0006f          	j	136a8 <get_device_name+0x144>
    }
    if (did >= GNSS_SUB_SYSTEM && did <= DID_LAST) {
   13610:	fec45783          	lhu	a5,-20(s0)
   13614:	0007871b          	sext.w	a4,a5
   13618:	06600793          	li	a5,102
   1361c:	02e7fe63          	bleu	a4,a5,13658 <get_device_name+0xf4>
   13620:	fec45783          	lhu	a5,-20(s0)
   13624:	0007871b          	sext.w	a4,a5
   13628:	08a00793          	li	a5,138
   1362c:	02e7e663          	bltu	a5,a4,13658 <get_device_name+0xf4>
        return XSLV_DEVICE_NAMES[did - GNSS_SUB_SYSTEM];
   13630:	fec45783          	lhu	a5,-20(s0)
   13634:	0007879b          	sext.w	a5,a5
   13638:	f997879b          	addiw	a5,a5,-103
   1363c:	0007871b          	sext.w	a4,a5
   13640:	0001b7b7          	lui	a5,0x1b
   13644:	00371713          	slli	a4,a4,0x3
   13648:	93878793          	addi	a5,a5,-1736 # 1a938 <XSLV_DEVICE_NAMES>
   1364c:	00f707b3          	add	a5,a4,a5
   13650:	0007b783          	ld	a5,0(a5)
   13654:	0540006f          	j	136a8 <get_device_name+0x144>
    }
    if (did >= RISCV_CACHED_TILELINK && did <= GNSSSENSOR_JTAG_TAP) {
   13658:	fec45783          	lhu	a5,-20(s0)
   1365c:	0007871b          	sext.w	a4,a5
   13660:	4ff00793          	li	a5,1279
   13664:	02e7fe63          	bleu	a4,a5,136a0 <get_device_name+0x13c>
   13668:	fec45783          	lhu	a5,-20(s0)
   1366c:	0007871b          	sext.w	a4,a5
   13670:	50b00793          	li	a5,1291
   13674:	02e7e663          	bltu	a5,a4,136a0 <get_device_name+0x13c>
        return XMST_DEVICE_NAMES[did - RISCV_CACHED_TILELINK];
   13678:	fec45783          	lhu	a5,-20(s0)
   1367c:	0007879b          	sext.w	a5,a5
   13680:	b007879b          	addiw	a5,a5,-1280
   13684:	0007871b          	sext.w	a4,a5
   13688:	0001a7b7          	lui	a5,0x1a
   1368c:	00371713          	slli	a4,a4,0x3
   13690:	71078793          	addi	a5,a5,1808 # 1a710 <XMST_DEVICE_NAMES>
   13694:	00f707b3          	add	a5,a4,a5
   13698:	0007b783          	ld	a5,0(a5)
   1369c:	00c0006f          	j	136a8 <get_device_name+0x144>
    }
    return UNKOWN_ID_NAME;
   136a0:	0001a7b7          	lui	a5,0x1a
   136a4:	62078793          	addi	a5,a5,1568 # 1a620 <strnlen+0x21e>
}
   136a8:	00078513          	mv	a0,a5
   136ac:	01813403          	ld	s0,24(sp)
   136b0:	02010113          	addi	sp,sp,32
   136b4:	00008067          	ret

00000000000136b8 <print_pnp>:

void print_pnp() {
   136b8:	fa010113          	addi	sp,sp,-96
   136bc:	04113c23          	sd	ra,88(sp)
   136c0:	04813823          	sd	s0,80(sp)
   136c4:	04913423          	sd	s1,72(sp)
   136c8:	06010413          	addi	s0,sp,96
    dev_cfg_type dcfg;
    pnp_map *pnp = (pnp_map *)ADDR_BUS0_XSLV_PNP;
   136cc:	100ff7b7          	lui	a5,0x100ff
   136d0:	fcf43823          	sd	a5,-48(s0)
    int slots_total = (pnp->cfg >> 8) & 0xFF;
   136d4:	fd043783          	ld	a5,-48(s0)
   136d8:	0087a783          	lw	a5,8(a5) # 100ff008 <_end+0x100df76c>
   136dc:	0087d79b          	srliw	a5,a5,0x8
   136e0:	0007879b          	sext.w	a5,a5
   136e4:	0007879b          	sext.w	a5,a5
   136e8:	0ff7f793          	andi	a5,a5,255
   136ec:	fcf42623          	sw	a5,-52(s0)
    int off = 0;
   136f0:	fc042e23          	sw	zero,-36(s0)
    uint32_t xsize;

    printf_uart("\r\n# Plug'n'Play info:\r\n");
   136f4:	0001b7b7          	lui	a5,0x1b
   136f8:	a6878513          	addi	a0,a5,-1432 # 1aa68 <XSLV_DEVICE_NAMES+0x130>
   136fc:	fffff097          	auipc	ra,0xfffff
   13700:	254080e7          	jalr	596(ra) # 12950 <printf_uart>

    for (int i = 0; i < slots_total; i++) {
   13704:	fc042c23          	sw	zero,-40(s0)
   13708:	1e00006f          	j	138e8 <print_pnp+0x230>
        dcfg = *(dev_cfg_type *)&pnp->cfg_table[off];
   1370c:	fdc42783          	lw	a5,-36(s0)
   13710:	04078793          	addi	a5,a5,64
   13714:	fd043703          	ld	a4,-48(s0)
   13718:	00f707b3          	add	a5,a4,a5
   1371c:	0007b703          	ld	a4,0(a5)
   13720:	fae43423          	sd	a4,-88(s0)
   13724:	0087b703          	ld	a4,8(a5)
   13728:	fae43823          	sd	a4,-80(s0)
   1372c:	0107b703          	ld	a4,16(a5)
   13730:	fae43c23          	sd	a4,-72(s0)
   13734:	0187b783          	ld	a5,24(a5)
   13738:	fcf43023          	sd	a5,-64(s0)
        off += sizeof(dcfg);
   1373c:	fdc42783          	lw	a5,-36(s0)
   13740:	0207879b          	addiw	a5,a5,32
   13744:	0007879b          	sext.w	a5,a5
   13748:	fcf42e23          	sw	a5,-36(s0)

        if (dcfg.u.descrtype == PNP_CFG_TYPE_MASTER) {
   1374c:	fa944783          	lbu	a5,-87(s0)
   13750:	0037f793          	andi	a5,a5,3
   13754:	0ff7f793          	andi	a5,a5,255
   13758:	00078713          	mv	a4,a5
   1375c:	00100793          	li	a5,1
   13760:	04f71a63          	bne	a4,a5,137b4 <print_pnp+0xfc>
            printf_uart("# AXI4: mst%d: %s    %s\r\n", i, 
   13764:	fae45783          	lhu	a5,-82(s0)
   13768:	00078513          	mv	a0,a5
   1376c:	d81ff0ef          	jal	ra,134ec <get_vendor_name>
   13770:	00050493          	mv	s1,a0
   13774:	fae45783          	lhu	a5,-82(s0)
   13778:	fac45703          	lhu	a4,-84(s0)
   1377c:	00070593          	mv	a1,a4
   13780:	00078513          	mv	a0,a5
   13784:	00000097          	auipc	ra,0x0
   13788:	de0080e7          	jalr	-544(ra) # 13564 <get_device_name>
   1378c:	00050713          	mv	a4,a0
   13790:	fd842783          	lw	a5,-40(s0)
   13794:	00070693          	mv	a3,a4
   13798:	00048613          	mv	a2,s1
   1379c:	00078593          	mv	a1,a5
   137a0:	0001b7b7          	lui	a5,0x1b
   137a4:	a8078513          	addi	a0,a5,-1408 # 1aa80 <XSLV_DEVICE_NAMES+0x148>
   137a8:	fffff097          	auipc	ra,0xfffff
   137ac:	1a8080e7          	jalr	424(ra) # 12950 <printf_uart>
   137b0:	12c0006f          	j	138dc <print_pnp+0x224>
                    get_vendor_name(dcfg.u.vid),
                    get_device_name(dcfg.u.vid, dcfg.u.did));
        } else if (dcfg.u.descrtype == PNP_CFG_TYPE_SLAVE) {
   137b4:	fa944783          	lbu	a5,-87(s0)
   137b8:	0037f793          	andi	a5,a5,3
   137bc:	0ff7f793          	andi	a5,a5,255
   137c0:	00078713          	mv	a4,a5
   137c4:	00200793          	li	a5,2
   137c8:	10f71a63          	bne	a4,a5,138dc <print_pnp+0x224>
            printf_uart("# AXI4: slv%d: %s    %s\r\n", i, 
   137cc:	fae45783          	lhu	a5,-82(s0)
   137d0:	00078513          	mv	a0,a5
   137d4:	d19ff0ef          	jal	ra,134ec <get_vendor_name>
   137d8:	00050493          	mv	s1,a0
   137dc:	fae45783          	lhu	a5,-82(s0)
   137e0:	fac45703          	lhu	a4,-84(s0)
   137e4:	00070593          	mv	a1,a4
   137e8:	00078513          	mv	a0,a5
   137ec:	00000097          	auipc	ra,0x0
   137f0:	d78080e7          	jalr	-648(ra) # 13564 <get_device_name>
   137f4:	00050713          	mv	a4,a0
   137f8:	fd842783          	lw	a5,-40(s0)
   137fc:	00070693          	mv	a3,a4
   13800:	00048613          	mv	a2,s1
   13804:	00078593          	mv	a1,a5
   13808:	0001b7b7          	lui	a5,0x1b
   1380c:	aa078513          	addi	a0,a5,-1376 # 1aaa0 <XSLV_DEVICE_NAMES+0x168>
   13810:	fffff097          	auipc	ra,0xfffff
   13814:	140080e7          	jalr	320(ra) # 12950 <printf_uart>
                    get_vendor_name(dcfg.u.vid),
                    get_device_name(dcfg.u.vid, dcfg.u.did));

            xsize = dcfg.u.addr_end - dcfg.u.addr_start;
   13818:	fc043783          	ld	a5,-64(s0)
   1381c:	0007871b          	sext.w	a4,a5
   13820:	fb843783          	ld	a5,-72(s0)
   13824:	0007879b          	sext.w	a5,a5
   13828:	40f707bb          	subw	a5,a4,a5
   1382c:	fcf42423          	sw	a5,-56(s0)

            printf_uart("#    %016llx...%016llx, size = ",
   13830:	fb843703          	ld	a4,-72(s0)
                dcfg.u.addr_start, (dcfg.u.addr_end - 1));
   13834:	fc043783          	ld	a5,-64(s0)
            printf_uart("#    %016llx...%016llx, size = ",
   13838:	fff78793          	addi	a5,a5,-1
   1383c:	00078613          	mv	a2,a5
   13840:	00070593          	mv	a1,a4
   13844:	0001b7b7          	lui	a5,0x1b
   13848:	ac078513          	addi	a0,a5,-1344 # 1aac0 <XSLV_DEVICE_NAMES+0x188>
   1384c:	fffff097          	auipc	ra,0xfffff
   13850:	104080e7          	jalr	260(ra) # 12950 <printf_uart>
            if (xsize < 1024) {
   13854:	fc842783          	lw	a5,-56(s0)
   13858:	0007871b          	sext.w	a4,a5
   1385c:	3ff00793          	li	a5,1023
   13860:	02e7e063          	bltu	a5,a4,13880 <print_pnp+0x1c8>
                printf_uart("%d bytes\r\n", (int)xsize);
   13864:	fc842783          	lw	a5,-56(s0)
   13868:	00078593          	mv	a1,a5
   1386c:	0001b7b7          	lui	a5,0x1b
   13870:	ae078513          	addi	a0,a5,-1312 # 1aae0 <XSLV_DEVICE_NAMES+0x1a8>
   13874:	fffff097          	auipc	ra,0xfffff
   13878:	0dc080e7          	jalr	220(ra) # 12950 <printf_uart>
   1387c:	0600006f          	j	138dc <print_pnp+0x224>
            } else if (xsize < 1024*1024) {
   13880:	fc842783          	lw	a5,-56(s0)
   13884:	0007871b          	sext.w	a4,a5
   13888:	001007b7          	lui	a5,0x100
   1388c:	02f77663          	bleu	a5,a4,138b8 <print_pnp+0x200>
                printf_uart("%d KB\r\n", (int)(xsize >> 10));
   13890:	fc842783          	lw	a5,-56(s0)
   13894:	00a7d79b          	srliw	a5,a5,0xa
   13898:	0007879b          	sext.w	a5,a5
   1389c:	0007879b          	sext.w	a5,a5
   138a0:	00078593          	mv	a1,a5
   138a4:	0001b7b7          	lui	a5,0x1b
   138a8:	af078513          	addi	a0,a5,-1296 # 1aaf0 <XSLV_DEVICE_NAMES+0x1b8>
   138ac:	fffff097          	auipc	ra,0xfffff
   138b0:	0a4080e7          	jalr	164(ra) # 12950 <printf_uart>
   138b4:	0280006f          	j	138dc <print_pnp+0x224>
            } else {
                printf_uart("%d MB\r\n", (int)(xsize >> 20));
   138b8:	fc842783          	lw	a5,-56(s0)
   138bc:	0147d79b          	srliw	a5,a5,0x14
   138c0:	0007879b          	sext.w	a5,a5
   138c4:	0007879b          	sext.w	a5,a5
   138c8:	00078593          	mv	a1,a5
   138cc:	0001b7b7          	lui	a5,0x1b
   138d0:	af878513          	addi	a0,a5,-1288 # 1aaf8 <XSLV_DEVICE_NAMES+0x1c0>
   138d4:	fffff097          	auipc	ra,0xfffff
   138d8:	07c080e7          	jalr	124(ra) # 12950 <printf_uart>
    for (int i = 0; i < slots_total; i++) {
   138dc:	fd842783          	lw	a5,-40(s0)
   138e0:	0017879b          	addiw	a5,a5,1
   138e4:	fcf42c23          	sw	a5,-40(s0)
   138e8:	fd842703          	lw	a4,-40(s0)
   138ec:	fcc42783          	lw	a5,-52(s0)
   138f0:	0007071b          	sext.w	a4,a4
   138f4:	0007879b          	sext.w	a5,a5
   138f8:	e0f74ae3          	blt	a4,a5,1370c <print_pnp+0x54>
            }
        }
    }
}
   138fc:	00000013          	nop
   13900:	05813083          	ld	ra,88(sp)
   13904:	05013403          	ld	s0,80(sp)
   13908:	04813483          	ld	s1,72(sp)
   1390c:	06010113          	addi	sp,sp,96
   13910:	00008067          	ret
   13914:	0000                	unimp
	...

0000000000013918 <test_fpu>:

#include <string.h>
#include "fw_api.h"
#include "test_fpu.h"

void test_fpu(void) { 
   13918:	f9010113          	addi	sp,sp,-112
   1391c:	06113423          	sd	ra,104(sp)
   13920:	06813023          	sd	s0,96(sp)
   13924:	07010413          	addi	s0,sp,112
    Reg64Type a, b, res;
    int64_t ix3;
    uint64_t ux3;
    int err_cnt = 0;
   13928:	fe042623          	sw	zero,-20(s0)
#ifdef FPU_ENABLED
    printf_uart("%s", "HW_FPU . . . . .testing\r\n");
   1392c:	0001d7b7          	lui	a5,0x1d
   13930:	72878593          	addi	a1,a5,1832 # 1d728 <FCVT_WU_D_TESTS+0xf0>
   13934:	0001d7b7          	lui	a5,0x1d
   13938:	74878513          	addi	a0,a5,1864 # 1d748 <FCVT_WU_D_TESTS+0x110>
   1393c:	fffff097          	auipc	ra,0xfffff
   13940:	014080e7          	jalr	20(ra) # 12950 <printf_uart>
#else
    printf_uart("%s", "SOFT_FPU . . . .testing\r\n");
#endif

#ifdef ENABLE_FADD_TESTS
    printf_uart("Testing %s\r\n", "FADD");
   13944:	0001d7b7          	lui	a5,0x1d
   13948:	75078593          	addi	a1,a5,1872 # 1d750 <FCVT_WU_D_TESTS+0x118>
   1394c:	0001d7b7          	lui	a5,0x1d
   13950:	75878513          	addi	a0,a5,1880 # 1d758 <FCVT_WU_D_TESTS+0x120>
   13954:	fffff097          	auipc	ra,0xfffff
   13958:	ffc080e7          	jalr	-4(ra) # 12950 <printf_uart>
    for (size_t i = 0; i < FADD_LENGTH; i++) {
   1395c:	fe043023          	sd	zero,-32(s0)
   13960:	0bc0006f          	j	13a1c <test_fpu+0x104>
        a.val = FADD_TESTS[i].a;
   13964:	0001b6b7          	lui	a3,0x1b
   13968:	fe043703          	ld	a4,-32(s0)
   1396c:	00070793          	mv	a5,a4
   13970:	00179793          	slli	a5,a5,0x1
   13974:	00e787b3          	add	a5,a5,a4
   13978:	00379793          	slli	a5,a5,0x3
   1397c:	b0068713          	addi	a4,a3,-1280 # 1ab00 <FADD_TESTS>
   13980:	00e787b3          	add	a5,a5,a4
   13984:	0007b783          	ld	a5,0(a5)
   13988:	faf43023          	sd	a5,-96(s0)
        b.val = FADD_TESTS[i].b;
   1398c:	0001b7b7          	lui	a5,0x1b
   13990:	fe043703          	ld	a4,-32(s0)
   13994:	b0078693          	addi	a3,a5,-1280 # 1ab00 <FADD_TESTS>
   13998:	00070793          	mv	a5,a4
   1399c:	00179793          	slli	a5,a5,0x1
   139a0:	00e787b3          	add	a5,a5,a4
   139a4:	00379793          	slli	a5,a5,0x3
   139a8:	00f687b3          	add	a5,a3,a5
   139ac:	0087b783          	ld	a5,8(a5)
   139b0:	f8f43c23          	sd	a5,-104(s0)
        res.f64 = a.f64 + b.f64;
   139b4:	fa043707          	fld	fa4,-96(s0)
   139b8:	f9843787          	fld	fa5,-104(s0)
   139bc:	02f777d3          	fadd.d	fa5,fa4,fa5
   139c0:	f8f43827          	fsd	fa5,-112(s0)
        if (res.val != FADD_TESTS[i].res) {
   139c4:	f9043683          	ld	a3,-112(s0)
   139c8:	0001b637          	lui	a2,0x1b
   139cc:	fe043703          	ld	a4,-32(s0)
   139d0:	00070793          	mv	a5,a4
   139d4:	00179793          	slli	a5,a5,0x1
   139d8:	00e787b3          	add	a5,a5,a4
   139dc:	00379793          	slli	a5,a5,0x3
   139e0:	b0060713          	addi	a4,a2,-1280 # 1ab00 <FADD_TESTS>
   139e4:	00e787b3          	add	a5,a5,a4
   139e8:	0107b783          	ld	a5,16(a5)
   139ec:	02f68263          	beq	a3,a5,13a10 <test_fpu+0xf8>
            err_cnt++;
   139f0:	fec42783          	lw	a5,-20(s0)
   139f4:	0017879b          	addiw	a5,a5,1
   139f8:	fef42623          	sw	a5,-20(s0)
            printf_uart("FADD[%d] fail\r\n", i);
   139fc:	fe043583          	ld	a1,-32(s0)
   13a00:	0001d7b7          	lui	a5,0x1d
   13a04:	76878513          	addi	a0,a5,1896 # 1d768 <FCVT_WU_D_TESTS+0x130>
   13a08:	fffff097          	auipc	ra,0xfffff
   13a0c:	f48080e7          	jalr	-184(ra) # 12950 <printf_uart>
    for (size_t i = 0; i < FADD_LENGTH; i++) {
   13a10:	fe043783          	ld	a5,-32(s0)
   13a14:	00178793          	addi	a5,a5,1
   13a18:	fef43023          	sd	a5,-32(s0)
   13a1c:	0b100793          	li	a5,177
   13a20:	fe043703          	ld	a4,-32(s0)
   13a24:	f4f760e3          	bltu	a4,a5,13964 <test_fpu+0x4c>
        }
    }
#endif

#ifdef ENABLE_FMUL_TESTS
    printf_uart("Testing %s\r\n", "FMUL");
   13a28:	0001d7b7          	lui	a5,0x1d
   13a2c:	77878593          	addi	a1,a5,1912 # 1d778 <FCVT_WU_D_TESTS+0x140>
   13a30:	0001d7b7          	lui	a5,0x1d
   13a34:	75878513          	addi	a0,a5,1880 # 1d758 <FCVT_WU_D_TESTS+0x120>
   13a38:	fffff097          	auipc	ra,0xfffff
   13a3c:	f18080e7          	jalr	-232(ra) # 12950 <printf_uart>
    for (size_t i = 0; i < FMUL_LENGTH; i++) {
   13a40:	fc043c23          	sd	zero,-40(s0)
   13a44:	0bc0006f          	j	13b00 <test_fpu+0x1e8>
        a.val = FMUL_TESTS[i].a;
   13a48:	0001c6b7          	lui	a3,0x1c
   13a4c:	fd843703          	ld	a4,-40(s0)
   13a50:	00070793          	mv	a5,a4
   13a54:	00179793          	slli	a5,a5,0x1
   13a58:	00e787b3          	add	a5,a5,a4
   13a5c:	00379793          	slli	a5,a5,0x3
   13a60:	b9868713          	addi	a4,a3,-1128 # 1bb98 <FMUL_TESTS>
   13a64:	00e787b3          	add	a5,a5,a4
   13a68:	0007b783          	ld	a5,0(a5)
   13a6c:	faf43023          	sd	a5,-96(s0)
        b.val = FMUL_TESTS[i].b;
   13a70:	0001c7b7          	lui	a5,0x1c
   13a74:	fd843703          	ld	a4,-40(s0)
   13a78:	b9878693          	addi	a3,a5,-1128 # 1bb98 <FMUL_TESTS>
   13a7c:	00070793          	mv	a5,a4
   13a80:	00179793          	slli	a5,a5,0x1
   13a84:	00e787b3          	add	a5,a5,a4
   13a88:	00379793          	slli	a5,a5,0x3
   13a8c:	00f687b3          	add	a5,a3,a5
   13a90:	0087b783          	ld	a5,8(a5)
   13a94:	f8f43c23          	sd	a5,-104(s0)
        res.f64 = a.f64 * b.f64;
   13a98:	fa043707          	fld	fa4,-96(s0)
   13a9c:	f9843787          	fld	fa5,-104(s0)
   13aa0:	12f777d3          	fmul.d	fa5,fa4,fa5
   13aa4:	f8f43827          	fsd	fa5,-112(s0)
        if (res.val != FMUL_TESTS[i].res) {
   13aa8:	f9043683          	ld	a3,-112(s0)
   13aac:	0001c637          	lui	a2,0x1c
   13ab0:	fd843703          	ld	a4,-40(s0)
   13ab4:	00070793          	mv	a5,a4
   13ab8:	00179793          	slli	a5,a5,0x1
   13abc:	00e787b3          	add	a5,a5,a4
   13ac0:	00379793          	slli	a5,a5,0x3
   13ac4:	b9860713          	addi	a4,a2,-1128 # 1bb98 <FMUL_TESTS>
   13ac8:	00e787b3          	add	a5,a5,a4
   13acc:	0107b783          	ld	a5,16(a5)
   13ad0:	02f68263          	beq	a3,a5,13af4 <test_fpu+0x1dc>
            err_cnt++;
   13ad4:	fec42783          	lw	a5,-20(s0)
   13ad8:	0017879b          	addiw	a5,a5,1
   13adc:	fef42623          	sw	a5,-20(s0)
            printf_uart("FMUL[%d] fail\r\n", i);
   13ae0:	fd843583          	ld	a1,-40(s0)
   13ae4:	0001d7b7          	lui	a5,0x1d
   13ae8:	78078513          	addi	a0,a5,1920 # 1d780 <FCVT_WU_D_TESTS+0x148>
   13aec:	fffff097          	auipc	ra,0xfffff
   13af0:	e64080e7          	jalr	-412(ra) # 12950 <printf_uart>
    for (size_t i = 0; i < FMUL_LENGTH; i++) {
   13af4:	fd843783          	ld	a5,-40(s0)
   13af8:	00178793          	addi	a5,a5,1
   13afc:	fcf43c23          	sd	a5,-40(s0)
   13b00:	10400793          	li	a5,260
   13b04:	fd843703          	ld	a4,-40(s0)
   13b08:	f4f760e3          	bltu	a4,a5,13a48 <test_fpu+0x130>
        }
    }
#endif

#ifdef ENABLE_FCVT_D_W_TESTS
    printf_uart("Testing %s\r\n", "DCVT_D_W");
   13b0c:	0001d7b7          	lui	a5,0x1d
   13b10:	79078593          	addi	a1,a5,1936 # 1d790 <FCVT_WU_D_TESTS+0x158>
   13b14:	0001d7b7          	lui	a5,0x1d
   13b18:	75878513          	addi	a0,a5,1880 # 1d758 <FCVT_WU_D_TESTS+0x120>
   13b1c:	fffff097          	auipc	ra,0xfffff
   13b20:	e34080e7          	jalr	-460(ra) # 12950 <printf_uart>
    for (size_t i = 0; i < FCVT_D_W_LENGTH; i++) {
   13b24:	fc043823          	sd	zero,-48(s0)
   13b28:	0b80006f          	j	13be0 <test_fpu+0x2c8>
        a.val = FCVT_D_W_TESTS[i].a;
   13b2c:	0001d6b7          	lui	a3,0x1d
   13b30:	fd043703          	ld	a4,-48(s0)
   13b34:	00070793          	mv	a5,a4
   13b38:	00179793          	slli	a5,a5,0x1
   13b3c:	00e787b3          	add	a5,a5,a4
   13b40:	00379793          	slli	a5,a5,0x3
   13b44:	3f868713          	addi	a4,a3,1016 # 1d3f8 <FCVT_D_W_TESTS>
   13b48:	00e787b3          	add	a5,a5,a4
   13b4c:	0007b783          	ld	a5,0(a5)
   13b50:	faf43023          	sd	a5,-96(s0)
        b.val = FCVT_D_W_TESTS[i].b;
   13b54:	0001d7b7          	lui	a5,0x1d
   13b58:	fd043703          	ld	a4,-48(s0)
   13b5c:	3f878693          	addi	a3,a5,1016 # 1d3f8 <FCVT_D_W_TESTS>
   13b60:	00070793          	mv	a5,a4
   13b64:	00179793          	slli	a5,a5,0x1
   13b68:	00e787b3          	add	a5,a5,a4
   13b6c:	00379793          	slli	a5,a5,0x3
   13b70:	00f687b3          	add	a5,a3,a5
   13b74:	0087b783          	ld	a5,8(a5)
   13b78:	f8f43c23          	sd	a5,-104(s0)
        res.f64 = (double)a.ibuf32[0];
   13b7c:	fa042783          	lw	a5,-96(s0)
   13b80:	d20787d3          	fcvt.d.w	fa5,a5
   13b84:	f8f43827          	fsd	fa5,-112(s0)
        if (res.val != FCVT_D_W_TESTS[i].res) {
   13b88:	f9043683          	ld	a3,-112(s0)
   13b8c:	0001d637          	lui	a2,0x1d
   13b90:	fd043703          	ld	a4,-48(s0)
   13b94:	00070793          	mv	a5,a4
   13b98:	00179793          	slli	a5,a5,0x1
   13b9c:	00e787b3          	add	a5,a5,a4
   13ba0:	00379793          	slli	a5,a5,0x3
   13ba4:	3f860713          	addi	a4,a2,1016 # 1d3f8 <FCVT_D_W_TESTS>
   13ba8:	00e787b3          	add	a5,a5,a4
   13bac:	0107b783          	ld	a5,16(a5)
   13bb0:	02f68263          	beq	a3,a5,13bd4 <test_fpu+0x2bc>
            err_cnt++;
   13bb4:	fec42783          	lw	a5,-20(s0)
   13bb8:	0017879b          	addiw	a5,a5,1
   13bbc:	fef42623          	sw	a5,-20(s0)
            printf_uart("DCVT_D_W[%d] fail\r\n", i);
   13bc0:	fd043583          	ld	a1,-48(s0)
   13bc4:	0001d7b7          	lui	a5,0x1d
   13bc8:	7a078513          	addi	a0,a5,1952 # 1d7a0 <FCVT_WU_D_TESTS+0x168>
   13bcc:	fffff097          	auipc	ra,0xfffff
   13bd0:	d84080e7          	jalr	-636(ra) # 12950 <printf_uart>
    for (size_t i = 0; i < FCVT_D_W_LENGTH; i++) {
   13bd4:	fd043783          	ld	a5,-48(s0)
   13bd8:	00178793          	addi	a5,a5,1
   13bdc:	fcf43823          	sd	a5,-48(s0)
   13be0:	00700793          	li	a5,7
   13be4:	fd043703          	ld	a4,-48(s0)
   13be8:	f4f762e3          	bltu	a4,a5,13b2c <test_fpu+0x214>
        }
    }
#endif

#ifdef ENABLE_FCVT_D_WU_TESTS
    printf_uart("Testing %s\r\n", "DCVT_D_WU");
   13bec:	0001d7b7          	lui	a5,0x1d
   13bf0:	7b878593          	addi	a1,a5,1976 # 1d7b8 <FCVT_WU_D_TESTS+0x180>
   13bf4:	0001d7b7          	lui	a5,0x1d
   13bf8:	75878513          	addi	a0,a5,1880 # 1d758 <FCVT_WU_D_TESTS+0x120>
   13bfc:	fffff097          	auipc	ra,0xfffff
   13c00:	d54080e7          	jalr	-684(ra) # 12950 <printf_uart>
    for (size_t i = 0; i < FCVT_D_WU_LENGTH; i++) {
   13c04:	fc043423          	sd	zero,-56(s0)
   13c08:	0b80006f          	j	13cc0 <test_fpu+0x3a8>
        a.val = FCVT_D_WU_TESTS[i].a;
   13c0c:	0001d6b7          	lui	a3,0x1d
   13c10:	fc843703          	ld	a4,-56(s0)
   13c14:	00070793          	mv	a5,a4
   13c18:	00179793          	slli	a5,a5,0x1
   13c1c:	00e787b3          	add	a5,a5,a4
   13c20:	00379793          	slli	a5,a5,0x3
   13c24:	4a068713          	addi	a4,a3,1184 # 1d4a0 <FCVT_D_WU_TESTS>
   13c28:	00e787b3          	add	a5,a5,a4
   13c2c:	0007b783          	ld	a5,0(a5)
   13c30:	faf43023          	sd	a5,-96(s0)
        b.val = FCVT_D_WU_TESTS[i].b;
   13c34:	0001d7b7          	lui	a5,0x1d
   13c38:	fc843703          	ld	a4,-56(s0)
   13c3c:	4a078693          	addi	a3,a5,1184 # 1d4a0 <FCVT_D_WU_TESTS>
   13c40:	00070793          	mv	a5,a4
   13c44:	00179793          	slli	a5,a5,0x1
   13c48:	00e787b3          	add	a5,a5,a4
   13c4c:	00379793          	slli	a5,a5,0x3
   13c50:	00f687b3          	add	a5,a3,a5
   13c54:	0087b783          	ld	a5,8(a5)
   13c58:	f8f43c23          	sd	a5,-104(s0)
        res.f64 = (double)a.buf32[0];
   13c5c:	fa042783          	lw	a5,-96(s0)
   13c60:	d21787d3          	fcvt.d.wu	fa5,a5
   13c64:	f8f43827          	fsd	fa5,-112(s0)
        if (res.val != FCVT_D_WU_TESTS[i].res) {
   13c68:	f9043683          	ld	a3,-112(s0)
   13c6c:	0001d637          	lui	a2,0x1d
   13c70:	fc843703          	ld	a4,-56(s0)
   13c74:	00070793          	mv	a5,a4
   13c78:	00179793          	slli	a5,a5,0x1
   13c7c:	00e787b3          	add	a5,a5,a4
   13c80:	00379793          	slli	a5,a5,0x3
   13c84:	4a060713          	addi	a4,a2,1184 # 1d4a0 <FCVT_D_WU_TESTS>
   13c88:	00e787b3          	add	a5,a5,a4
   13c8c:	0107b783          	ld	a5,16(a5)
   13c90:	02f68263          	beq	a3,a5,13cb4 <test_fpu+0x39c>
            err_cnt++;
   13c94:	fec42783          	lw	a5,-20(s0)
   13c98:	0017879b          	addiw	a5,a5,1
   13c9c:	fef42623          	sw	a5,-20(s0)
            printf_uart("DCVT_D_WU[%d] fail\r\n", i);
   13ca0:	fc843583          	ld	a1,-56(s0)
   13ca4:	0001d7b7          	lui	a5,0x1d
   13ca8:	7c878513          	addi	a0,a5,1992 # 1d7c8 <FCVT_WU_D_TESTS+0x190>
   13cac:	fffff097          	auipc	ra,0xfffff
   13cb0:	ca4080e7          	jalr	-860(ra) # 12950 <printf_uart>
    for (size_t i = 0; i < FCVT_D_WU_LENGTH; i++) {
   13cb4:	fc843783          	ld	a5,-56(s0)
   13cb8:	00178793          	addi	a5,a5,1
   13cbc:	fcf43423          	sd	a5,-56(s0)
   13cc0:	00700793          	li	a5,7
   13cc4:	fc843703          	ld	a4,-56(s0)
   13cc8:	f4f762e3          	bltu	a4,a5,13c0c <test_fpu+0x2f4>
        }
    }
#endif

#ifdef ENABLE_FCVT_W_D_TESTS
    printf_uart("Testing %s\r\n", "DCVT_W_D");
   13ccc:	0001d7b7          	lui	a5,0x1d
   13cd0:	7e078593          	addi	a1,a5,2016 # 1d7e0 <FCVT_WU_D_TESTS+0x1a8>
   13cd4:	0001d7b7          	lui	a5,0x1d
   13cd8:	75878513          	addi	a0,a5,1880 # 1d758 <FCVT_WU_D_TESTS+0x120>
   13cdc:	fffff097          	auipc	ra,0xfffff
   13ce0:	c74080e7          	jalr	-908(ra) # 12950 <printf_uart>
    for (size_t i = 0; i < FCVT_W_D_LENGTH; i++) {
   13ce4:	fc043023          	sd	zero,-64(s0)
   13ce8:	0bc0006f          	j	13da4 <test_fpu+0x48c>
        a.val = FCVT_W_D_TESTS[i].a;
   13cec:	0001d6b7          	lui	a3,0x1d
   13cf0:	fc043703          	ld	a4,-64(s0)
   13cf4:	00070793          	mv	a5,a4
   13cf8:	00179793          	slli	a5,a5,0x1
   13cfc:	00e787b3          	add	a5,a5,a4
   13d00:	00379793          	slli	a5,a5,0x3
   13d04:	54868713          	addi	a4,a3,1352 # 1d548 <FCVT_W_D_TESTS>
   13d08:	00e787b3          	add	a5,a5,a4
   13d0c:	0007b783          	ld	a5,0(a5)
   13d10:	faf43023          	sd	a5,-96(s0)
        b.val = FCVT_W_D_TESTS[i].b;
   13d14:	0001d7b7          	lui	a5,0x1d
   13d18:	fc043703          	ld	a4,-64(s0)
   13d1c:	54878693          	addi	a3,a5,1352 # 1d548 <FCVT_W_D_TESTS>
   13d20:	00070793          	mv	a5,a4
   13d24:	00179793          	slli	a5,a5,0x1
   13d28:	00e787b3          	add	a5,a5,a4
   13d2c:	00379793          	slli	a5,a5,0x3
   13d30:	00f687b3          	add	a5,a3,a5
   13d34:	0087b783          	ld	a5,8(a5)
   13d38:	f8f43c23          	sd	a5,-104(s0)
        res.ival = (int32_t)a.f64;
   13d3c:	fa043787          	fld	fa5,-96(s0)
   13d40:	c20797d3          	fcvt.w.d	a5,fa5,rtz
   13d44:	0007879b          	sext.w	a5,a5
   13d48:	f8f43823          	sd	a5,-112(s0)
        if (res.val != FCVT_W_D_TESTS[i].res) {
   13d4c:	f9043683          	ld	a3,-112(s0)
   13d50:	0001d637          	lui	a2,0x1d
   13d54:	fc043703          	ld	a4,-64(s0)
   13d58:	00070793          	mv	a5,a4
   13d5c:	00179793          	slli	a5,a5,0x1
   13d60:	00e787b3          	add	a5,a5,a4
   13d64:	00379793          	slli	a5,a5,0x3
   13d68:	54860713          	addi	a4,a2,1352 # 1d548 <FCVT_W_D_TESTS>
   13d6c:	00e787b3          	add	a5,a5,a4
   13d70:	0107b783          	ld	a5,16(a5)
   13d74:	02f68263          	beq	a3,a5,13d98 <test_fpu+0x480>
            err_cnt++;
   13d78:	fec42783          	lw	a5,-20(s0)
   13d7c:	0017879b          	addiw	a5,a5,1
   13d80:	fef42623          	sw	a5,-20(s0)
            printf_uart("DCVT_W_D[%d] fail\r\n", i);
   13d84:	fc043583          	ld	a1,-64(s0)
   13d88:	0001d7b7          	lui	a5,0x1d
   13d8c:	7f078513          	addi	a0,a5,2032 # 1d7f0 <FCVT_WU_D_TESTS+0x1b8>
   13d90:	fffff097          	auipc	ra,0xfffff
   13d94:	bc0080e7          	jalr	-1088(ra) # 12950 <printf_uart>
    for (size_t i = 0; i < FCVT_W_D_LENGTH; i++) {
   13d98:	fc043783          	ld	a5,-64(s0)
   13d9c:	00178793          	addi	a5,a5,1
   13da0:	fcf43023          	sd	a5,-64(s0)
   13da4:	00a00793          	li	a5,10
   13da8:	fc043703          	ld	a4,-64(s0)
   13dac:	f4f760e3          	bltu	a4,a5,13cec <test_fpu+0x3d4>
        }
    }
#endif

#ifdef ENABLE_FCVT_WU_D_TESTS
    printf_uart("Testing %s\r\n", "DCVT_WU_D");
   13db0:	0001e7b7          	lui	a5,0x1e
   13db4:	80878593          	addi	a1,a5,-2040 # 1d808 <FCVT_WU_D_TESTS+0x1d0>
   13db8:	0001d7b7          	lui	a5,0x1d
   13dbc:	75878513          	addi	a0,a5,1880 # 1d758 <FCVT_WU_D_TESTS+0x120>
   13dc0:	fffff097          	auipc	ra,0xfffff
   13dc4:	b90080e7          	jalr	-1136(ra) # 12950 <printf_uart>
    for (size_t i = 0; i < FCVT_WU_D_LENGTH; i++) {
   13dc8:	fa043c23          	sd	zero,-72(s0)
   13dcc:	0c40006f          	j	13e90 <test_fpu+0x578>
        a.val = FCVT_WU_D_TESTS[i].a;
   13dd0:	0001d6b7          	lui	a3,0x1d
   13dd4:	fb843703          	ld	a4,-72(s0)
   13dd8:	00070793          	mv	a5,a4
   13ddc:	00179793          	slli	a5,a5,0x1
   13de0:	00e787b3          	add	a5,a5,a4
   13de4:	00379793          	slli	a5,a5,0x3
   13de8:	63868713          	addi	a4,a3,1592 # 1d638 <FCVT_WU_D_TESTS>
   13dec:	00e787b3          	add	a5,a5,a4
   13df0:	0007b783          	ld	a5,0(a5)
   13df4:	faf43023          	sd	a5,-96(s0)
        b.val = FCVT_WU_D_TESTS[i].b;
   13df8:	0001d7b7          	lui	a5,0x1d
   13dfc:	fb843703          	ld	a4,-72(s0)
   13e00:	63878693          	addi	a3,a5,1592 # 1d638 <FCVT_WU_D_TESTS>
   13e04:	00070793          	mv	a5,a4
   13e08:	00179793          	slli	a5,a5,0x1
   13e0c:	00e787b3          	add	a5,a5,a4
   13e10:	00379793          	slli	a5,a5,0x3
   13e14:	00f687b3          	add	a5,a3,a5
   13e18:	0087b783          	ld	a5,8(a5)
   13e1c:	f8f43c23          	sd	a5,-104(s0)
        res.val = (uint32_t)a.f64;
   13e20:	fa043787          	fld	fa5,-96(s0)
   13e24:	c21797d3          	fcvt.wu.d	a5,fa5,rtz
   13e28:	0007879b          	sext.w	a5,a5
   13e2c:	02079793          	slli	a5,a5,0x20
   13e30:	0207d793          	srli	a5,a5,0x20
   13e34:	f8f43823          	sd	a5,-112(s0)
        if (res.val != FCVT_WU_D_TESTS[i].res) {
   13e38:	f9043683          	ld	a3,-112(s0)
   13e3c:	0001d637          	lui	a2,0x1d
   13e40:	fb843703          	ld	a4,-72(s0)
   13e44:	00070793          	mv	a5,a4
   13e48:	00179793          	slli	a5,a5,0x1
   13e4c:	00e787b3          	add	a5,a5,a4
   13e50:	00379793          	slli	a5,a5,0x3
   13e54:	63860713          	addi	a4,a2,1592 # 1d638 <FCVT_WU_D_TESTS>
   13e58:	00e787b3          	add	a5,a5,a4
   13e5c:	0107b783          	ld	a5,16(a5)
   13e60:	02f68263          	beq	a3,a5,13e84 <test_fpu+0x56c>
            err_cnt++;
   13e64:	fec42783          	lw	a5,-20(s0)
   13e68:	0017879b          	addiw	a5,a5,1
   13e6c:	fef42623          	sw	a5,-20(s0)
            printf_uart("DCVT_WU_D[%d] fail\r\n", i);
   13e70:	fb843583          	ld	a1,-72(s0)
   13e74:	0001e7b7          	lui	a5,0x1e
   13e78:	81878513          	addi	a0,a5,-2024 # 1d818 <FCVT_WU_D_TESTS+0x1e0>
   13e7c:	fffff097          	auipc	ra,0xfffff
   13e80:	ad4080e7          	jalr	-1324(ra) # 12950 <printf_uart>
    for (size_t i = 0; i < FCVT_WU_D_LENGTH; i++) {
   13e84:	fb843783          	ld	a5,-72(s0)
   13e88:	00178793          	addi	a5,a5,1
   13e8c:	faf43c23          	sd	a5,-72(s0)
   13e90:	00a00793          	li	a5,10
   13e94:	fb843703          	ld	a4,-72(s0)
   13e98:	f2f76ce3          	bltu	a4,a5,13dd0 <test_fpu+0x4b8>
        }
    }
#endif

    a.f64 = 10.323;
   13e9c:	0001e7b7          	lui	a5,0x1e
   13ea0:	8c87b787          	fld	fa5,-1848(a5) # 1d8c8 <FCVT_WU_D_TESTS+0x290>
   13ea4:	faf43027          	fsd	fa5,-96(s0)
    b.f64 = -5.3333;
   13ea8:	0001e7b7          	lui	a5,0x1e
   13eac:	8d07b787          	fld	fa5,-1840(a5) # 1d8d0 <FCVT_WU_D_TESTS+0x298>
   13eb0:	f8f43c27          	fsd	fa5,-104(s0)

    ix3 = -55;
   13eb4:	fc900793          	li	a5,-55
   13eb8:	faf43823          	sd	a5,-80(s0)
    res.f64 = (double)ix3;
   13ebc:	fb043783          	ld	a5,-80(s0)
   13ec0:	d227f7d3          	fcvt.d.l	fa5,a5
   13ec4:	f8f43827          	fsd	fa5,-112(s0)
    if (res.f64 != -55.0) {
   13ec8:	f9043707          	fld	fa4,-112(s0)
   13ecc:	0001e7b7          	lui	a5,0x1e
   13ed0:	8d87b787          	fld	fa5,-1832(a5) # 1d8d8 <FCVT_WU_D_TESTS+0x2a0>
   13ed4:	a2f727d3          	feq.d	a5,fa4,fa5
   13ed8:	02079463          	bnez	a5,13f00 <test_fpu+0x5e8>
        err_cnt++;
   13edc:	fec42783          	lw	a5,-20(s0)
   13ee0:	0017879b          	addiw	a5,a5,1
   13ee4:	fef42623          	sw	a5,-20(s0)
        printf_uart("%s fail\r\n", "DCVT_D_L");
   13ee8:	0001e7b7          	lui	a5,0x1e
   13eec:	83078593          	addi	a1,a5,-2000 # 1d830 <FCVT_WU_D_TESTS+0x1f8>
   13ef0:	0001e7b7          	lui	a5,0x1e
   13ef4:	84078513          	addi	a0,a5,-1984 # 1d840 <FCVT_WU_D_TESTS+0x208>
   13ef8:	fffff097          	auipc	ra,0xfffff
   13efc:	a58080e7          	jalr	-1448(ra) # 12950 <printf_uart>
    }

    ux3 = 75;
   13f00:	04b00793          	li	a5,75
   13f04:	faf43423          	sd	a5,-88(s0)
    res.f64 = (double)ux3;
   13f08:	fa843783          	ld	a5,-88(s0)
   13f0c:	d237f7d3          	fcvt.d.lu	fa5,a5
   13f10:	f8f43827          	fsd	fa5,-112(s0)
    if (res.f64 != 75.0) {
   13f14:	f9043707          	fld	fa4,-112(s0)
   13f18:	0001e7b7          	lui	a5,0x1e
   13f1c:	8e07b787          	fld	fa5,-1824(a5) # 1d8e0 <FCVT_WU_D_TESTS+0x2a8>
   13f20:	a2f727d3          	feq.d	a5,fa4,fa5
   13f24:	02079463          	bnez	a5,13f4c <test_fpu+0x634>
        err_cnt++;
   13f28:	fec42783          	lw	a5,-20(s0)
   13f2c:	0017879b          	addiw	a5,a5,1
   13f30:	fef42623          	sw	a5,-20(s0)
        printf_uart("%s fail\r\n", "DCVT_D_LU");
   13f34:	0001e7b7          	lui	a5,0x1e
   13f38:	85078593          	addi	a1,a5,-1968 # 1d850 <FCVT_WU_D_TESTS+0x218>
   13f3c:	0001e7b7          	lui	a5,0x1e
   13f40:	84078513          	addi	a0,a5,-1984 # 1d840 <FCVT_WU_D_TESTS+0x208>
   13f44:	fffff097          	auipc	ra,0xfffff
   13f48:	a0c080e7          	jalr	-1524(ra) # 12950 <printf_uart>
    }

    res.ival = (int64_t)b.f64;
   13f4c:	f9843787          	fld	fa5,-104(s0)
   13f50:	c22797d3          	fcvt.l.d	a5,fa5,rtz
   13f54:	f8f43823          	sd	a5,-112(s0)
    if (res.ival != (int64_t)(-5.3333)) {
   13f58:	f9043703          	ld	a4,-112(s0)
   13f5c:	ffb00793          	li	a5,-5
   13f60:	02f70463          	beq	a4,a5,13f88 <test_fpu+0x670>
        err_cnt++;
   13f64:	fec42783          	lw	a5,-20(s0)
   13f68:	0017879b          	addiw	a5,a5,1
   13f6c:	fef42623          	sw	a5,-20(s0)
        printf_uart("%s fail\r\n", "DCVT_L_D");
   13f70:	0001e7b7          	lui	a5,0x1e
   13f74:	86078593          	addi	a1,a5,-1952 # 1d860 <FCVT_WU_D_TESTS+0x228>
   13f78:	0001e7b7          	lui	a5,0x1e
   13f7c:	84078513          	addi	a0,a5,-1984 # 1d840 <FCVT_WU_D_TESTS+0x208>
   13f80:	fffff097          	auipc	ra,0xfffff
   13f84:	9d0080e7          	jalr	-1584(ra) # 12950 <printf_uart>

    /** Warning: conversion of negative double to unsigned integer
                 is undefined (C99/C11 6.3.1.4) and result is target dependable.
                 Hardware FPU is oriented on x86 implementation
    */
    res.val = (uint64_t)((int64_t)b.f64);
   13f88:	f9843787          	fld	fa5,-104(s0)
   13f8c:	c22797d3          	fcvt.l.d	a5,fa5,rtz
   13f90:	f8f43823          	sd	a5,-112(s0)
    if (res.val != (uint64_t)((int64_t)(-5.3333))) {
   13f94:	f9043703          	ld	a4,-112(s0)
   13f98:	ffb00793          	li	a5,-5
   13f9c:	02f70463          	beq	a4,a5,13fc4 <test_fpu+0x6ac>
        err_cnt++;
   13fa0:	fec42783          	lw	a5,-20(s0)
   13fa4:	0017879b          	addiw	a5,a5,1
   13fa8:	fef42623          	sw	a5,-20(s0)
        printf_uart("%s fail\r\n", "DCVT_LU_D");
   13fac:	0001e7b7          	lui	a5,0x1e
   13fb0:	87078593          	addi	a1,a5,-1936 # 1d870 <FCVT_WU_D_TESTS+0x238>
   13fb4:	0001e7b7          	lui	a5,0x1e
   13fb8:	84078513          	addi	a0,a5,-1984 # 1d840 <FCVT_WU_D_TESTS+0x208>
   13fbc:	fffff097          	auipc	ra,0xfffff
   13fc0:	994080e7          	jalr	-1644(ra) # 12950 <printf_uart>
    }

    res.f64 = a.f64 * b.f64;
   13fc4:	fa043707          	fld	fa4,-96(s0)
   13fc8:	f9843787          	fld	fa5,-104(s0)
   13fcc:	12f777d3          	fmul.d	fa5,fa4,fa5
   13fd0:	f8f43827          	fsd	fa5,-112(s0)
    if (res.f64 != (10.323 * -5.3333)) {
   13fd4:	f9043707          	fld	fa4,-112(s0)
   13fd8:	0001e7b7          	lui	a5,0x1e
   13fdc:	8e87b787          	fld	fa5,-1816(a5) # 1d8e8 <FCVT_WU_D_TESTS+0x2b0>
   13fe0:	a2f727d3          	feq.d	a5,fa4,fa5
   13fe4:	02079463          	bnez	a5,1400c <test_fpu+0x6f4>
        err_cnt++;
   13fe8:	fec42783          	lw	a5,-20(s0)
   13fec:	0017879b          	addiw	a5,a5,1
   13ff0:	fef42623          	sw	a5,-20(s0)
        printf_uart("%s fail\r\n", "DMUL");
   13ff4:	0001e7b7          	lui	a5,0x1e
   13ff8:	88078593          	addi	a1,a5,-1920 # 1d880 <FCVT_WU_D_TESTS+0x248>
   13ffc:	0001e7b7          	lui	a5,0x1e
   14000:	84078513          	addi	a0,a5,-1984 # 1d840 <FCVT_WU_D_TESTS+0x208>
   14004:	fffff097          	auipc	ra,0xfffff
   14008:	94c080e7          	jalr	-1716(ra) # 12950 <printf_uart>
    }

    res.f64 = a.f64 / b.f64;
   1400c:	fa043707          	fld	fa4,-96(s0)
   14010:	f9843787          	fld	fa5,-104(s0)
   14014:	1af777d3          	fdiv.d	fa5,fa4,fa5
   14018:	f8f43827          	fsd	fa5,-112(s0)
    if (res.f64 != (10.323 / -5.3333)) {
   1401c:	f9043707          	fld	fa4,-112(s0)
   14020:	0001e7b7          	lui	a5,0x1e
   14024:	8f07b787          	fld	fa5,-1808(a5) # 1d8f0 <FCVT_WU_D_TESTS+0x2b8>
   14028:	a2f727d3          	feq.d	a5,fa4,fa5
   1402c:	02079463          	bnez	a5,14054 <test_fpu+0x73c>
        err_cnt++;
   14030:	fec42783          	lw	a5,-20(s0)
   14034:	0017879b          	addiw	a5,a5,1
   14038:	fef42623          	sw	a5,-20(s0)
        printf_uart("%s fail\r\n", "DDIV");
   1403c:	0001e7b7          	lui	a5,0x1e
   14040:	88878593          	addi	a1,a5,-1912 # 1d888 <FCVT_WU_D_TESTS+0x250>
   14044:	0001e7b7          	lui	a5,0x1e
   14048:	84078513          	addi	a0,a5,-1984 # 1d840 <FCVT_WU_D_TESTS+0x208>
   1404c:	fffff097          	auipc	ra,0xfffff
   14050:	904080e7          	jalr	-1788(ra) # 12950 <printf_uart>
    }

    res.f64 = a.f64 + b.f64;
   14054:	fa043707          	fld	fa4,-96(s0)
   14058:	f9843787          	fld	fa5,-104(s0)
   1405c:	02f777d3          	fadd.d	fa5,fa4,fa5
   14060:	f8f43827          	fsd	fa5,-112(s0)
    // It supposed to work only with optimization -O0
    if (res.f64 != (10.323 - 5.3333)) {
   14064:	f9043707          	fld	fa4,-112(s0)
   14068:	0001e7b7          	lui	a5,0x1e
   1406c:	8f87b787          	fld	fa5,-1800(a5) # 1d8f8 <FCVT_WU_D_TESTS+0x2c0>
   14070:	a2f727d3          	feq.d	a5,fa4,fa5
   14074:	02079463          	bnez	a5,1409c <test_fpu+0x784>
        err_cnt++;
   14078:	fec42783          	lw	a5,-20(s0)
   1407c:	0017879b          	addiw	a5,a5,1
   14080:	fef42623          	sw	a5,-20(s0)
        printf_uart("%s fail\r\n", "DADD");
   14084:	0001e7b7          	lui	a5,0x1e
   14088:	89078593          	addi	a1,a5,-1904 # 1d890 <FCVT_WU_D_TESTS+0x258>
   1408c:	0001e7b7          	lui	a5,0x1e
   14090:	84078513          	addi	a0,a5,-1984 # 1d840 <FCVT_WU_D_TESTS+0x208>
   14094:	fffff097          	auipc	ra,0xfffff
   14098:	8bc080e7          	jalr	-1860(ra) # 12950 <printf_uart>
    }

    res.f64 = a.f64 - b.f64;
   1409c:	fa043707          	fld	fa4,-96(s0)
   140a0:	f9843787          	fld	fa5,-104(s0)
   140a4:	0af777d3          	fsub.d	fa5,fa4,fa5
   140a8:	f8f43827          	fsd	fa5,-112(s0)
    if (res.f64 != (10.323 + 5.3333)) {
   140ac:	f9043707          	fld	fa4,-112(s0)
   140b0:	0001e7b7          	lui	a5,0x1e
   140b4:	9007b787          	fld	fa5,-1792(a5) # 1d900 <FCVT_WU_D_TESTS+0x2c8>
   140b8:	a2f727d3          	feq.d	a5,fa4,fa5
   140bc:	02079463          	bnez	a5,140e4 <test_fpu+0x7cc>
        err_cnt++;
   140c0:	fec42783          	lw	a5,-20(s0)
   140c4:	0017879b          	addiw	a5,a5,1
   140c8:	fef42623          	sw	a5,-20(s0)
        printf_uart("%s fail\r\n", "DSUB");
   140cc:	0001e7b7          	lui	a5,0x1e
   140d0:	89878593          	addi	a1,a5,-1896 # 1d898 <FCVT_WU_D_TESTS+0x260>
   140d4:	0001e7b7          	lui	a5,0x1e
   140d8:	84078513          	addi	a0,a5,-1984 # 1d840 <FCVT_WU_D_TESTS+0x208>
   140dc:	fffff097          	auipc	ra,0xfffff
   140e0:	874080e7          	jalr	-1932(ra) # 12950 <printf_uart>
    }

    a.f64 = -17.1;
   140e4:	0001e7b7          	lui	a5,0x1e
   140e8:	9087b787          	fld	fa5,-1784(a5) # 1d908 <FCVT_WU_D_TESTS+0x2d0>
   140ec:	faf43027          	fsd	fa5,-96(s0)
    b.f64 = -17.05;
   140f0:	0001e7b7          	lui	a5,0x1e
   140f4:	9107b787          	fld	fa5,-1776(a5) # 1d910 <FCVT_WU_D_TESTS+0x2d8>
   140f8:	f8f43c27          	fsd	fa5,-104(s0)
    if (a.f64 >= b.f64) {
   140fc:	fa043707          	fld	fa4,-96(s0)
   14100:	f9843787          	fld	fa5,-104(s0)
   14104:	a2e787d3          	fle.d	a5,fa5,fa4
   14108:	02078263          	beqz	a5,1412c <test_fpu+0x814>
        err_cnt++;
   1410c:	fec42783          	lw	a5,-20(s0)
   14110:	0017879b          	addiw	a5,a5,1
   14114:	fef42623          	sw	a5,-20(s0)
        printf_uart("FCMP %d fail\r\n", 1);
   14118:	00100593          	li	a1,1
   1411c:	0001e7b7          	lui	a5,0x1e
   14120:	8a078513          	addi	a0,a5,-1888 # 1d8a0 <FCVT_WU_D_TESTS+0x268>
   14124:	fffff097          	auipc	ra,0xfffff
   14128:	82c080e7          	jalr	-2004(ra) # 12950 <printf_uart>
    }

    a.f64 = 17.1;
   1412c:	0001e7b7          	lui	a5,0x1e
   14130:	9187b787          	fld	fa5,-1768(a5) # 1d918 <FCVT_WU_D_TESTS+0x2e0>
   14134:	faf43027          	fsd	fa5,-96(s0)
    b.f64 = 17.05;
   14138:	0001e7b7          	lui	a5,0x1e
   1413c:	9207b787          	fld	fa5,-1760(a5) # 1d920 <FCVT_WU_D_TESTS+0x2e8>
   14140:	f8f43c27          	fsd	fa5,-104(s0)
    if (a.f64 < b.f64) {
   14144:	fa043707          	fld	fa4,-96(s0)
   14148:	f9843787          	fld	fa5,-104(s0)
   1414c:	a2f717d3          	flt.d	a5,fa4,fa5
   14150:	02078263          	beqz	a5,14174 <test_fpu+0x85c>
        err_cnt++;
   14154:	fec42783          	lw	a5,-20(s0)
   14158:	0017879b          	addiw	a5,a5,1
   1415c:	fef42623          	sw	a5,-20(s0)
        printf_uart("FCMP %d fail\r\n", 2);
   14160:	00200593          	li	a1,2
   14164:	0001e7b7          	lui	a5,0x1e
   14168:	8a078513          	addi	a0,a5,-1888 # 1d8a0 <FCVT_WU_D_TESTS+0x268>
   1416c:	ffffe097          	auipc	ra,0xffffe
   14170:	7e4080e7          	jalr	2020(ra) # 12950 <printf_uart>
    }

    a.f64 = -17.1;
   14174:	0001e7b7          	lui	a5,0x1e
   14178:	9087b787          	fld	fa5,-1784(a5) # 1d908 <FCVT_WU_D_TESTS+0x2d0>
   1417c:	faf43027          	fsd	fa5,-96(s0)
    b.f64 = 17.1;
   14180:	0001e7b7          	lui	a5,0x1e
   14184:	9187b787          	fld	fa5,-1768(a5) # 1d918 <FCVT_WU_D_TESTS+0x2e0>
   14188:	f8f43c27          	fsd	fa5,-104(s0)
    if (b.f64 <= a.f64) {
   1418c:	f9843707          	fld	fa4,-104(s0)
   14190:	fa043787          	fld	fa5,-96(s0)
   14194:	a2f707d3          	fle.d	a5,fa4,fa5
   14198:	02078263          	beqz	a5,141bc <test_fpu+0x8a4>
        err_cnt++;
   1419c:	fec42783          	lw	a5,-20(s0)
   141a0:	0017879b          	addiw	a5,a5,1
   141a4:	fef42623          	sw	a5,-20(s0)
        printf_uart("FCMP %d fail\r\n", 3);
   141a8:	00300593          	li	a1,3
   141ac:	0001e7b7          	lui	a5,0x1e
   141b0:	8a078513          	addi	a0,a5,-1888 # 1d8a0 <FCVT_WU_D_TESTS+0x268>
   141b4:	ffffe097          	auipc	ra,0xffffe
   141b8:	79c080e7          	jalr	1948(ra) # 12950 <printf_uart>
    }

    a.f64 = -17.1;
   141bc:	0001e7b7          	lui	a5,0x1e
   141c0:	9087b787          	fld	fa5,-1784(a5) # 1d908 <FCVT_WU_D_TESTS+0x2d0>
   141c4:	faf43027          	fsd	fa5,-96(s0)
    b.f64 = -17.1;
   141c8:	0001e7b7          	lui	a5,0x1e
   141cc:	9087b787          	fld	fa5,-1784(a5) # 1d908 <FCVT_WU_D_TESTS+0x2d0>
   141d0:	f8f43c27          	fsd	fa5,-104(s0)
    if (b.f64 != a.f64) {
   141d4:	f9843707          	fld	fa4,-104(s0)
   141d8:	fa043787          	fld	fa5,-96(s0)
   141dc:	a2f727d3          	feq.d	a5,fa4,fa5
   141e0:	02079263          	bnez	a5,14204 <test_fpu+0x8ec>
        err_cnt++;
   141e4:	fec42783          	lw	a5,-20(s0)
   141e8:	0017879b          	addiw	a5,a5,1
   141ec:	fef42623          	sw	a5,-20(s0)
        printf_uart("FCMP %d fail\r\n", 4);
   141f0:	00400593          	li	a1,4
   141f4:	0001e7b7          	lui	a5,0x1e
   141f8:	8a078513          	addi	a0,a5,-1888 # 1d8a0 <FCVT_WU_D_TESTS+0x268>
   141fc:	ffffe097          	auipc	ra,0xffffe
   14200:	754080e7          	jalr	1876(ra) # 12950 <printf_uart>
    }

    a.f64 = 17.1;
   14204:	0001e7b7          	lui	a5,0x1e
   14208:	9187b787          	fld	fa5,-1768(a5) # 1d918 <FCVT_WU_D_TESTS+0x2e0>
   1420c:	faf43027          	fsd	fa5,-96(s0)
    b.f64 = 17.1;
   14210:	0001e7b7          	lui	a5,0x1e
   14214:	9187b787          	fld	fa5,-1768(a5) # 1d918 <FCVT_WU_D_TESTS+0x2e0>
   14218:	f8f43c27          	fsd	fa5,-104(s0)
    if (b.f64 != a.f64) {
   1421c:	f9843707          	fld	fa4,-104(s0)
   14220:	fa043787          	fld	fa5,-96(s0)
   14224:	a2f727d3          	feq.d	a5,fa4,fa5
   14228:	02079263          	bnez	a5,1424c <test_fpu+0x934>
        err_cnt++;
   1422c:	fec42783          	lw	a5,-20(s0)
   14230:	0017879b          	addiw	a5,a5,1
   14234:	fef42623          	sw	a5,-20(s0)
        printf_uart("FCMP %d fail\r\n", 5);
   14238:	00500593          	li	a1,5
   1423c:	0001e7b7          	lui	a5,0x1e
   14240:	8a078513          	addi	a0,a5,-1888 # 1d8a0 <FCVT_WU_D_TESTS+0x268>
   14244:	ffffe097          	auipc	ra,0xffffe
   14248:	70c080e7          	jalr	1804(ra) # 12950 <printf_uart>
    }

    printf_uart("FPU errors . . .%d\r\n", err_cnt);
   1424c:	fec42783          	lw	a5,-20(s0)
   14250:	00078593          	mv	a1,a5
   14254:	0001e7b7          	lui	a5,0x1e
   14258:	8b078513          	addi	a0,a5,-1872 # 1d8b0 <FCVT_WU_D_TESTS+0x278>
   1425c:	ffffe097          	auipc	ra,0xffffe
   14260:	6f4080e7          	jalr	1780(ra) # 12950 <printf_uart>
}
   14264:	00000013          	nop
   14268:	06813083          	ld	ra,104(sp)
   1426c:	06013403          	ld	s0,96(sp)
   14270:	07010113          	addi	sp,sp,112
   14274:	00008067          	ret
   14278:	0000                	unimp
	...

000000000001427c <get_dev_bar>:
static uint64_t get_dev_bar(pnp_map *pnp, uint16_t vid, uint16_t did) {
   1427c:	fb010113          	addi	sp,sp,-80
   14280:	04813423          	sd	s0,72(sp)
   14284:	05010413          	addi	s0,sp,80
   14288:	faa43c23          	sd	a0,-72(s0)
   1428c:	00058793          	mv	a5,a1
   14290:	00060713          	mv	a4,a2
   14294:	faf41b23          	sh	a5,-74(s0)
   14298:	00070793          	mv	a5,a4
   1429c:	faf41a23          	sh	a5,-76(s0)
    int slots_total = (pnp->cfg >> 8) & 0xFF;
   142a0:	fb843783          	ld	a5,-72(s0)
   142a4:	0087a783          	lw	a5,8(a5)
   142a8:	0087d79b          	srliw	a5,a5,0x8
   142ac:	0007879b          	sext.w	a5,a5
   142b0:	0007879b          	sext.w	a5,a5
   142b4:	0ff7f793          	andi	a5,a5,255
   142b8:	fef42223          	sw	a5,-28(s0)
    int off = 0;
   142bc:	fe042623          	sw	zero,-20(s0)
    for (int i = 0; i < slots_total; i++) {
   142c0:	fe042423          	sw	zero,-24(s0)
   142c4:	09c0006f          	j	14360 <get_dev_bar+0xe4>
        dcfg = *(dev_cfg_type *)&pnp->cfg_table[off];
   142c8:	fec42783          	lw	a5,-20(s0)
   142cc:	04078793          	addi	a5,a5,64
   142d0:	fb843703          	ld	a4,-72(s0)
   142d4:	00f707b3          	add	a5,a4,a5
   142d8:	0007b703          	ld	a4,0(a5)
   142dc:	fce43023          	sd	a4,-64(s0)
   142e0:	0087b703          	ld	a4,8(a5)
   142e4:	fce43423          	sd	a4,-56(s0)
   142e8:	0107b703          	ld	a4,16(a5)
   142ec:	fce43823          	sd	a4,-48(s0)
   142f0:	0187b783          	ld	a5,24(a5)
   142f4:	fcf43c23          	sd	a5,-40(s0)
        off += sizeof(dcfg);
   142f8:	fec42783          	lw	a5,-20(s0)
   142fc:	0207879b          	addiw	a5,a5,32
   14300:	0007879b          	sext.w	a5,a5
   14304:	fef42623          	sw	a5,-20(s0)
        if (dcfg.u.descrtype != PNP_CFG_TYPE_SLAVE) {
   14308:	fc144783          	lbu	a5,-63(s0)
   1430c:	0037f793          	andi	a5,a5,3
   14310:	0ff7f793          	andi	a5,a5,255
   14314:	00078713          	mv	a4,a5
   14318:	00200793          	li	a5,2
   1431c:	02f71a63          	bne	a4,a5,14350 <get_dev_bar+0xd4>
        if (dcfg.u.vid == vid && dcfg.u.did == did) {
   14320:	fc645783          	lhu	a5,-58(s0)
   14324:	fb645703          	lhu	a4,-74(s0)
   14328:	0007071b          	sext.w	a4,a4
   1432c:	0007879b          	sext.w	a5,a5
   14330:	02f71263          	bne	a4,a5,14354 <get_dev_bar+0xd8>
   14334:	fc445783          	lhu	a5,-60(s0)
   14338:	fb445703          	lhu	a4,-76(s0)
   1433c:	0007071b          	sext.w	a4,a4
   14340:	0007879b          	sext.w	a5,a5
   14344:	00f71863          	bne	a4,a5,14354 <get_dev_bar+0xd8>
            return dcfg.u.addr_start;
   14348:	fd043783          	ld	a5,-48(s0)
   1434c:	02c0006f          	j	14378 <get_dev_bar+0xfc>
            continue;
   14350:	00000013          	nop
    for (int i = 0; i < slots_total; i++) {
   14354:	fe842783          	lw	a5,-24(s0)
   14358:	0017879b          	addiw	a5,a5,1
   1435c:	fef42423          	sw	a5,-24(s0)
   14360:	fe842703          	lw	a4,-24(s0)
   14364:	fe442783          	lw	a5,-28(s0)
   14368:	0007071b          	sext.w	a4,a4
   1436c:	0007879b          	sext.w	a5,a5
   14370:	f4f74ce3          	blt	a4,a5,142c8 <get_dev_bar+0x4c>
    return DEV_NONE;
   14374:	fff00793          	li	a5,-1
}
   14378:	00078513          	mv	a0,a5
   1437c:	04813403          	ld	s0,72(sp)
   14380:	05010113          	addi	sp,sp,80
   14384:	00008067          	ret

0000000000014388 <mpu_region_total>:
static int mpu_region_total() {
   14388:	fe010113          	addi	sp,sp,-32
   1438c:	00813c23          	sd	s0,24(sp)
   14390:	02010413          	addi	s0,sp,32
    uint64_t val = 0;
   14394:	fe043423          	sd	zero,-24(s0)
    asm("csrr %0, 0xBC4" : "=r" (val));
   14398:	bc4027f3          	csrr	a5,0xbc4
   1439c:	fef43423          	sd	a5,-24(s0)
    return (int)(val >> 8);
   143a0:	fe843783          	ld	a5,-24(s0)
   143a4:	0087d793          	srli	a5,a5,0x8
   143a8:	0007879b          	sext.w	a5,a5
}
   143ac:	00078513          	mv	a0,a5
   143b0:	01813403          	ld	s0,24(sp)
   143b4:	02010113          	addi	sp,sp,32
   143b8:	00008067          	ret

00000000000143bc <mpu_disable_region>:
static void mpu_disable_region(int idx) {
   143bc:	fd010113          	addi	sp,sp,-48
   143c0:	02813423          	sd	s0,40(sp)
   143c4:	03010413          	addi	s0,sp,48
   143c8:	00050793          	mv	a5,a0
   143cc:	fcf42e23          	sw	a5,-36(s0)
    ctrl.value = 0;
   143d0:	fe043423          	sd	zero,-24(s0)
    ctrl.bits.IDX = idx;
   143d4:	fdc42783          	lw	a5,-36(s0)
   143d8:	0ff7f793          	andi	a5,a5,255
   143dc:	fef404a3          	sb	a5,-23(s0)
    ctrl.bits.WE = 1;
   143e0:	fe844783          	lbu	a5,-24(s0)
   143e4:	f807e793          	ori	a5,a5,-128
   143e8:	fef40423          	sb	a5,-24(s0)
    asm("csrw 0xBC4, %0" : :"r"(ctrl.value));
   143ec:	fe843783          	ld	a5,-24(s0)
   143f0:	bc479073          	csrw	0xbc4,a5
}
   143f4:	00000013          	nop
   143f8:	02813403          	ld	s0,40(sp)
   143fc:	03010113          	addi	sp,sp,48
   14400:	00008067          	ret

0000000000014404 <mpu_enable_region>:
                       const char *rwx) {
   14404:	fb010113          	addi	sp,sp,-80
   14408:	04813423          	sd	s0,72(sp)
   1440c:	05010413          	addi	s0,sp,80
   14410:	00050793          	mv	a5,a0
   14414:	fcb43023          	sd	a1,-64(s0)
   14418:	fac43c23          	sd	a2,-72(s0)
   1441c:	fae43823          	sd	a4,-80(s0)
   14420:	fcf42623          	sw	a5,-52(s0)
   14424:	00068793          	mv	a5,a3
   14428:	fcf42423          	sw	a5,-56(s0)
    uint64_t mask = (~0ull) << 10;
   1442c:	c0000793          	li	a5,-1024
   14430:	fef43423          	sd	a5,-24(s0)
    const char *p = rwx;
   14434:	fb043783          	ld	a5,-80(s0)
   14438:	fef43023          	sd	a5,-32(s0)
    asm("csrw 0xBC2, %0" : :"r"(bar));
   1443c:	fc043783          	ld	a5,-64(s0)
   14440:	bc279073          	csrw	0xbc2,a5
    KB >>= 1;
   14444:	fb843783          	ld	a5,-72(s0)
   14448:	0017d793          	srli	a5,a5,0x1
   1444c:	faf43c23          	sd	a5,-72(s0)
    while (KB) {
   14450:	01c0006f          	j	1446c <mpu_enable_region+0x68>
        mask <<= 1;
   14454:	fe843783          	ld	a5,-24(s0)
   14458:	00179793          	slli	a5,a5,0x1
   1445c:	fef43423          	sd	a5,-24(s0)
        KB >>= 1;
   14460:	fb843783          	ld	a5,-72(s0)
   14464:	0017d793          	srli	a5,a5,0x1
   14468:	faf43c23          	sd	a5,-72(s0)
    while (KB) {
   1446c:	fb843783          	ld	a5,-72(s0)
   14470:	fe0792e3          	bnez	a5,14454 <mpu_enable_region+0x50>
    asm("csrw 0xBC3, %0" : :"r"(mask));
   14474:	fe843783          	ld	a5,-24(s0)
   14478:	bc379073          	csrw	0xbc3,a5
    ctrl.value = 0;
   1447c:	fc043c23          	sd	zero,-40(s0)
    ctrl.bits.IDX = idx;
   14480:	fcc42783          	lw	a5,-52(s0)
   14484:	0ff7f793          	andi	a5,a5,255
   14488:	fcf40ca3          	sb	a5,-39(s0)
    ctrl.bits.ENA = 1;
   1448c:	fd844783          	lbu	a5,-40(s0)
   14490:	0107e793          	ori	a5,a5,16
   14494:	fcf40c23          	sb	a5,-40(s0)
    ctrl.bits.CACHABLE = cached;
   14498:	fc842783          	lw	a5,-56(s0)
   1449c:	0017f793          	andi	a5,a5,1
   144a0:	0ff7f793          	andi	a5,a5,255
   144a4:	0017f793          	andi	a5,a5,1
   144a8:	0037969b          	slliw	a3,a5,0x3
   144ac:	fd844783          	lbu	a5,-40(s0)
   144b0:	ff77f793          	andi	a5,a5,-9
   144b4:	00078713          	mv	a4,a5
   144b8:	00068793          	mv	a5,a3
   144bc:	00f767b3          	or	a5,a4,a5
   144c0:	fcf40c23          	sb	a5,-40(s0)
    ctrl.bits.WE = 1; // write into MPU
   144c4:	fd844783          	lbu	a5,-40(s0)
   144c8:	f807e793          	ori	a5,a5,-128
   144cc:	fcf40c23          	sb	a5,-40(s0)
    while (*p) {
   144d0:	0700006f          	j	14540 <mpu_enable_region+0x13c>
        if (*p == 'r') {
   144d4:	fe043783          	ld	a5,-32(s0)
   144d8:	0007c783          	lbu	a5,0(a5)
   144dc:	00078713          	mv	a4,a5
   144e0:	07200793          	li	a5,114
   144e4:	00f71863          	bne	a4,a5,144f4 <mpu_enable_region+0xf0>
            ctrl.bits.RD = 1;
   144e8:	fd844783          	lbu	a5,-40(s0)
   144ec:	0027e793          	ori	a5,a5,2
   144f0:	fcf40c23          	sb	a5,-40(s0)
        if (*p == 'w') {
   144f4:	fe043783          	ld	a5,-32(s0)
   144f8:	0007c783          	lbu	a5,0(a5)
   144fc:	00078713          	mv	a4,a5
   14500:	07700793          	li	a5,119
   14504:	00f71863          	bne	a4,a5,14514 <mpu_enable_region+0x110>
            ctrl.bits.WR = 1;
   14508:	fd844783          	lbu	a5,-40(s0)
   1450c:	0017e793          	ori	a5,a5,1
   14510:	fcf40c23          	sb	a5,-40(s0)
        if (*p == 'x') {
   14514:	fe043783          	ld	a5,-32(s0)
   14518:	0007c783          	lbu	a5,0(a5)
   1451c:	00078713          	mv	a4,a5
   14520:	07800793          	li	a5,120
   14524:	00f71863          	bne	a4,a5,14534 <mpu_enable_region+0x130>
            ctrl.bits.EXEC = 1;
   14528:	fd844783          	lbu	a5,-40(s0)
   1452c:	0047e793          	ori	a5,a5,4
   14530:	fcf40c23          	sb	a5,-40(s0)
        p++;
   14534:	fe043783          	ld	a5,-32(s0)
   14538:	00178793          	addi	a5,a5,1
   1453c:	fef43023          	sd	a5,-32(s0)
    while (*p) {
   14540:	fe043783          	ld	a5,-32(s0)
   14544:	0007c783          	lbu	a5,0(a5)
   14548:	f80796e3          	bnez	a5,144d4 <mpu_enable_region+0xd0>
    asm("csrw 0xBC4, %0" : :"r"(ctrl.value));
   1454c:	fd843783          	ld	a5,-40(s0)
   14550:	bc479073          	csrw	0xbc4,a5
}
   14554:	00000013          	nop
   14558:	04813403          	ld	s0,72(sp)
   1455c:	05010113          	addi	sp,sp,80
   14560:	00008067          	ret

0000000000014564 <test_missaccess>:
#include <axi_maps.h>
#include "fw_api.h"

static const uint64_t UNMAPPED_ADDRESS = 0x70000040;

void test_missaccess(void) {
   14564:	fe010113          	addi	sp,sp,-32
   14568:	00113c23          	sd	ra,24(sp)
   1456c:	00813823          	sd	s0,16(sp)
   14570:	02010413          	addi	s0,sp,32
    pnp_map *pnp = (pnp_map *)ADDR_BUS0_XSLV_PNP;
   14574:	100ff7b7          	lui	a5,0x100ff
   14578:	fef43423          	sd	a5,-24(s0)

    // jump to unmappedregion and execute instruction
    pnp->fwdbg1 = (uint64_t)&&ret_from_exception;  // gcc extension
   1457c:	000147b7          	lui	a5,0x14
   14580:	59478713          	addi	a4,a5,1428 # 14594 <test_missaccess+0x30>
   14584:	fe843783          	ld	a5,-24(s0)
   14588:	02e7b423          	sd	a4,40(a5)

    asm("li t0,0x70000000");
   1458c:	700002b7          	lui	t0,0x70000
    asm("jalr x0,0(t0)");
   14590:	00028067          	jr	t0
ret_from_exception:
    printf_uart("%s", "instr_load_err .");
   14594:	0001e7b7          	lui	a5,0x1e
   14598:	92878593          	addi	a1,a5,-1752 # 1d928 <FCVT_WU_D_TESTS+0x2f0>
   1459c:	0001e7b7          	lui	a5,0x1e
   145a0:	94078513          	addi	a0,a5,-1728 # 1d940 <FCVT_WU_D_TESTS+0x308>
   145a4:	ffffe097          	auipc	ra,0xffffe
   145a8:	3ac080e7          	jalr	940(ra) # 12950 <printf_uart>
    if (pnp->fwdbg1 != 0x70000000ull) {
   145ac:	fe843783          	ld	a5,-24(s0)
   145b0:	0287b703          	ld	a4,40(a5)
   145b4:	700007b7          	lui	a5,0x70000
   145b8:	02f70463          	beq	a4,a5,145e0 <test_missaccess+0x7c>
        printf_uart("FAIL: %08x != %08x\r\n",
   145bc:	fe843783          	ld	a5,-24(s0)
   145c0:	0287b783          	ld	a5,40(a5) # 70000028 <_end+0x6ffe078c>
   145c4:	70000637          	lui	a2,0x70000
   145c8:	00078593          	mv	a1,a5
   145cc:	0001e7b7          	lui	a5,0x1e
   145d0:	94878513          	addi	a0,a5,-1720 # 1d948 <FCVT_WU_D_TESTS+0x310>
   145d4:	ffffe097          	auipc	ra,0xffffe
   145d8:	37c080e7          	jalr	892(ra) # 12950 <printf_uart>
   145dc:	01c0006f          	j	145f8 <test_missaccess+0x94>
                    pnp->fwdbg1, 0x70000000ull);
    } else {
        printf_uart("%s", "PASS\r\n");
   145e0:	0001e7b7          	lui	a5,0x1e
   145e4:	96078593          	addi	a1,a5,-1696 # 1d960 <FCVT_WU_D_TESTS+0x328>
   145e8:	0001e7b7          	lui	a5,0x1e
   145ec:	94078513          	addi	a0,a5,-1728 # 1d940 <FCVT_WU_D_TESTS+0x308>
   145f0:	ffffe097          	auipc	ra,0xffffe
   145f4:	360080e7          	jalr	864(ra) # 12950 <printf_uart>
    }


    // clear register. it should be modified from exception handler
    pnp->fwdbg1 = 0;
   145f8:	fe843783          	ld	a5,-24(s0)
   145fc:	0207b423          	sd	zero,40(a5)

    // Read unmapped address to some register (to avoid optimization)
    pnp->idt = *((uint64_t *)UNMAPPED_ADDRESS);
   14600:	700007b7          	lui	a5,0x70000
   14604:	04078793          	addi	a5,a5,64 # 70000040 <_end+0x6ffe07a4>
   14608:	0007b703          	ld	a4,0(a5)
   1460c:	fe843783          	ld	a5,-24(s0)
   14610:	00e7b823          	sd	a4,16(a5)

    if (pnp->fwdbg1 != UNMAPPED_ADDRESS) {
   14614:	fe843783          	ld	a5,-24(s0)
   14618:	0287b703          	ld	a4,40(a5)
   1461c:	700007b7          	lui	a5,0x70000
   14620:	04078793          	addi	a5,a5,64 # 70000040 <_end+0x6ffe07a4>
   14624:	02f70863          	beq	a4,a5,14654 <test_missaccess+0xf0>
        printf_uart("rd_missaccess. .FAIL: %08x != %08x\r\n",
   14628:	fe843783          	ld	a5,-24(s0)
   1462c:	0287b703          	ld	a4,40(a5)
   14630:	700007b7          	lui	a5,0x70000
   14634:	04078793          	addi	a5,a5,64 # 70000040 <_end+0x6ffe07a4>
   14638:	00078613          	mv	a2,a5
   1463c:	00070593          	mv	a1,a4
   14640:	0001e7b7          	lui	a5,0x1e
   14644:	96878513          	addi	a0,a5,-1688 # 1d968 <FCVT_WU_D_TESTS+0x330>
   14648:	ffffe097          	auipc	ra,0xffffe
   1464c:	308080e7          	jalr	776(ra) # 12950 <printf_uart>
   14650:	01c0006f          	j	1466c <test_missaccess+0x108>
                    pnp->fwdbg1, UNMAPPED_ADDRESS);
    } else {
        printf_uart("%s", "rd_missaccess. .PASS\r\n");
   14654:	0001e7b7          	lui	a5,0x1e
   14658:	99078593          	addi	a1,a5,-1648 # 1d990 <FCVT_WU_D_TESTS+0x358>
   1465c:	0001e7b7          	lui	a5,0x1e
   14660:	94078513          	addi	a0,a5,-1728 # 1d940 <FCVT_WU_D_TESTS+0x308>
   14664:	ffffe097          	auipc	ra,0xffffe
   14668:	2ec080e7          	jalr	748(ra) # 12950 <printf_uart>
    }

    // Test write miss access
    pnp->fwdbg1 = 0;
   1466c:	fe843783          	ld	a5,-24(s0)
   14670:	0207b423          	sd	zero,40(a5)
    *((uint64_t *)(UNMAPPED_ADDRESS + 8)) = 0x33445566;
   14674:	700007b7          	lui	a5,0x70000
   14678:	04078793          	addi	a5,a5,64 # 70000040 <_end+0x6ffe07a4>
   1467c:	00878793          	addi	a5,a5,8
   14680:	00078713          	mv	a4,a5
   14684:	334457b7          	lui	a5,0x33445
   14688:	56678793          	addi	a5,a5,1382 # 33445566 <_end+0x33425cca>
   1468c:	00f73023          	sd	a5,0(a4)

    // Pipeline can execute up to 2 instructions before store_fault
    // exception will be generated, so insert before reading fwdbg1 some logic.
    printf_uart("%s", "wr_missaccess. .");
   14690:	0001e7b7          	lui	a5,0x1e
   14694:	9a878593          	addi	a1,a5,-1624 # 1d9a8 <FCVT_WU_D_TESTS+0x370>
   14698:	0001e7b7          	lui	a5,0x1e
   1469c:	94078513          	addi	a0,a5,-1728 # 1d940 <FCVT_WU_D_TESTS+0x308>
   146a0:	ffffe097          	auipc	ra,0xffffe
   146a4:	2b0080e7          	jalr	688(ra) # 12950 <printf_uart>
    if (pnp->fwdbg1 != (UNMAPPED_ADDRESS+8)) {
   146a8:	fe843783          	ld	a5,-24(s0)
   146ac:	0287b703          	ld	a4,40(a5)
   146b0:	700007b7          	lui	a5,0x70000
   146b4:	04078793          	addi	a5,a5,64 # 70000040 <_end+0x6ffe07a4>
   146b8:	00878793          	addi	a5,a5,8
   146bc:	02f70a63          	beq	a4,a5,146f0 <test_missaccess+0x18c>
        printf_uart("FAIL: %08x != %08x\r\n",
   146c0:	fe843783          	ld	a5,-24(s0)
   146c4:	0287b703          	ld	a4,40(a5)
   146c8:	700007b7          	lui	a5,0x70000
   146cc:	04078793          	addi	a5,a5,64 # 70000040 <_end+0x6ffe07a4>
   146d0:	00878793          	addi	a5,a5,8
   146d4:	00078613          	mv	a2,a5
   146d8:	00070593          	mv	a1,a4
   146dc:	0001e7b7          	lui	a5,0x1e
   146e0:	94878513          	addi	a0,a5,-1720 # 1d948 <FCVT_WU_D_TESTS+0x310>
   146e4:	ffffe097          	auipc	ra,0xffffe
   146e8:	26c080e7          	jalr	620(ra) # 12950 <printf_uart>
                    pnp->fwdbg1, (UNMAPPED_ADDRESS+8));
    } else {
        printf_uart("%s", "PASS\r\n");
    }
}
   146ec:	01c0006f          	j	14708 <test_missaccess+0x1a4>
        printf_uart("%s", "PASS\r\n");
   146f0:	0001e7b7          	lui	a5,0x1e
   146f4:	96078593          	addi	a1,a5,-1696 # 1d960 <FCVT_WU_D_TESTS+0x328>
   146f8:	0001e7b7          	lui	a5,0x1e
   146fc:	94078513          	addi	a0,a5,-1728 # 1d940 <FCVT_WU_D_TESTS+0x308>
   14700:	ffffe097          	auipc	ra,0xffffe
   14704:	250080e7          	jalr	592(ra) # 12950 <printf_uart>
}
   14708:	00000013          	nop
   1470c:	01813083          	ld	ra,24(sp)
   14710:	01013403          	ld	s0,16(sp)
   14714:	02010113          	addi	sp,sp,32
   14718:	00008067          	ret
   1471c:	0000                	unimp
	...

0000000000014720 <get_dev_bar>:
static uint64_t get_dev_bar(pnp_map *pnp, uint16_t vid, uint16_t did) {
   14720:	fb010113          	addi	sp,sp,-80
   14724:	04813423          	sd	s0,72(sp)
   14728:	05010413          	addi	s0,sp,80
   1472c:	faa43c23          	sd	a0,-72(s0)
   14730:	00058793          	mv	a5,a1
   14734:	00060713          	mv	a4,a2
   14738:	faf41b23          	sh	a5,-74(s0)
   1473c:	00070793          	mv	a5,a4
   14740:	faf41a23          	sh	a5,-76(s0)
    int slots_total = (pnp->cfg >> 8) & 0xFF;
   14744:	fb843783          	ld	a5,-72(s0)
   14748:	0087a783          	lw	a5,8(a5)
   1474c:	0087d79b          	srliw	a5,a5,0x8
   14750:	0007879b          	sext.w	a5,a5
   14754:	0007879b          	sext.w	a5,a5
   14758:	0ff7f793          	andi	a5,a5,255
   1475c:	fef42223          	sw	a5,-28(s0)
    int off = 0;
   14760:	fe042623          	sw	zero,-20(s0)
    for (int i = 0; i < slots_total; i++) {
   14764:	fe042423          	sw	zero,-24(s0)
   14768:	09c0006f          	j	14804 <get_dev_bar+0xe4>
        dcfg = *(dev_cfg_type *)&pnp->cfg_table[off];
   1476c:	fec42783          	lw	a5,-20(s0)
   14770:	04078793          	addi	a5,a5,64
   14774:	fb843703          	ld	a4,-72(s0)
   14778:	00f707b3          	add	a5,a4,a5
   1477c:	0007b703          	ld	a4,0(a5)
   14780:	fce43023          	sd	a4,-64(s0)
   14784:	0087b703          	ld	a4,8(a5)
   14788:	fce43423          	sd	a4,-56(s0)
   1478c:	0107b703          	ld	a4,16(a5)
   14790:	fce43823          	sd	a4,-48(s0)
   14794:	0187b783          	ld	a5,24(a5)
   14798:	fcf43c23          	sd	a5,-40(s0)
        off += sizeof(dcfg);
   1479c:	fec42783          	lw	a5,-20(s0)
   147a0:	0207879b          	addiw	a5,a5,32
   147a4:	0007879b          	sext.w	a5,a5
   147a8:	fef42623          	sw	a5,-20(s0)
        if (dcfg.u.descrtype != PNP_CFG_TYPE_SLAVE) {
   147ac:	fc144783          	lbu	a5,-63(s0)
   147b0:	0037f793          	andi	a5,a5,3
   147b4:	0ff7f793          	andi	a5,a5,255
   147b8:	00078713          	mv	a4,a5
   147bc:	00200793          	li	a5,2
   147c0:	02f71a63          	bne	a4,a5,147f4 <get_dev_bar+0xd4>
        if (dcfg.u.vid == vid && dcfg.u.did == did) {
   147c4:	fc645783          	lhu	a5,-58(s0)
   147c8:	fb645703          	lhu	a4,-74(s0)
   147cc:	0007071b          	sext.w	a4,a4
   147d0:	0007879b          	sext.w	a5,a5
   147d4:	02f71263          	bne	a4,a5,147f8 <get_dev_bar+0xd8>
   147d8:	fc445783          	lhu	a5,-60(s0)
   147dc:	fb445703          	lhu	a4,-76(s0)
   147e0:	0007071b          	sext.w	a4,a4
   147e4:	0007879b          	sext.w	a5,a5
   147e8:	00f71863          	bne	a4,a5,147f8 <get_dev_bar+0xd8>
            return dcfg.u.addr_start;
   147ec:	fd043783          	ld	a5,-48(s0)
   147f0:	02c0006f          	j	1481c <get_dev_bar+0xfc>
            continue;
   147f4:	00000013          	nop
    for (int i = 0; i < slots_total; i++) {
   147f8:	fe842783          	lw	a5,-24(s0)
   147fc:	0017879b          	addiw	a5,a5,1
   14800:	fef42423          	sw	a5,-24(s0)
   14804:	fe842703          	lw	a4,-24(s0)
   14808:	fe442783          	lw	a5,-28(s0)
   1480c:	0007071b          	sext.w	a4,a4
   14810:	0007879b          	sext.w	a5,a5
   14814:	f4f74ce3          	blt	a4,a5,1476c <get_dev_bar+0x4c>
    return DEV_NONE;
   14818:	fff00793          	li	a5,-1
}
   1481c:	00078513          	mv	a0,a5
   14820:	04813403          	ld	s0,72(sp)
   14824:	05010113          	addi	sp,sp,80
   14828:	00008067          	ret

000000000001482c <mpu_region_total>:
static int mpu_region_total() {
   1482c:	fe010113          	addi	sp,sp,-32
   14830:	00813c23          	sd	s0,24(sp)
   14834:	02010413          	addi	s0,sp,32
    uint64_t val = 0;
   14838:	fe043423          	sd	zero,-24(s0)
    asm("csrr %0, 0xBC4" : "=r" (val));
   1483c:	bc4027f3          	csrr	a5,0xbc4
   14840:	fef43423          	sd	a5,-24(s0)
    return (int)(val >> 8);
   14844:	fe843783          	ld	a5,-24(s0)
   14848:	0087d793          	srli	a5,a5,0x8
   1484c:	0007879b          	sext.w	a5,a5
}
   14850:	00078513          	mv	a0,a5
   14854:	01813403          	ld	s0,24(sp)
   14858:	02010113          	addi	sp,sp,32
   1485c:	00008067          	ret

0000000000014860 <mpu_disable_region>:
static void mpu_disable_region(int idx) {
   14860:	fd010113          	addi	sp,sp,-48
   14864:	02813423          	sd	s0,40(sp)
   14868:	03010413          	addi	s0,sp,48
   1486c:	00050793          	mv	a5,a0
   14870:	fcf42e23          	sw	a5,-36(s0)
    ctrl.value = 0;
   14874:	fe043423          	sd	zero,-24(s0)
    ctrl.bits.IDX = idx;
   14878:	fdc42783          	lw	a5,-36(s0)
   1487c:	0ff7f793          	andi	a5,a5,255
   14880:	fef404a3          	sb	a5,-23(s0)
    ctrl.bits.WE = 1;
   14884:	fe844783          	lbu	a5,-24(s0)
   14888:	f807e793          	ori	a5,a5,-128
   1488c:	fef40423          	sb	a5,-24(s0)
    asm("csrw 0xBC4, %0" : :"r"(ctrl.value));
   14890:	fe843783          	ld	a5,-24(s0)
   14894:	bc479073          	csrw	0xbc4,a5
}
   14898:	00000013          	nop
   1489c:	02813403          	ld	s0,40(sp)
   148a0:	03010113          	addi	sp,sp,48
   148a4:	00008067          	ret

00000000000148a8 <mpu_enable_region>:
                       const char *rwx) {
   148a8:	fb010113          	addi	sp,sp,-80
   148ac:	04813423          	sd	s0,72(sp)
   148b0:	05010413          	addi	s0,sp,80
   148b4:	00050793          	mv	a5,a0
   148b8:	fcb43023          	sd	a1,-64(s0)
   148bc:	fac43c23          	sd	a2,-72(s0)
   148c0:	fae43823          	sd	a4,-80(s0)
   148c4:	fcf42623          	sw	a5,-52(s0)
   148c8:	00068793          	mv	a5,a3
   148cc:	fcf42423          	sw	a5,-56(s0)
    uint64_t mask = (~0ull) << 10;
   148d0:	c0000793          	li	a5,-1024
   148d4:	fef43423          	sd	a5,-24(s0)
    const char *p = rwx;
   148d8:	fb043783          	ld	a5,-80(s0)
   148dc:	fef43023          	sd	a5,-32(s0)
    asm("csrw 0xBC2, %0" : :"r"(bar));
   148e0:	fc043783          	ld	a5,-64(s0)
   148e4:	bc279073          	csrw	0xbc2,a5
    KB >>= 1;
   148e8:	fb843783          	ld	a5,-72(s0)
   148ec:	0017d793          	srli	a5,a5,0x1
   148f0:	faf43c23          	sd	a5,-72(s0)
    while (KB) {
   148f4:	01c0006f          	j	14910 <mpu_enable_region+0x68>
        mask <<= 1;
   148f8:	fe843783          	ld	a5,-24(s0)
   148fc:	00179793          	slli	a5,a5,0x1
   14900:	fef43423          	sd	a5,-24(s0)
        KB >>= 1;
   14904:	fb843783          	ld	a5,-72(s0)
   14908:	0017d793          	srli	a5,a5,0x1
   1490c:	faf43c23          	sd	a5,-72(s0)
    while (KB) {
   14910:	fb843783          	ld	a5,-72(s0)
   14914:	fe0792e3          	bnez	a5,148f8 <mpu_enable_region+0x50>
    asm("csrw 0xBC3, %0" : :"r"(mask));
   14918:	fe843783          	ld	a5,-24(s0)
   1491c:	bc379073          	csrw	0xbc3,a5
    ctrl.value = 0;
   14920:	fc043c23          	sd	zero,-40(s0)
    ctrl.bits.IDX = idx;
   14924:	fcc42783          	lw	a5,-52(s0)
   14928:	0ff7f793          	andi	a5,a5,255
   1492c:	fcf40ca3          	sb	a5,-39(s0)
    ctrl.bits.ENA = 1;
   14930:	fd844783          	lbu	a5,-40(s0)
   14934:	0107e793          	ori	a5,a5,16
   14938:	fcf40c23          	sb	a5,-40(s0)
    ctrl.bits.CACHABLE = cached;
   1493c:	fc842783          	lw	a5,-56(s0)
   14940:	0017f793          	andi	a5,a5,1
   14944:	0ff7f793          	andi	a5,a5,255
   14948:	0017f793          	andi	a5,a5,1
   1494c:	0037969b          	slliw	a3,a5,0x3
   14950:	fd844783          	lbu	a5,-40(s0)
   14954:	ff77f793          	andi	a5,a5,-9
   14958:	00078713          	mv	a4,a5
   1495c:	00068793          	mv	a5,a3
   14960:	00f767b3          	or	a5,a4,a5
   14964:	fcf40c23          	sb	a5,-40(s0)
    ctrl.bits.WE = 1; // write into MPU
   14968:	fd844783          	lbu	a5,-40(s0)
   1496c:	f807e793          	ori	a5,a5,-128
   14970:	fcf40c23          	sb	a5,-40(s0)
    while (*p) {
   14974:	0700006f          	j	149e4 <mpu_enable_region+0x13c>
        if (*p == 'r') {
   14978:	fe043783          	ld	a5,-32(s0)
   1497c:	0007c783          	lbu	a5,0(a5)
   14980:	00078713          	mv	a4,a5
   14984:	07200793          	li	a5,114
   14988:	00f71863          	bne	a4,a5,14998 <mpu_enable_region+0xf0>
            ctrl.bits.RD = 1;
   1498c:	fd844783          	lbu	a5,-40(s0)
   14990:	0027e793          	ori	a5,a5,2
   14994:	fcf40c23          	sb	a5,-40(s0)
        if (*p == 'w') {
   14998:	fe043783          	ld	a5,-32(s0)
   1499c:	0007c783          	lbu	a5,0(a5)
   149a0:	00078713          	mv	a4,a5
   149a4:	07700793          	li	a5,119
   149a8:	00f71863          	bne	a4,a5,149b8 <mpu_enable_region+0x110>
            ctrl.bits.WR = 1;
   149ac:	fd844783          	lbu	a5,-40(s0)
   149b0:	0017e793          	ori	a5,a5,1
   149b4:	fcf40c23          	sb	a5,-40(s0)
        if (*p == 'x') {
   149b8:	fe043783          	ld	a5,-32(s0)
   149bc:	0007c783          	lbu	a5,0(a5)
   149c0:	00078713          	mv	a4,a5
   149c4:	07800793          	li	a5,120
   149c8:	00f71863          	bne	a4,a5,149d8 <mpu_enable_region+0x130>
            ctrl.bits.EXEC = 1;
   149cc:	fd844783          	lbu	a5,-40(s0)
   149d0:	0047e793          	ori	a5,a5,4
   149d4:	fcf40c23          	sb	a5,-40(s0)
        p++;
   149d8:	fe043783          	ld	a5,-32(s0)
   149dc:	00178793          	addi	a5,a5,1
   149e0:	fef43023          	sd	a5,-32(s0)
    while (*p) {
   149e4:	fe043783          	ld	a5,-32(s0)
   149e8:	0007c783          	lbu	a5,0(a5)
   149ec:	f80796e3          	bnez	a5,14978 <mpu_enable_region+0xd0>
    asm("csrw 0xBC4, %0" : :"r"(ctrl.value));
   149f0:	fd843783          	ld	a5,-40(s0)
   149f4:	bc479073          	csrw	0xbc4,a5
}
   149f8:	00000013          	nop
   149fc:	04813403          	ld	s0,72(sp)
   14a00:	05010113          	addi	sp,sp,80
   14a04:	00008067          	ret

0000000000014a08 <recursive_call>:
#include <string.h>
#include <axi_maps.h>
#include "fw_api.h"

/** Function to check Stack Overflow exception */
void recursive_call() {
   14a08:	fe010113          	addi	sp,sp,-32
   14a0c:	00113c23          	sd	ra,24(sp)
   14a10:	00813823          	sd	s0,16(sp)
   14a14:	02010413          	addi	s0,sp,32
    pnp_map *pnp = (pnp_map *)ADDR_BUS0_XSLV_PNP;
   14a18:	100ff7b7          	lui	a5,0x100ff
   14a1c:	fef43423          	sd	a5,-24(s0)
    if (pnp->fwdbg1 < 10 && pnp->fwdbg2 == 0) {
   14a20:	fe843783          	ld	a5,-24(s0)
   14a24:	0287b703          	ld	a4,40(a5) # 100ff028 <_end+0x100df78c>
   14a28:	00900793          	li	a5,9
   14a2c:	02e7e463          	bltu	a5,a4,14a54 <recursive_call+0x4c>
   14a30:	fe843783          	ld	a5,-24(s0)
   14a34:	0307b783          	ld	a5,48(a5)
   14a38:	00079e63          	bnez	a5,14a54 <recursive_call+0x4c>
        pnp->fwdbg1++;
   14a3c:	fe843783          	ld	a5,-24(s0)
   14a40:	0287b783          	ld	a5,40(a5)
   14a44:	00178713          	addi	a4,a5,1
   14a48:	fe843783          	ld	a5,-24(s0)
   14a4c:	02e7b423          	sd	a4,40(a5)
        recursive_call();
   14a50:	fb9ff0ef          	jal	ra,14a08 <recursive_call>
    }
}
   14a54:	00000013          	nop
   14a58:	01813083          	ld	ra,24(sp)
   14a5c:	01013403          	ld	s0,16(sp)
   14a60:	02010113          	addi	sp,sp,32
   14a64:	00008067          	ret

0000000000014a68 <recursive_ret>:

/** Function to check Stack Underflow exception */
void recursive_ret() {
   14a68:	fe010113          	addi	sp,sp,-32
   14a6c:	00113c23          	sd	ra,24(sp)
   14a70:	00813823          	sd	s0,16(sp)
   14a74:	02010413          	addi	s0,sp,32
    pnp_map *pnp = (pnp_map *)ADDR_BUS0_XSLV_PNP;
   14a78:	100ff7b7          	lui	a5,0x100ff
   14a7c:	fef43423          	sd	a5,-24(s0)
    uint64_t sp;
    if (pnp->fwdbg1 != 0) {
   14a80:	fe843783          	ld	a5,-24(s0)
   14a84:	0287b783          	ld	a5,40(a5) # 100ff028 <_end+0x100df78c>
   14a88:	02078063          	beqz	a5,14aa8 <recursive_ret+0x40>
        pnp->fwdbg1--;
   14a8c:	fe843783          	ld	a5,-24(s0)
   14a90:	0287b783          	ld	a5,40(a5)
   14a94:	fff78713          	addi	a4,a5,-1
   14a98:	fe843783          	ld	a5,-24(s0)
   14a9c:	02e7b423          	sd	a4,40(a5)
        recursive_ret();
   14aa0:	fc9ff0ef          	jal	ra,14a68 <recursive_ret>
        asm("mv %0, sp" : "=r" (sp));
        // Write CSR_mstackund register as underflow border
        sp += 16*sizeof(uint64_t);         // stack underflow limit
        asm("csrw 0xBC1, %0": : "r"(sp));
    }
}
   14aa4:	0200006f          	j	14ac4 <recursive_ret+0x5c>
        asm("mv %0, sp" : "=r" (sp));
   14aa8:	00010793          	mv	a5,sp
   14aac:	fef43023          	sd	a5,-32(s0)
        sp += 16*sizeof(uint64_t);         // stack underflow limit
   14ab0:	fe043783          	ld	a5,-32(s0)
   14ab4:	08078793          	addi	a5,a5,128
   14ab8:	fef43023          	sd	a5,-32(s0)
        asm("csrw 0xBC1, %0": : "r"(sp));
   14abc:	fe043783          	ld	a5,-32(s0)
   14ac0:	bc179073          	csrw	0xbc1,a5
}
   14ac4:	00000013          	nop
   14ac8:	01813083          	ld	ra,24(sp)
   14acc:	01013403          	ld	s0,16(sp)
   14ad0:	02010113          	addi	sp,sp,32
   14ad4:	00008067          	ret

0000000000014ad8 <test_stackprotect>:

void test_stackprotect(void) {
   14ad8:	fd010113          	addi	sp,sp,-48
   14adc:	02113423          	sd	ra,40(sp)
   14ae0:	02813023          	sd	s0,32(sp)
   14ae4:	03010413          	addi	s0,sp,48
    uint64_t sp;
    pnp_map *pnp = (pnp_map *)ADDR_BUS0_XSLV_PNP;
   14ae8:	100ff7b7          	lui	a5,0x100ff
   14aec:	fef43423          	sd	a5,-24(s0)
    // clear register. it should be modified from exception handler
    pnp->fwdbg1 = 0;
   14af0:	fe843783          	ld	a5,-24(s0)
   14af4:	0207b423          	sd	zero,40(a5) # 100ff028 <_end+0x100df78c>
    pnp->fwdbg2 = 0;
   14af8:	fe843783          	ld	a5,-24(s0)
   14afc:	0207b823          	sd	zero,48(a5)

    uint64_t t1 = 0x00000008;
   14b00:	00800793          	li	a5,8
   14b04:	fef43023          	sd	a5,-32(s0)

    // Read current value of the Stack Ponter
    asm("mv %0, sp" : "=r" (sp));
   14b08:	00010793          	mv	a5,sp
   14b0c:	fcf43c23          	sd	a5,-40(s0)

    // Write CSR_mstackovr register as overflow border
    sp -= 16*sizeof(uint64_t);         // stack overflow limit
   14b10:	fd843783          	ld	a5,-40(s0)
   14b14:	f8078793          	addi	a5,a5,-128
   14b18:	fcf43c23          	sd	a5,-40(s0)
    asm("csrw 0xBC0, %0": : "r"(sp));
   14b1c:	fd843783          	ld	a5,-40(s0)
   14b20:	bc079073          	csrw	0xbc0,a5

    asm("csrc mstatus, %0" : :"r"(t1));  // clear mie
   14b24:	fe043783          	ld	a5,-32(s0)
   14b28:	3007b073          	csrc	mstatus,a5
    recursive_call();
   14b2c:	eddff0ef          	jal	ra,14a08 <recursive_call>
    asm("csrs mstatus, %0" : :"r"(t1));  // enable mie
   14b30:	fe043783          	ld	a5,-32(s0)
   14b34:	3007a073          	csrs	mstatus,a5

    /** Check result:
          If the StackOverflow exception was called then fwdbg2 must be
        non-zero. This should happen before fwdbg1 counter reaches 10.
    */
    printf_uart("%s", "stack_ovr. . . .");
   14b38:	0001e7b7          	lui	a5,0x1e
   14b3c:	9c078593          	addi	a1,a5,-1600 # 1d9c0 <FCVT_WU_D_TESTS+0x388>
   14b40:	0001e7b7          	lui	a5,0x1e
   14b44:	9d878513          	addi	a0,a5,-1576 # 1d9d8 <FCVT_WU_D_TESTS+0x3a0>
   14b48:	ffffe097          	auipc	ra,0xffffe
   14b4c:	e08080e7          	jalr	-504(ra) # 12950 <printf_uart>
    if (pnp->fwdbg1 > 1 && pnp->fwdbg1 < 10 && pnp->fwdbg2) {
   14b50:	fe843783          	ld	a5,-24(s0)
   14b54:	0287b703          	ld	a4,40(a5)
   14b58:	00100793          	li	a5,1
   14b5c:	02e7fe63          	bleu	a4,a5,14b98 <test_stackprotect+0xc0>
   14b60:	fe843783          	ld	a5,-24(s0)
   14b64:	0287b703          	ld	a4,40(a5)
   14b68:	00900793          	li	a5,9
   14b6c:	02e7e663          	bltu	a5,a4,14b98 <test_stackprotect+0xc0>
   14b70:	fe843783          	ld	a5,-24(s0)
   14b74:	0307b783          	ld	a5,48(a5)
   14b78:	02078063          	beqz	a5,14b98 <test_stackprotect+0xc0>
        printf_uart("%s", "PASS\r\n");
   14b7c:	0001e7b7          	lui	a5,0x1e
   14b80:	9e078593          	addi	a1,a5,-1568 # 1d9e0 <FCVT_WU_D_TESTS+0x3a8>
   14b84:	0001e7b7          	lui	a5,0x1e
   14b88:	9d878513          	addi	a0,a5,-1576 # 1d9d8 <FCVT_WU_D_TESTS+0x3a0>
   14b8c:	ffffe097          	auipc	ra,0xffffe
   14b90:	dc4080e7          	jalr	-572(ra) # 12950 <printf_uart>
   14b94:	02c0006f          	j	14bc0 <test_stackprotect+0xe8>
    } else {
        printf_uart("FAIL: %08x, %08x\r\n", pnp->fwdbg1, pnp->fwdbg2);
   14b98:	fe843783          	ld	a5,-24(s0)
   14b9c:	0287b703          	ld	a4,40(a5)
   14ba0:	fe843783          	ld	a5,-24(s0)
   14ba4:	0307b783          	ld	a5,48(a5)
   14ba8:	00078613          	mv	a2,a5
   14bac:	00070593          	mv	a1,a4
   14bb0:	0001e7b7          	lui	a5,0x1e
   14bb4:	9e878513          	addi	a0,a5,-1560 # 1d9e8 <FCVT_WU_D_TESTS+0x3b0>
   14bb8:	ffffe097          	auipc	ra,0xffffe
   14bbc:	d98080e7          	jalr	-616(ra) # 12950 <printf_uart>
    }


    // Test Stack Underflow exception
    pnp->fwdbg2 = 0;
   14bc0:	fe843783          	ld	a5,-24(s0)
   14bc4:	0207b823          	sd	zero,48(a5)

    asm("csrc mstatus, %0" : :"r"(t1));  // clear mie
   14bc8:	fe043783          	ld	a5,-32(s0)
   14bcc:	3007b073          	csrc	mstatus,a5
    recursive_ret();
   14bd0:	00000097          	auipc	ra,0x0
   14bd4:	e98080e7          	jalr	-360(ra) # 14a68 <recursive_ret>
    asm("csrs mstatus, %0" : :"r"(t1));  // enable mie
   14bd8:	fe043783          	ld	a5,-32(s0)
   14bdc:	3007a073          	csrs	mstatus,a5

    printf_uart("%s", "stack_und. . . .");
   14be0:	0001e7b7          	lui	a5,0x1e
   14be4:	a0078593          	addi	a1,a5,-1536 # 1da00 <FCVT_WU_D_TESTS+0x3c8>
   14be8:	0001e7b7          	lui	a5,0x1e
   14bec:	9d878513          	addi	a0,a5,-1576 # 1d9d8 <FCVT_WU_D_TESTS+0x3a0>
   14bf0:	ffffe097          	auipc	ra,0xffffe
   14bf4:	d60080e7          	jalr	-672(ra) # 12950 <printf_uart>
    if (pnp->fwdbg2) {
   14bf8:	fe843783          	ld	a5,-24(s0)
   14bfc:	0307b783          	ld	a5,48(a5)
   14c00:	02078063          	beqz	a5,14c20 <test_stackprotect+0x148>
        printf_uart("%s", "PASS\r\n");
   14c04:	0001e7b7          	lui	a5,0x1e
   14c08:	9e078593          	addi	a1,a5,-1568 # 1d9e0 <FCVT_WU_D_TESTS+0x3a8>
   14c0c:	0001e7b7          	lui	a5,0x1e
   14c10:	9d878513          	addi	a0,a5,-1576 # 1d9d8 <FCVT_WU_D_TESTS+0x3a0>
   14c14:	ffffe097          	auipc	ra,0xffffe
   14c18:	d3c080e7          	jalr	-708(ra) # 12950 <printf_uart>
    } else {
        printf_uart("FAIL: %08x\r\n", pnp->fwdbg2);
    }

}
   14c1c:	0200006f          	j	14c3c <test_stackprotect+0x164>
        printf_uart("FAIL: %08x\r\n", pnp->fwdbg2);
   14c20:	fe843783          	ld	a5,-24(s0)
   14c24:	0307b783          	ld	a5,48(a5)
   14c28:	00078593          	mv	a1,a5
   14c2c:	0001e7b7          	lui	a5,0x1e
   14c30:	a1878513          	addi	a0,a5,-1512 # 1da18 <FCVT_WU_D_TESTS+0x3e0>
   14c34:	ffffe097          	auipc	ra,0xffffe
   14c38:	d1c080e7          	jalr	-740(ra) # 12950 <printf_uart>
}
   14c3c:	00000013          	nop
   14c40:	02813083          	ld	ra,40(sp)
   14c44:	02013403          	ld	s0,32(sp)
   14c48:	03010113          	addi	sp,sp,48
   14c4c:	00008067          	ret
   14c50:	0000                	unimp
	...

0000000000014c54 <get_dev_bar>:
static uint64_t get_dev_bar(pnp_map *pnp, uint16_t vid, uint16_t did) {
   14c54:	fb010113          	addi	sp,sp,-80
   14c58:	04813423          	sd	s0,72(sp)
   14c5c:	05010413          	addi	s0,sp,80
   14c60:	faa43c23          	sd	a0,-72(s0)
   14c64:	00058793          	mv	a5,a1
   14c68:	00060713          	mv	a4,a2
   14c6c:	faf41b23          	sh	a5,-74(s0)
   14c70:	00070793          	mv	a5,a4
   14c74:	faf41a23          	sh	a5,-76(s0)
    int slots_total = (pnp->cfg >> 8) & 0xFF;
   14c78:	fb843783          	ld	a5,-72(s0)
   14c7c:	0087a783          	lw	a5,8(a5)
   14c80:	0087d79b          	srliw	a5,a5,0x8
   14c84:	0007879b          	sext.w	a5,a5
   14c88:	0007879b          	sext.w	a5,a5
   14c8c:	0ff7f793          	andi	a5,a5,255
   14c90:	fef42223          	sw	a5,-28(s0)
    int off = 0;
   14c94:	fe042623          	sw	zero,-20(s0)
    for (int i = 0; i < slots_total; i++) {
   14c98:	fe042423          	sw	zero,-24(s0)
   14c9c:	09c0006f          	j	14d38 <get_dev_bar+0xe4>
        dcfg = *(dev_cfg_type *)&pnp->cfg_table[off];
   14ca0:	fec42783          	lw	a5,-20(s0)
   14ca4:	04078793          	addi	a5,a5,64
   14ca8:	fb843703          	ld	a4,-72(s0)
   14cac:	00f707b3          	add	a5,a4,a5
   14cb0:	0007b703          	ld	a4,0(a5)
   14cb4:	fce43023          	sd	a4,-64(s0)
   14cb8:	0087b703          	ld	a4,8(a5)
   14cbc:	fce43423          	sd	a4,-56(s0)
   14cc0:	0107b703          	ld	a4,16(a5)
   14cc4:	fce43823          	sd	a4,-48(s0)
   14cc8:	0187b783          	ld	a5,24(a5)
   14ccc:	fcf43c23          	sd	a5,-40(s0)
        off += sizeof(dcfg);
   14cd0:	fec42783          	lw	a5,-20(s0)
   14cd4:	0207879b          	addiw	a5,a5,32
   14cd8:	0007879b          	sext.w	a5,a5
   14cdc:	fef42623          	sw	a5,-20(s0)
        if (dcfg.u.descrtype != PNP_CFG_TYPE_SLAVE) {
   14ce0:	fc144783          	lbu	a5,-63(s0)
   14ce4:	0037f793          	andi	a5,a5,3
   14ce8:	0ff7f793          	andi	a5,a5,255
   14cec:	00078713          	mv	a4,a5
   14cf0:	00200793          	li	a5,2
   14cf4:	02f71a63          	bne	a4,a5,14d28 <get_dev_bar+0xd4>
        if (dcfg.u.vid == vid && dcfg.u.did == did) {
   14cf8:	fc645783          	lhu	a5,-58(s0)
   14cfc:	fb645703          	lhu	a4,-74(s0)
   14d00:	0007071b          	sext.w	a4,a4
   14d04:	0007879b          	sext.w	a5,a5
   14d08:	02f71263          	bne	a4,a5,14d2c <get_dev_bar+0xd8>
   14d0c:	fc445783          	lhu	a5,-60(s0)
   14d10:	fb445703          	lhu	a4,-76(s0)
   14d14:	0007071b          	sext.w	a4,a4
   14d18:	0007879b          	sext.w	a5,a5
   14d1c:	00f71863          	bne	a4,a5,14d2c <get_dev_bar+0xd8>
            return dcfg.u.addr_start;
   14d20:	fd043783          	ld	a5,-48(s0)
   14d24:	02c0006f          	j	14d50 <get_dev_bar+0xfc>
            continue;
   14d28:	00000013          	nop
    for (int i = 0; i < slots_total; i++) {
   14d2c:	fe842783          	lw	a5,-24(s0)
   14d30:	0017879b          	addiw	a5,a5,1
   14d34:	fef42423          	sw	a5,-24(s0)
   14d38:	fe842703          	lw	a4,-24(s0)
   14d3c:	fe442783          	lw	a5,-28(s0)
   14d40:	0007071b          	sext.w	a4,a4
   14d44:	0007879b          	sext.w	a5,a5
   14d48:	f4f74ce3          	blt	a4,a5,14ca0 <get_dev_bar+0x4c>
    return DEV_NONE;
   14d4c:	fff00793          	li	a5,-1
}
   14d50:	00078513          	mv	a0,a5
   14d54:	04813403          	ld	s0,72(sp)
   14d58:	05010113          	addi	sp,sp,80
   14d5c:	00008067          	ret

0000000000014d60 <mpu_region_total>:
static int mpu_region_total() {
   14d60:	fe010113          	addi	sp,sp,-32
   14d64:	00813c23          	sd	s0,24(sp)
   14d68:	02010413          	addi	s0,sp,32
    uint64_t val = 0;
   14d6c:	fe043423          	sd	zero,-24(s0)
    asm("csrr %0, 0xBC4" : "=r" (val));
   14d70:	bc4027f3          	csrr	a5,0xbc4
   14d74:	fef43423          	sd	a5,-24(s0)
    return (int)(val >> 8);
   14d78:	fe843783          	ld	a5,-24(s0)
   14d7c:	0087d793          	srli	a5,a5,0x8
   14d80:	0007879b          	sext.w	a5,a5
}
   14d84:	00078513          	mv	a0,a5
   14d88:	01813403          	ld	s0,24(sp)
   14d8c:	02010113          	addi	sp,sp,32
   14d90:	00008067          	ret

0000000000014d94 <mpu_disable_region>:
static void mpu_disable_region(int idx) {
   14d94:	fd010113          	addi	sp,sp,-48
   14d98:	02813423          	sd	s0,40(sp)
   14d9c:	03010413          	addi	s0,sp,48
   14da0:	00050793          	mv	a5,a0
   14da4:	fcf42e23          	sw	a5,-36(s0)
    ctrl.value = 0;
   14da8:	fe043423          	sd	zero,-24(s0)
    ctrl.bits.IDX = idx;
   14dac:	fdc42783          	lw	a5,-36(s0)
   14db0:	0ff7f793          	andi	a5,a5,255
   14db4:	fef404a3          	sb	a5,-23(s0)
    ctrl.bits.WE = 1;
   14db8:	fe844783          	lbu	a5,-24(s0)
   14dbc:	f807e793          	ori	a5,a5,-128
   14dc0:	fef40423          	sb	a5,-24(s0)
    asm("csrw 0xBC4, %0" : :"r"(ctrl.value));
   14dc4:	fe843783          	ld	a5,-24(s0)
   14dc8:	bc479073          	csrw	0xbc4,a5
}
   14dcc:	00000013          	nop
   14dd0:	02813403          	ld	s0,40(sp)
   14dd4:	03010113          	addi	sp,sp,48
   14dd8:	00008067          	ret

0000000000014ddc <mpu_enable_region>:
                       const char *rwx) {
   14ddc:	fb010113          	addi	sp,sp,-80
   14de0:	04813423          	sd	s0,72(sp)
   14de4:	05010413          	addi	s0,sp,80
   14de8:	00050793          	mv	a5,a0
   14dec:	fcb43023          	sd	a1,-64(s0)
   14df0:	fac43c23          	sd	a2,-72(s0)
   14df4:	fae43823          	sd	a4,-80(s0)
   14df8:	fcf42623          	sw	a5,-52(s0)
   14dfc:	00068793          	mv	a5,a3
   14e00:	fcf42423          	sw	a5,-56(s0)
    uint64_t mask = (~0ull) << 10;
   14e04:	c0000793          	li	a5,-1024
   14e08:	fef43423          	sd	a5,-24(s0)
    const char *p = rwx;
   14e0c:	fb043783          	ld	a5,-80(s0)
   14e10:	fef43023          	sd	a5,-32(s0)
    asm("csrw 0xBC2, %0" : :"r"(bar));
   14e14:	fc043783          	ld	a5,-64(s0)
   14e18:	bc279073          	csrw	0xbc2,a5
    KB >>= 1;
   14e1c:	fb843783          	ld	a5,-72(s0)
   14e20:	0017d793          	srli	a5,a5,0x1
   14e24:	faf43c23          	sd	a5,-72(s0)
    while (KB) {
   14e28:	01c0006f          	j	14e44 <mpu_enable_region+0x68>
        mask <<= 1;
   14e2c:	fe843783          	ld	a5,-24(s0)
   14e30:	00179793          	slli	a5,a5,0x1
   14e34:	fef43423          	sd	a5,-24(s0)
        KB >>= 1;
   14e38:	fb843783          	ld	a5,-72(s0)
   14e3c:	0017d793          	srli	a5,a5,0x1
   14e40:	faf43c23          	sd	a5,-72(s0)
    while (KB) {
   14e44:	fb843783          	ld	a5,-72(s0)
   14e48:	fe0792e3          	bnez	a5,14e2c <mpu_enable_region+0x50>
    asm("csrw 0xBC3, %0" : :"r"(mask));
   14e4c:	fe843783          	ld	a5,-24(s0)
   14e50:	bc379073          	csrw	0xbc3,a5
    ctrl.value = 0;
   14e54:	fc043c23          	sd	zero,-40(s0)
    ctrl.bits.IDX = idx;
   14e58:	fcc42783          	lw	a5,-52(s0)
   14e5c:	0ff7f793          	andi	a5,a5,255
   14e60:	fcf40ca3          	sb	a5,-39(s0)
    ctrl.bits.ENA = 1;
   14e64:	fd844783          	lbu	a5,-40(s0)
   14e68:	0107e793          	ori	a5,a5,16
   14e6c:	fcf40c23          	sb	a5,-40(s0)
    ctrl.bits.CACHABLE = cached;
   14e70:	fc842783          	lw	a5,-56(s0)
   14e74:	0017f793          	andi	a5,a5,1
   14e78:	0ff7f793          	andi	a5,a5,255
   14e7c:	0017f793          	andi	a5,a5,1
   14e80:	0037969b          	slliw	a3,a5,0x3
   14e84:	fd844783          	lbu	a5,-40(s0)
   14e88:	ff77f793          	andi	a5,a5,-9
   14e8c:	00078713          	mv	a4,a5
   14e90:	00068793          	mv	a5,a3
   14e94:	00f767b3          	or	a5,a4,a5
   14e98:	fcf40c23          	sb	a5,-40(s0)
    ctrl.bits.WE = 1; // write into MPU
   14e9c:	fd844783          	lbu	a5,-40(s0)
   14ea0:	f807e793          	ori	a5,a5,-128
   14ea4:	fcf40c23          	sb	a5,-40(s0)
    while (*p) {
   14ea8:	0700006f          	j	14f18 <mpu_enable_region+0x13c>
        if (*p == 'r') {
   14eac:	fe043783          	ld	a5,-32(s0)
   14eb0:	0007c783          	lbu	a5,0(a5)
   14eb4:	00078713          	mv	a4,a5
   14eb8:	07200793          	li	a5,114
   14ebc:	00f71863          	bne	a4,a5,14ecc <mpu_enable_region+0xf0>
            ctrl.bits.RD = 1;
   14ec0:	fd844783          	lbu	a5,-40(s0)
   14ec4:	0027e793          	ori	a5,a5,2
   14ec8:	fcf40c23          	sb	a5,-40(s0)
        if (*p == 'w') {
   14ecc:	fe043783          	ld	a5,-32(s0)
   14ed0:	0007c783          	lbu	a5,0(a5)
   14ed4:	00078713          	mv	a4,a5
   14ed8:	07700793          	li	a5,119
   14edc:	00f71863          	bne	a4,a5,14eec <mpu_enable_region+0x110>
            ctrl.bits.WR = 1;
   14ee0:	fd844783          	lbu	a5,-40(s0)
   14ee4:	0017e793          	ori	a5,a5,1
   14ee8:	fcf40c23          	sb	a5,-40(s0)
        if (*p == 'x') {
   14eec:	fe043783          	ld	a5,-32(s0)
   14ef0:	0007c783          	lbu	a5,0(a5)
   14ef4:	00078713          	mv	a4,a5
   14ef8:	07800793          	li	a5,120
   14efc:	00f71863          	bne	a4,a5,14f0c <mpu_enable_region+0x130>
            ctrl.bits.EXEC = 1;
   14f00:	fd844783          	lbu	a5,-40(s0)
   14f04:	0047e793          	ori	a5,a5,4
   14f08:	fcf40c23          	sb	a5,-40(s0)
        p++;
   14f0c:	fe043783          	ld	a5,-32(s0)
   14f10:	00178793          	addi	a5,a5,1
   14f14:	fef43023          	sd	a5,-32(s0)
    while (*p) {
   14f18:	fe043783          	ld	a5,-32(s0)
   14f1c:	0007c783          	lbu	a5,0(a5)
   14f20:	f80796e3          	bnez	a5,14eac <mpu_enable_region+0xd0>
    asm("csrw 0xBC4, %0" : :"r"(ctrl.value));
   14f24:	fd843783          	ld	a5,-40(s0)
   14f28:	bc479073          	csrw	0xbc4,a5
}
   14f2c:	00000013          	nop
   14f30:	04813403          	ld	s0,72(sp)
   14f34:	05010113          	addi	sp,sp,80
   14f38:	00008067          	ret

0000000000014f3c <isr_gnss_ss>:
#include <axi_maps.h>
#include "fw_api.h"

#define WAS_GNSS_ISR_MARKER 0xcafe0001ull

void isr_gnss_ss(void) {
   14f3c:	fe010113          	addi	sp,sp,-32
   14f40:	00813c23          	sd	s0,24(sp)
   14f44:	02010413          	addi	s0,sp,32
    pnp_map *pnp = (pnp_map *)ADDR_BUS0_XSLV_PNP;
   14f48:	100ff7b7          	lui	a5,0x100ff
   14f4c:	fef43423          	sd	a5,-24(s0)
    pnp->fwdbg1 = WAS_GNSS_ISR_MARKER;
   14f50:	fe843783          	ld	a5,-24(s0)
   14f54:	0657f737          	lui	a4,0x657f
   14f58:	00571713          	slli	a4,a4,0x5
   14f5c:	00170713          	addi	a4,a4,1 # 657f001 <_end+0x655f765>
   14f60:	02e7b423          	sd	a4,40(a5) # 100ff028 <_end+0x100df78c>
}
   14f64:	00000013          	nop
   14f68:	01813403          	ld	s0,24(sp)
   14f6c:	02010113          	addi	sp,sp,32
   14f70:	00008067          	ret

0000000000014f74 <test_gnss_ss>:

void test_gnss_ss(uint64_t bar) {
   14f74:	fb010113          	addi	sp,sp,-80
   14f78:	04113423          	sd	ra,72(sp)
   14f7c:	04813023          	sd	s0,64(sp)
   14f80:	05010413          	addi	s0,sp,80
   14f84:	faa43c23          	sd	a0,-72(s0)
    pnp_map *pnp = (pnp_map *)ADDR_BUS0_XSLV_PNP;
   14f88:	100ff7b7          	lui	a5,0x100ff
   14f8c:	fef43423          	sd	a5,-24(s0)
    rfctrl_map *rf = (rfctrl_map *)(bar + 0*0x1000);
   14f90:	fb843783          	ld	a5,-72(s0)
   14f94:	fef43023          	sd	a5,-32(s0)
    GnssEngine_map *gnss = (GnssEngine_map *)(bar + 1*0x1000);
   14f98:	fb843703          	ld	a4,-72(s0)
   14f9c:	000017b7          	lui	a5,0x1
   14fa0:	00f707b3          	add	a5,a4,a5
   14fa4:	fcf43c23          	sd	a5,-40(s0)
    fsev2_map *fse = (fsev2_map *)(bar + 2*0x1000);
   14fa8:	fb843703          	ld	a4,-72(s0)
   14fac:	000027b7          	lui	a5,0x2
   14fb0:	00f707b3          	add	a5,a4,a5
   14fb4:	fcf43823          	sd	a5,-48(s0)

    register_ext_interrupt_handler(CFG_IRQ_GNSS_SS, isr_gnss_ss);
   14fb8:	000157b7          	lui	a5,0x15
   14fbc:	f3c78593          	addi	a1,a5,-196 # 14f3c <isr_gnss_ss>
   14fc0:	04700513          	li	a0,71
   14fc4:	b48fc0ef          	jal	ra,1130c <register_ext_interrupt_handler>
    fw_enable_plic_irq(CTX_CPU0_M_MODE, CFG_IRQ_GNSS_SS);
   14fc8:	04700593          	li	a1,71
   14fcc:	00000513          	li	a0,0
   14fd0:	ffffe097          	auipc	ra,0xffffe
   14fd4:	e5c080e7          	jalr	-420(ra) # 12e2c <fw_enable_plic_irq>

    // rf controller
    pnp->fwdbg1 = rf->subsystem_config;
   14fd8:	fe043783          	ld	a5,-32(s0)
   14fdc:	0407a783          	lw	a5,64(a5)
   14fe0:	0007879b          	sext.w	a5,a5
   14fe4:	02079713          	slli	a4,a5,0x20
   14fe8:	02075713          	srli	a4,a4,0x20
   14fec:	fe843783          	ld	a5,-24(s0)
   14ff0:	02e7b423          	sd	a4,40(a5)
    rf->conf1 = 0x34;
   14ff4:	fe043783          	ld	a5,-32(s0)
   14ff8:	03400713          	li	a4,52
   14ffc:	00e7a023          	sw	a4,0(a5)

    // engine access
    pnp->fwdbg1 = 0;
   15000:	fe843783          	ld	a5,-24(s0)
   15004:	0207b423          	sd	zero,40(a5)
    gnss->tmr.rw_MsLength = 2000;
   15008:	fd843783          	ld	a5,-40(s0)
   1500c:	7d000713          	li	a4,2000
   15010:	04e7a023          	sw	a4,64(a5)

    int t1 = 0x00000800;
   15014:	000017b7          	lui	a5,0x1
   15018:	8007879b          	addiw	a5,a5,-2048
   1501c:	fcf42623          	sw	a5,-52(s0)
    asm("csrs mie, %0" : :"r"(t1));  // enable external irq from PLIC
   15020:	fcc42783          	lw	a5,-52(s0)
   15024:	3047a073          	csrs	mie,a5

    while (pnp->fwdbg1 != WAS_GNSS_ISR_MARKER) {}
   15028:	00000013          	nop
   1502c:	fe843783          	ld	a5,-24(s0)
   15030:	0287b703          	ld	a4,40(a5) # 1028 <_ftext-0xefd8>
   15034:	0657f7b7          	lui	a5,0x657f
   15038:	00579793          	slli	a5,a5,0x5
   1503c:	00178793          	addi	a5,a5,1 # 657f001 <_end+0x655f765>
   15040:	fef716e3          	bne	a4,a5,1502c <test_gnss_ss+0xb8>

    fw_disable_plic_irq(CTX_CPU0_M_MODE, CFG_IRQ_GNSS_SS);
   15044:	04700593          	li	a1,71
   15048:	00000513          	li	a0,0
   1504c:	ec1fd0ef          	jal	ra,12f0c <fw_disable_plic_irq>
    asm("csrc mie, %0" : :"r"(t1));  // disable external irq from PLIC
   15050:	fcc42783          	lw	a5,-52(s0)
   15054:	3047b073          	csrc	mie,a5

    pnp->fwdbg1 = gnss->tmr.rw_tow;
   15058:	fd843783          	ld	a5,-40(s0)
   1505c:	0487a783          	lw	a5,72(a5)
   15060:	0007879b          	sext.w	a5,a5
   15064:	00078713          	mv	a4,a5
   15068:	fe843783          	ld	a5,-24(s0)
   1506c:	02e7b423          	sd	a4,40(a5)

    pnp->fwdbg1 = gnss->misc.GenericChanCfg;
   15070:	fd843783          	ld	a5,-40(s0)
   15074:	0047a783          	lw	a5,4(a5)
   15078:	0007879b          	sext.w	a5,a5
   1507c:	02079713          	slli	a4,a5,0x20
   15080:	02075713          	srli	a4,a4,0x20
   15084:	fe843783          	ld	a5,-24(s0)
   15088:	02e7b423          	sd	a4,40(a5)
    gnss->chn[0].u.w.CodeNcoTh = 1023*40000;
   1508c:	fd843783          	ld	a5,-40(s0)
   15090:	02706737          	lui	a4,0x2706
   15094:	3c07071b          	addiw	a4,a4,960
   15098:	0ce7a023          	sw	a4,192(a5)

    // fse gps
    pnp->fwdbg1 = fse->hw_id;
   1509c:	fd043783          	ld	a5,-48(s0)
   150a0:	4007a783          	lw	a5,1024(a5)
   150a4:	0007879b          	sext.w	a5,a5
   150a8:	02079713          	slli	a4,a5,0x20
   150ac:	02075713          	srli	a4,a4,0x20
   150b0:	fe843783          	ld	a5,-24(s0)
   150b4:	02e7b423          	sd	a4,40(a5)
    fse->chan[0].carr_nco_f0 = 555;
   150b8:	fd043783          	ld	a5,-48(s0)
   150bc:	22b00713          	li	a4,555
   150c0:	00e7a223          	sw	a4,4(a5)
    fse->carr_nco_th = 0xFFEE;
   150c4:	fd043783          	ld	a5,-48(s0)
   150c8:	00010737          	lui	a4,0x10
   150cc:	fee7071b          	addiw	a4,a4,-18
   150d0:	40e7a623          	sw	a4,1036(a5)
}
   150d4:	00000013          	nop
   150d8:	04813083          	ld	ra,72(sp)
   150dc:	04013403          	ld	s0,64(sp)
   150e0:	05010113          	addi	sp,sp,80
   150e4:	00008067          	ret
   150e8:	0000                	unimp
	...

00000000000150ec <get_dev_bar>:
static uint64_t get_dev_bar(pnp_map *pnp, uint16_t vid, uint16_t did) {
   150ec:	fb010113          	addi	sp,sp,-80
   150f0:	04813423          	sd	s0,72(sp)
   150f4:	05010413          	addi	s0,sp,80
   150f8:	faa43c23          	sd	a0,-72(s0)
   150fc:	00058793          	mv	a5,a1
   15100:	00060713          	mv	a4,a2
   15104:	faf41b23          	sh	a5,-74(s0)
   15108:	00070793          	mv	a5,a4
   1510c:	faf41a23          	sh	a5,-76(s0)
    int slots_total = (pnp->cfg >> 8) & 0xFF;
   15110:	fb843783          	ld	a5,-72(s0)
   15114:	0087a783          	lw	a5,8(a5)
   15118:	0087d79b          	srliw	a5,a5,0x8
   1511c:	0007879b          	sext.w	a5,a5
   15120:	0007879b          	sext.w	a5,a5
   15124:	0ff7f793          	andi	a5,a5,255
   15128:	fef42223          	sw	a5,-28(s0)
    int off = 0;
   1512c:	fe042623          	sw	zero,-20(s0)
    for (int i = 0; i < slots_total; i++) {
   15130:	fe042423          	sw	zero,-24(s0)
   15134:	09c0006f          	j	151d0 <get_dev_bar+0xe4>
        dcfg = *(dev_cfg_type *)&pnp->cfg_table[off];
   15138:	fec42783          	lw	a5,-20(s0)
   1513c:	04078793          	addi	a5,a5,64
   15140:	fb843703          	ld	a4,-72(s0)
   15144:	00f707b3          	add	a5,a4,a5
   15148:	0007b703          	ld	a4,0(a5)
   1514c:	fce43023          	sd	a4,-64(s0)
   15150:	0087b703          	ld	a4,8(a5)
   15154:	fce43423          	sd	a4,-56(s0)
   15158:	0107b703          	ld	a4,16(a5)
   1515c:	fce43823          	sd	a4,-48(s0)
   15160:	0187b783          	ld	a5,24(a5)
   15164:	fcf43c23          	sd	a5,-40(s0)
        off += sizeof(dcfg);
   15168:	fec42783          	lw	a5,-20(s0)
   1516c:	0207879b          	addiw	a5,a5,32
   15170:	0007879b          	sext.w	a5,a5
   15174:	fef42623          	sw	a5,-20(s0)
        if (dcfg.u.descrtype != PNP_CFG_TYPE_SLAVE) {
   15178:	fc144783          	lbu	a5,-63(s0)
   1517c:	0037f793          	andi	a5,a5,3
   15180:	0ff7f793          	andi	a5,a5,255
   15184:	00078713          	mv	a4,a5
   15188:	00200793          	li	a5,2
   1518c:	02f71a63          	bne	a4,a5,151c0 <get_dev_bar+0xd4>
        if (dcfg.u.vid == vid && dcfg.u.did == did) {
   15190:	fc645783          	lhu	a5,-58(s0)
   15194:	fb645703          	lhu	a4,-74(s0)
   15198:	0007071b          	sext.w	a4,a4
   1519c:	0007879b          	sext.w	a5,a5
   151a0:	02f71263          	bne	a4,a5,151c4 <get_dev_bar+0xd8>
   151a4:	fc445783          	lhu	a5,-60(s0)
   151a8:	fb445703          	lhu	a4,-76(s0)
   151ac:	0007071b          	sext.w	a4,a4
   151b0:	0007879b          	sext.w	a5,a5
   151b4:	00f71863          	bne	a4,a5,151c4 <get_dev_bar+0xd8>
            return dcfg.u.addr_start;
   151b8:	fd043783          	ld	a5,-48(s0)
   151bc:	02c0006f          	j	151e8 <get_dev_bar+0xfc>
            continue;
   151c0:	00000013          	nop
    for (int i = 0; i < slots_total; i++) {
   151c4:	fe842783          	lw	a5,-24(s0)
   151c8:	0017879b          	addiw	a5,a5,1
   151cc:	fef42423          	sw	a5,-24(s0)
   151d0:	fe842703          	lw	a4,-24(s0)
   151d4:	fe442783          	lw	a5,-28(s0)
   151d8:	0007071b          	sext.w	a4,a4
   151dc:	0007879b          	sext.w	a5,a5
   151e0:	f4f74ce3          	blt	a4,a5,15138 <get_dev_bar+0x4c>
    return DEV_NONE;
   151e4:	fff00793          	li	a5,-1
}
   151e8:	00078513          	mv	a0,a5
   151ec:	04813403          	ld	s0,72(sp)
   151f0:	05010113          	addi	sp,sp,80
   151f4:	00008067          	ret

00000000000151f8 <mpu_region_total>:
static int mpu_region_total() {
   151f8:	fe010113          	addi	sp,sp,-32
   151fc:	00813c23          	sd	s0,24(sp)
   15200:	02010413          	addi	s0,sp,32
    uint64_t val = 0;
   15204:	fe043423          	sd	zero,-24(s0)
    asm("csrr %0, 0xBC4" : "=r" (val));
   15208:	bc4027f3          	csrr	a5,0xbc4
   1520c:	fef43423          	sd	a5,-24(s0)
    return (int)(val >> 8);
   15210:	fe843783          	ld	a5,-24(s0)
   15214:	0087d793          	srli	a5,a5,0x8
   15218:	0007879b          	sext.w	a5,a5
}
   1521c:	00078513          	mv	a0,a5
   15220:	01813403          	ld	s0,24(sp)
   15224:	02010113          	addi	sp,sp,32
   15228:	00008067          	ret

000000000001522c <mpu_disable_region>:
static void mpu_disable_region(int idx) {
   1522c:	fd010113          	addi	sp,sp,-48
   15230:	02813423          	sd	s0,40(sp)
   15234:	03010413          	addi	s0,sp,48
   15238:	00050793          	mv	a5,a0
   1523c:	fcf42e23          	sw	a5,-36(s0)
    ctrl.value = 0;
   15240:	fe043423          	sd	zero,-24(s0)
    ctrl.bits.IDX = idx;
   15244:	fdc42783          	lw	a5,-36(s0)
   15248:	0ff7f793          	andi	a5,a5,255
   1524c:	fef404a3          	sb	a5,-23(s0)
    ctrl.bits.WE = 1;
   15250:	fe844783          	lbu	a5,-24(s0)
   15254:	f807e793          	ori	a5,a5,-128
   15258:	fef40423          	sb	a5,-24(s0)
    asm("csrw 0xBC4, %0" : :"r"(ctrl.value));
   1525c:	fe843783          	ld	a5,-24(s0)
   15260:	bc479073          	csrw	0xbc4,a5
}
   15264:	00000013          	nop
   15268:	02813403          	ld	s0,40(sp)
   1526c:	03010113          	addi	sp,sp,48
   15270:	00008067          	ret

0000000000015274 <mpu_enable_region>:
                       const char *rwx) {
   15274:	fb010113          	addi	sp,sp,-80
   15278:	04813423          	sd	s0,72(sp)
   1527c:	05010413          	addi	s0,sp,80
   15280:	00050793          	mv	a5,a0
   15284:	fcb43023          	sd	a1,-64(s0)
   15288:	fac43c23          	sd	a2,-72(s0)
   1528c:	fae43823          	sd	a4,-80(s0)
   15290:	fcf42623          	sw	a5,-52(s0)
   15294:	00068793          	mv	a5,a3
   15298:	fcf42423          	sw	a5,-56(s0)
    uint64_t mask = (~0ull) << 10;
   1529c:	c0000793          	li	a5,-1024
   152a0:	fef43423          	sd	a5,-24(s0)
    const char *p = rwx;
   152a4:	fb043783          	ld	a5,-80(s0)
   152a8:	fef43023          	sd	a5,-32(s0)
    asm("csrw 0xBC2, %0" : :"r"(bar));
   152ac:	fc043783          	ld	a5,-64(s0)
   152b0:	bc279073          	csrw	0xbc2,a5
    KB >>= 1;
   152b4:	fb843783          	ld	a5,-72(s0)
   152b8:	0017d793          	srli	a5,a5,0x1
   152bc:	faf43c23          	sd	a5,-72(s0)
    while (KB) {
   152c0:	01c0006f          	j	152dc <mpu_enable_region+0x68>
        mask <<= 1;
   152c4:	fe843783          	ld	a5,-24(s0)
   152c8:	00179793          	slli	a5,a5,0x1
   152cc:	fef43423          	sd	a5,-24(s0)
        KB >>= 1;
   152d0:	fb843783          	ld	a5,-72(s0)
   152d4:	0017d793          	srli	a5,a5,0x1
   152d8:	faf43c23          	sd	a5,-72(s0)
    while (KB) {
   152dc:	fb843783          	ld	a5,-72(s0)
   152e0:	fe0792e3          	bnez	a5,152c4 <mpu_enable_region+0x50>
    asm("csrw 0xBC3, %0" : :"r"(mask));
   152e4:	fe843783          	ld	a5,-24(s0)
   152e8:	bc379073          	csrw	0xbc3,a5
    ctrl.value = 0;
   152ec:	fc043c23          	sd	zero,-40(s0)
    ctrl.bits.IDX = idx;
   152f0:	fcc42783          	lw	a5,-52(s0)
   152f4:	0ff7f793          	andi	a5,a5,255
   152f8:	fcf40ca3          	sb	a5,-39(s0)
    ctrl.bits.ENA = 1;
   152fc:	fd844783          	lbu	a5,-40(s0)
   15300:	0107e793          	ori	a5,a5,16
   15304:	fcf40c23          	sb	a5,-40(s0)
    ctrl.bits.CACHABLE = cached;
   15308:	fc842783          	lw	a5,-56(s0)
   1530c:	0017f793          	andi	a5,a5,1
   15310:	0ff7f793          	andi	a5,a5,255
   15314:	0017f793          	andi	a5,a5,1
   15318:	0037969b          	slliw	a3,a5,0x3
   1531c:	fd844783          	lbu	a5,-40(s0)
   15320:	ff77f793          	andi	a5,a5,-9
   15324:	00078713          	mv	a4,a5
   15328:	00068793          	mv	a5,a3
   1532c:	00f767b3          	or	a5,a4,a5
   15330:	fcf40c23          	sb	a5,-40(s0)
    ctrl.bits.WE = 1; // write into MPU
   15334:	fd844783          	lbu	a5,-40(s0)
   15338:	f807e793          	ori	a5,a5,-128
   1533c:	fcf40c23          	sb	a5,-40(s0)
    while (*p) {
   15340:	0700006f          	j	153b0 <mpu_enable_region+0x13c>
        if (*p == 'r') {
   15344:	fe043783          	ld	a5,-32(s0)
   15348:	0007c783          	lbu	a5,0(a5)
   1534c:	00078713          	mv	a4,a5
   15350:	07200793          	li	a5,114
   15354:	00f71863          	bne	a4,a5,15364 <mpu_enable_region+0xf0>
            ctrl.bits.RD = 1;
   15358:	fd844783          	lbu	a5,-40(s0)
   1535c:	0027e793          	ori	a5,a5,2
   15360:	fcf40c23          	sb	a5,-40(s0)
        if (*p == 'w') {
   15364:	fe043783          	ld	a5,-32(s0)
   15368:	0007c783          	lbu	a5,0(a5)
   1536c:	00078713          	mv	a4,a5
   15370:	07700793          	li	a5,119
   15374:	00f71863          	bne	a4,a5,15384 <mpu_enable_region+0x110>
            ctrl.bits.WR = 1;
   15378:	fd844783          	lbu	a5,-40(s0)
   1537c:	0017e793          	ori	a5,a5,1
   15380:	fcf40c23          	sb	a5,-40(s0)
        if (*p == 'x') {
   15384:	fe043783          	ld	a5,-32(s0)
   15388:	0007c783          	lbu	a5,0(a5)
   1538c:	00078713          	mv	a4,a5
   15390:	07800793          	li	a5,120
   15394:	00f71863          	bne	a4,a5,153a4 <mpu_enable_region+0x130>
            ctrl.bits.EXEC = 1;
   15398:	fd844783          	lbu	a5,-40(s0)
   1539c:	0047e793          	ori	a5,a5,4
   153a0:	fcf40c23          	sb	a5,-40(s0)
        p++;
   153a4:	fe043783          	ld	a5,-32(s0)
   153a8:	00178793          	addi	a5,a5,1
   153ac:	fef43023          	sd	a5,-32(s0)
    while (*p) {
   153b0:	fe043783          	ld	a5,-32(s0)
   153b4:	0007c783          	lbu	a5,0(a5)
   153b8:	f80796e3          	bnez	a5,15344 <mpu_enable_region+0xd0>
    asm("csrw 0xBC4, %0" : :"r"(ctrl.value));
   153bc:	fd843783          	ld	a5,-40(s0)
   153c0:	bc479073          	csrw	0xbc4,a5
}
   153c4:	00000013          	nop
   153c8:	04813403          	ld	s0,72(sp)
   153cc:	05010113          	addi	sp,sp,80
   153d0:	00008067          	ret

00000000000153d4 <plic_enable_irq>:

uint32_t plic_claim(int ctxid);
void plic_complete(int ctxid, int irqid);


void plic_enable_irq(int ctxid, int irqidx) {
   153d4:	fd010113          	addi	sp,sp,-48
   153d8:	02813423          	sd	s0,40(sp)
   153dc:	03010413          	addi	s0,sp,48
   153e0:	00050793          	mv	a5,a0
   153e4:	00058713          	mv	a4,a1
   153e8:	fcf42e23          	sw	a5,-36(s0)
   153ec:	00070793          	mv	a5,a4
   153f0:	fcf42c23          	sw	a5,-40(s0)
    plic_map *p = (plic_map *)ADDR_BUS0_XSLV_PLIC;
   153f4:	0c0007b7          	lui	a5,0xc000
   153f8:	fef43423          	sd	a5,-24(s0)
    p->src_prioirty[irqidx] = 0x1;    // 1=lowest prioirty; 0 = disabled
   153fc:	fe843703          	ld	a4,-24(s0)
   15400:	fd842783          	lw	a5,-40(s0)
   15404:	00279793          	slli	a5,a5,0x2
   15408:	00f707b3          	add	a5,a4,a5
   1540c:	00100713          	li	a4,1
   15410:	00e7a023          	sw	a4,0(a5) # c000000 <_end+0xbfe0764>
#ifdef PLIC_MODE_ENABLED
    p->src_mode[irqidx] = PLIC_MODE_RISING_EDGE;
   15414:	00300713          	li	a4,3
   15418:	fe843683          	ld	a3,-24(s0)
   1541c:	fd842603          	lw	a2,-40(s0)
   15420:	0007c7b7          	lui	a5,0x7c
   15424:	00f607b3          	add	a5,a2,a5
   15428:	00279793          	slli	a5,a5,0x2
   1542c:	00f687b3          	add	a5,a3,a5
   15430:	00e7a023          	sw	a4,0(a5) # 7c000 <_end+0x5c764>
#endif
    p->ctx_prio[ctxid].priority = 0;
   15434:	fe843703          	ld	a4,-24(s0)
   15438:	fdc42783          	lw	a5,-36(s0)
   1543c:	20078793          	addi	a5,a5,512
   15440:	00c79793          	slli	a5,a5,0xc
   15444:	00f707b3          	add	a5,a4,a5
   15448:	0007a023          	sw	zero,0(a5)
    p->ctx_ie[ctxid].irq_enable[irqidx/32] = 1ul << (irqidx & 0x1F);
   1544c:	fd842783          	lw	a5,-40(s0)
   15450:	01f7f793          	andi	a5,a5,31
   15454:	0007879b          	sext.w	a5,a5
   15458:	00100713          	li	a4,1
   1545c:	00f716b3          	sll	a3,a4,a5
   15460:	fd842783          	lw	a5,-40(s0)
   15464:	41f7d71b          	sraiw	a4,a5,0x1f
   15468:	01b7571b          	srliw	a4,a4,0x1b
   1546c:	00f707bb          	addw	a5,a4,a5
   15470:	4057d79b          	sraiw	a5,a5,0x5
   15474:	0007879b          	sext.w	a5,a5
   15478:	0006871b          	sext.w	a4,a3
   1547c:	fe843683          	ld	a3,-24(s0)
   15480:	fdc42603          	lw	a2,-36(s0)
   15484:	00561613          	slli	a2,a2,0x5
   15488:	00f60633          	add	a2,a2,a5
   1548c:	000017b7          	lui	a5,0x1
   15490:	80078793          	addi	a5,a5,-2048 # 800 <_ftext-0xf800>
   15494:	00f607b3          	add	a5,a2,a5
   15498:	00279793          	slli	a5,a5,0x2
   1549c:	00f687b3          	add	a5,a3,a5
   154a0:	00e7a023          	sw	a4,0(a5)
}
   154a4:	00000013          	nop
   154a8:	02813403          	ld	s0,40(sp)
   154ac:	03010113          	addi	sp,sp,48
   154b0:	00008067          	ret

00000000000154b4 <plic_is_pending>:

uint32_t plic_is_pending(int irqidx) {
   154b4:	fd010113          	addi	sp,sp,-48
   154b8:	02813423          	sd	s0,40(sp)
   154bc:	03010413          	addi	s0,sp,48
   154c0:	00050793          	mv	a5,a0
   154c4:	fcf42e23          	sw	a5,-36(s0)
    plic_map *p = (plic_map *)ADDR_BUS0_XSLV_PLIC;
   154c8:	0c0007b7          	lui	a5,0xc000
   154cc:	fef43423          	sd	a5,-24(s0)
    uint32_t ret = p->pending[irqidx/32];
   154d0:	fdc42783          	lw	a5,-36(s0)
   154d4:	41f7d71b          	sraiw	a4,a5,0x1f
   154d8:	01b7571b          	srliw	a4,a4,0x1b
   154dc:	00f707bb          	addw	a5,a4,a5
   154e0:	4057d79b          	sraiw	a5,a5,0x5
   154e4:	0007879b          	sext.w	a5,a5
   154e8:	fe843703          	ld	a4,-24(s0)
   154ec:	40078793          	addi	a5,a5,1024 # c000400 <_end+0xbfe0b64>
   154f0:	00279793          	slli	a5,a5,0x2
   154f4:	00f707b3          	add	a5,a4,a5
   154f8:	0007a783          	lw	a5,0(a5)
   154fc:	fef42223          	sw	a5,-28(s0)
    ret >>= (irqidx & 0x1F);
   15500:	fdc42783          	lw	a5,-36(s0)
   15504:	01f7f793          	andi	a5,a5,31
   15508:	0007879b          	sext.w	a5,a5
   1550c:	fe442703          	lw	a4,-28(s0)
   15510:	00f757bb          	srlw	a5,a4,a5
   15514:	fef42223          	sw	a5,-28(s0)
    ret &= 0x1;
   15518:	fe442783          	lw	a5,-28(s0)
   1551c:	0017f793          	andi	a5,a5,1
   15520:	fef42223          	sw	a5,-28(s0)
    return ret;
   15524:	fe442783          	lw	a5,-28(s0)
}
   15528:	00078513          	mv	a0,a5
   1552c:	02813403          	ld	s0,40(sp)
   15530:	03010113          	addi	sp,sp,48
   15534:	00008067          	ret

0000000000015538 <test_generate_interrupt>:


void test_generate_interrupt() {
   15538:	fe010113          	addi	sp,sp,-32
   1553c:	00813c23          	sd	s0,24(sp)
   15540:	02010413          	addi	s0,sp,32
    // Trigger interrupt 70 (self-test) by writing into RO register HWID:
    pnp_map *pnp = (pnp_map *)ADDR_BUS0_XSLV_PNP;
   15544:	100ff7b7          	lui	a5,0x100ff
   15548:	fef43423          	sd	a5,-24(s0)
    pnp->hwid = 0;
   1554c:	fe843783          	ld	a5,-24(s0)
   15550:	0007a023          	sw	zero,0(a5) # 100ff000 <_end+0x100df764>
}
   15554:	00000013          	nop
   15558:	01813403          	ld	s0,24(sp)
   1555c:	02010113          	addi	sp,sp,32
   15560:	00008067          	ret

0000000000015564 <test_plic>:


void test_plic(void) {
   15564:	fd010113          	addi	sp,sp,-48
   15568:	02113423          	sd	ra,40(sp)
   1556c:	02813023          	sd	s0,32(sp)
   15570:	03010413          	addi	s0,sp,48
    plic_map *p = (plic_map *)ADDR_BUS0_XSLV_PLIC;
   15574:	0c0007b7          	lui	a5,0xc000
   15578:	fef43423          	sd	a5,-24(s0)

    fw_disable_m_interrupts();
   1557c:	80dfd0ef          	jal	ra,12d88 <fw_disable_m_interrupts>
    fw_mie_enable(HART_IRQ_MEIP);
   15580:	00b00513          	li	a0,11
   15584:	ffffe097          	auipc	ra,0xffffe
   15588:	830080e7          	jalr	-2000(ra) # 12db4 <fw_mie_enable>

    plic_enable_irq(CTX_CPU0_M_MODE, PLIC_IRQ_PNP);
   1558c:	04600593          	li	a1,70
   15590:	00000513          	li	a0,0
   15594:	00000097          	auipc	ra,0x0
   15598:	e40080e7          	jalr	-448(ra) # 153d4 <plic_enable_irq>

    test_generate_interrupt();
   1559c:	00000097          	auipc	ra,0x0
   155a0:	f9c080e7          	jalr	-100(ra) # 15538 <test_generate_interrupt>

    if (plic_is_pending(PLIC_IRQ_PNP) == 0) {
   155a4:	04600513          	li	a0,70
   155a8:	f0dff0ef          	jal	ra,154b4 <plic_is_pending>
   155ac:	00050793          	mv	a5,a0
   155b0:	0007879b          	sext.w	a5,a5
   155b4:	02079663          	bnez	a5,155e0 <test_plic+0x7c>
        printf_uart("FAIL: pending[70/32]=%08x not triggered\r\n",
   155b8:	fe843703          	ld	a4,-24(s0)
   155bc:	000017b7          	lui	a5,0x1
   155c0:	00f707b3          	add	a5,a4,a5
   155c4:	0087a783          	lw	a5,8(a5) # 1008 <_ftext-0xeff8>
   155c8:	0007879b          	sext.w	a5,a5
   155cc:	00078593          	mv	a1,a5
   155d0:	0001e7b7          	lui	a5,0x1e
   155d4:	a2878513          	addi	a0,a5,-1496 # 1da28 <FCVT_WU_D_TESTS+0x3f0>
   155d8:	b78fd0ef          	jal	ra,12950 <printf_uart>
                     p->pending[PLIC_IRQ_PNP/32]);
        return;
   155dc:	0e00006f          	j	156bc <test_plic+0x158>
    }

    uint64_t mip;
    asm("csrr %0, mip" : "=r" (mip));
   155e0:	344027f3          	csrr	a5,mip
   155e4:	fef43023          	sd	a5,-32(s0)

    // Check mip[11] = meip
    if (((mip >> 11) & 0x1) == 0) {
   155e8:	fe043703          	ld	a4,-32(s0)
   155ec:	000017b7          	lui	a5,0x1
   155f0:	80078793          	addi	a5,a5,-2048 # 800 <_ftext-0xf800>
   155f4:	00f777b3          	and	a5,a4,a5
   155f8:	00079c63          	bnez	a5,15610 <test_plic+0xac>
        printf_uart("FAIL: %s\r\n", "mip[11] = 0");
   155fc:	0001e7b7          	lui	a5,0x1e
   15600:	a5878593          	addi	a1,a5,-1448 # 1da58 <FCVT_WU_D_TESTS+0x420>
   15604:	0001e7b7          	lui	a5,0x1e
   15608:	a6878513          	addi	a0,a5,-1432 # 1da68 <FCVT_WU_D_TESTS+0x430>
   1560c:	b44fd0ef          	jal	ra,12950 <printf_uart>
    }
    
    // Check claim index
    uint32_t irqid = plic_claim(CTX_CPU0_M_MODE);
   15610:	00000513          	li	a0,0
   15614:	d7dfb0ef          	jal	ra,11390 <plic_claim>
   15618:	00050793          	mv	a5,a0
   1561c:	fcf42e23          	sw	a5,-36(s0)
    if (irqid != PLIC_IRQ_PNP) {
   15620:	fdc42783          	lw	a5,-36(s0)
   15624:	0007871b          	sext.w	a4,a5
   15628:	04600793          	li	a5,70
   1562c:	00f70e63          	beq	a4,a5,15648 <test_plic+0xe4>
        printf_uart("FAIL: claim_complete=%08x\r\n", irqid);
   15630:	fdc42783          	lw	a5,-36(s0)
   15634:	00078593          	mv	a1,a5
   15638:	0001e7b7          	lui	a5,0x1e
   1563c:	a7878513          	addi	a0,a5,-1416 # 1da78 <FCVT_WU_D_TESTS+0x440>
   15640:	b10fd0ef          	jal	ra,12950 <printf_uart>
        return;
   15644:	0780006f          	j	156bc <test_plic+0x158>
    }

    // Check that pending bit was cleared
    if (plic_is_pending(PLIC_IRQ_PNP) != 0) {
   15648:	04600513          	li	a0,70
   1564c:	e69ff0ef          	jal	ra,154b4 <plic_is_pending>
   15650:	00050793          	mv	a5,a0
   15654:	0007879b          	sext.w	a5,a5
   15658:	02078663          	beqz	a5,15684 <test_plic+0x120>
        printf_uart("FAIL: pending[70/32]=%08x not zero\r\n",
   1565c:	fe843703          	ld	a4,-24(s0)
   15660:	000017b7          	lui	a5,0x1
   15664:	00f707b3          	add	a5,a4,a5
   15668:	0087a783          	lw	a5,8(a5) # 1008 <_ftext-0xeff8>
   1566c:	0007879b          	sext.w	a5,a5
   15670:	00078593          	mv	a1,a5
   15674:	0001e7b7          	lui	a5,0x1e
   15678:	a9878513          	addi	a0,a5,-1384 # 1da98 <FCVT_WU_D_TESTS+0x460>
   1567c:	ad4fd0ef          	jal	ra,12950 <printf_uart>
                     p->pending[PLIC_IRQ_PNP/32]);
        return;
   15680:	03c0006f          	j	156bc <test_plic+0x158>
    }

    // write complete
    plic_complete(CTX_CPU0_M_MODE, irqid);
   15684:	fdc42783          	lw	a5,-36(s0)
   15688:	00078593          	mv	a1,a5
   1568c:	00000513          	li	a0,0
   15690:	ffffc097          	auipc	ra,0xffffc
   15694:	d48080e7          	jalr	-696(ra) # 113d8 <plic_complete>
    printf_uart("PLIC . . . . . .%s", "PASS\r\n");
   15698:	0001e7b7          	lui	a5,0x1e
   1569c:	ac078593          	addi	a1,a5,-1344 # 1dac0 <FCVT_WU_D_TESTS+0x488>
   156a0:	0001e7b7          	lui	a5,0x1e
   156a4:	ac878513          	addi	a0,a5,-1336 # 1dac8 <FCVT_WU_D_TESTS+0x490>
   156a8:	aa8fd0ef          	jal	ra,12950 <printf_uart>

    fw_mie_disable(HART_IRQ_MEIP);
   156ac:	00b00513          	li	a0,11
   156b0:	f40fd0ef          	jal	ra,12df0 <fw_mie_disable>
    fw_enable_m_interrupts();
   156b4:	ffffd097          	auipc	ra,0xffffd
   156b8:	6a8080e7          	jalr	1704(ra) # 12d5c <fw_enable_m_interrupts>
}
   156bc:	02813083          	ld	ra,40(sp)
   156c0:	02013403          	ld	s0,32(sp)
   156c4:	03010113          	addi	sp,sp,48
   156c8:	00008067          	ret

00000000000156cc <get_dev_bar>:
static uint64_t get_dev_bar(pnp_map *pnp, uint16_t vid, uint16_t did) {
   156cc:	fb010113          	addi	sp,sp,-80
   156d0:	04813423          	sd	s0,72(sp)
   156d4:	05010413          	addi	s0,sp,80
   156d8:	faa43c23          	sd	a0,-72(s0)
   156dc:	00058793          	mv	a5,a1
   156e0:	00060713          	mv	a4,a2
   156e4:	faf41b23          	sh	a5,-74(s0)
   156e8:	00070793          	mv	a5,a4
   156ec:	faf41a23          	sh	a5,-76(s0)
    int slots_total = (pnp->cfg >> 8) & 0xFF;
   156f0:	fb843783          	ld	a5,-72(s0)
   156f4:	0087a783          	lw	a5,8(a5)
   156f8:	0087d79b          	srliw	a5,a5,0x8
   156fc:	0007879b          	sext.w	a5,a5
   15700:	0007879b          	sext.w	a5,a5
   15704:	0ff7f793          	andi	a5,a5,255
   15708:	fef42223          	sw	a5,-28(s0)
    int off = 0;
   1570c:	fe042623          	sw	zero,-20(s0)
    for (int i = 0; i < slots_total; i++) {
   15710:	fe042423          	sw	zero,-24(s0)
   15714:	09c0006f          	j	157b0 <get_dev_bar+0xe4>
        dcfg = *(dev_cfg_type *)&pnp->cfg_table[off];
   15718:	fec42783          	lw	a5,-20(s0)
   1571c:	04078793          	addi	a5,a5,64
   15720:	fb843703          	ld	a4,-72(s0)
   15724:	00f707b3          	add	a5,a4,a5
   15728:	0007b703          	ld	a4,0(a5)
   1572c:	fce43023          	sd	a4,-64(s0)
   15730:	0087b703          	ld	a4,8(a5)
   15734:	fce43423          	sd	a4,-56(s0)
   15738:	0107b703          	ld	a4,16(a5)
   1573c:	fce43823          	sd	a4,-48(s0)
   15740:	0187b783          	ld	a5,24(a5)
   15744:	fcf43c23          	sd	a5,-40(s0)
        off += sizeof(dcfg);
   15748:	fec42783          	lw	a5,-20(s0)
   1574c:	0207879b          	addiw	a5,a5,32
   15750:	0007879b          	sext.w	a5,a5
   15754:	fef42623          	sw	a5,-20(s0)
        if (dcfg.u.descrtype != PNP_CFG_TYPE_SLAVE) {
   15758:	fc144783          	lbu	a5,-63(s0)
   1575c:	0037f793          	andi	a5,a5,3
   15760:	0ff7f793          	andi	a5,a5,255
   15764:	00078713          	mv	a4,a5
   15768:	00200793          	li	a5,2
   1576c:	02f71a63          	bne	a4,a5,157a0 <get_dev_bar+0xd4>
        if (dcfg.u.vid == vid && dcfg.u.did == did) {
   15770:	fc645783          	lhu	a5,-58(s0)
   15774:	fb645703          	lhu	a4,-74(s0)
   15778:	0007071b          	sext.w	a4,a4
   1577c:	0007879b          	sext.w	a5,a5
   15780:	02f71263          	bne	a4,a5,157a4 <get_dev_bar+0xd8>
   15784:	fc445783          	lhu	a5,-60(s0)
   15788:	fb445703          	lhu	a4,-76(s0)
   1578c:	0007071b          	sext.w	a4,a4
   15790:	0007879b          	sext.w	a5,a5
   15794:	00f71863          	bne	a4,a5,157a4 <get_dev_bar+0xd8>
            return dcfg.u.addr_start;
   15798:	fd043783          	ld	a5,-48(s0)
   1579c:	02c0006f          	j	157c8 <get_dev_bar+0xfc>
            continue;
   157a0:	00000013          	nop
    for (int i = 0; i < slots_total; i++) {
   157a4:	fe842783          	lw	a5,-24(s0)
   157a8:	0017879b          	addiw	a5,a5,1
   157ac:	fef42423          	sw	a5,-24(s0)
   157b0:	fe842703          	lw	a4,-24(s0)
   157b4:	fe442783          	lw	a5,-28(s0)
   157b8:	0007071b          	sext.w	a4,a4
   157bc:	0007879b          	sext.w	a5,a5
   157c0:	f4f74ce3          	blt	a4,a5,15718 <get_dev_bar+0x4c>
    return DEV_NONE;
   157c4:	fff00793          	li	a5,-1
}
   157c8:	00078513          	mv	a0,a5
   157cc:	04813403          	ld	s0,72(sp)
   157d0:	05010113          	addi	sp,sp,80
   157d4:	00008067          	ret

00000000000157d8 <mpu_region_total>:
static int mpu_region_total() {
   157d8:	fe010113          	addi	sp,sp,-32
   157dc:	00813c23          	sd	s0,24(sp)
   157e0:	02010413          	addi	s0,sp,32
    uint64_t val = 0;
   157e4:	fe043423          	sd	zero,-24(s0)
    asm("csrr %0, 0xBC4" : "=r" (val));
   157e8:	bc4027f3          	csrr	a5,0xbc4
   157ec:	fef43423          	sd	a5,-24(s0)
    return (int)(val >> 8);
   157f0:	fe843783          	ld	a5,-24(s0)
   157f4:	0087d793          	srli	a5,a5,0x8
   157f8:	0007879b          	sext.w	a5,a5
}
   157fc:	00078513          	mv	a0,a5
   15800:	01813403          	ld	s0,24(sp)
   15804:	02010113          	addi	sp,sp,32
   15808:	00008067          	ret

000000000001580c <mpu_disable_region>:
static void mpu_disable_region(int idx) {
   1580c:	fd010113          	addi	sp,sp,-48
   15810:	02813423          	sd	s0,40(sp)
   15814:	03010413          	addi	s0,sp,48
   15818:	00050793          	mv	a5,a0
   1581c:	fcf42e23          	sw	a5,-36(s0)
    ctrl.value = 0;
   15820:	fe043423          	sd	zero,-24(s0)
    ctrl.bits.IDX = idx;
   15824:	fdc42783          	lw	a5,-36(s0)
   15828:	0ff7f793          	andi	a5,a5,255
   1582c:	fef404a3          	sb	a5,-23(s0)
    ctrl.bits.WE = 1;
   15830:	fe844783          	lbu	a5,-24(s0)
   15834:	f807e793          	ori	a5,a5,-128
   15838:	fef40423          	sb	a5,-24(s0)
    asm("csrw 0xBC4, %0" : :"r"(ctrl.value));
   1583c:	fe843783          	ld	a5,-24(s0)
   15840:	bc479073          	csrw	0xbc4,a5
}
   15844:	00000013          	nop
   15848:	02813403          	ld	s0,40(sp)
   1584c:	03010113          	addi	sp,sp,48
   15850:	00008067          	ret

0000000000015854 <mpu_enable_region>:
                       const char *rwx) {
   15854:	fb010113          	addi	sp,sp,-80
   15858:	04813423          	sd	s0,72(sp)
   1585c:	05010413          	addi	s0,sp,80
   15860:	00050793          	mv	a5,a0
   15864:	fcb43023          	sd	a1,-64(s0)
   15868:	fac43c23          	sd	a2,-72(s0)
   1586c:	fae43823          	sd	a4,-80(s0)
   15870:	fcf42623          	sw	a5,-52(s0)
   15874:	00068793          	mv	a5,a3
   15878:	fcf42423          	sw	a5,-56(s0)
    uint64_t mask = (~0ull) << 10;
   1587c:	c0000793          	li	a5,-1024
   15880:	fef43423          	sd	a5,-24(s0)
    const char *p = rwx;
   15884:	fb043783          	ld	a5,-80(s0)
   15888:	fef43023          	sd	a5,-32(s0)
    asm("csrw 0xBC2, %0" : :"r"(bar));
   1588c:	fc043783          	ld	a5,-64(s0)
   15890:	bc279073          	csrw	0xbc2,a5
    KB >>= 1;
   15894:	fb843783          	ld	a5,-72(s0)
   15898:	0017d793          	srli	a5,a5,0x1
   1589c:	faf43c23          	sd	a5,-72(s0)
    while (KB) {
   158a0:	01c0006f          	j	158bc <mpu_enable_region+0x68>
        mask <<= 1;
   158a4:	fe843783          	ld	a5,-24(s0)
   158a8:	00179793          	slli	a5,a5,0x1
   158ac:	fef43423          	sd	a5,-24(s0)
        KB >>= 1;
   158b0:	fb843783          	ld	a5,-72(s0)
   158b4:	0017d793          	srli	a5,a5,0x1
   158b8:	faf43c23          	sd	a5,-72(s0)
    while (KB) {
   158bc:	fb843783          	ld	a5,-72(s0)
   158c0:	fe0792e3          	bnez	a5,158a4 <mpu_enable_region+0x50>
    asm("csrw 0xBC3, %0" : :"r"(mask));
   158c4:	fe843783          	ld	a5,-24(s0)
   158c8:	bc379073          	csrw	0xbc3,a5
    ctrl.value = 0;
   158cc:	fc043c23          	sd	zero,-40(s0)
    ctrl.bits.IDX = idx;
   158d0:	fcc42783          	lw	a5,-52(s0)
   158d4:	0ff7f793          	andi	a5,a5,255
   158d8:	fcf40ca3          	sb	a5,-39(s0)
    ctrl.bits.ENA = 1;
   158dc:	fd844783          	lbu	a5,-40(s0)
   158e0:	0107e793          	ori	a5,a5,16
   158e4:	fcf40c23          	sb	a5,-40(s0)
    ctrl.bits.CACHABLE = cached;
   158e8:	fc842783          	lw	a5,-56(s0)
   158ec:	0017f793          	andi	a5,a5,1
   158f0:	0ff7f793          	andi	a5,a5,255
   158f4:	0017f793          	andi	a5,a5,1
   158f8:	0037969b          	slliw	a3,a5,0x3
   158fc:	fd844783          	lbu	a5,-40(s0)
   15900:	ff77f793          	andi	a5,a5,-9
   15904:	00078713          	mv	a4,a5
   15908:	00068793          	mv	a5,a3
   1590c:	00f767b3          	or	a5,a4,a5
   15910:	fcf40c23          	sb	a5,-40(s0)
    ctrl.bits.WE = 1; // write into MPU
   15914:	fd844783          	lbu	a5,-40(s0)
   15918:	f807e793          	ori	a5,a5,-128
   1591c:	fcf40c23          	sb	a5,-40(s0)
    while (*p) {
   15920:	0700006f          	j	15990 <mpu_enable_region+0x13c>
        if (*p == 'r') {
   15924:	fe043783          	ld	a5,-32(s0)
   15928:	0007c783          	lbu	a5,0(a5)
   1592c:	00078713          	mv	a4,a5
   15930:	07200793          	li	a5,114
   15934:	00f71863          	bne	a4,a5,15944 <mpu_enable_region+0xf0>
            ctrl.bits.RD = 1;
   15938:	fd844783          	lbu	a5,-40(s0)
   1593c:	0027e793          	ori	a5,a5,2
   15940:	fcf40c23          	sb	a5,-40(s0)
        if (*p == 'w') {
   15944:	fe043783          	ld	a5,-32(s0)
   15948:	0007c783          	lbu	a5,0(a5)
   1594c:	00078713          	mv	a4,a5
   15950:	07700793          	li	a5,119
   15954:	00f71863          	bne	a4,a5,15964 <mpu_enable_region+0x110>
            ctrl.bits.WR = 1;
   15958:	fd844783          	lbu	a5,-40(s0)
   1595c:	0017e793          	ori	a5,a5,1
   15960:	fcf40c23          	sb	a5,-40(s0)
        if (*p == 'x') {
   15964:	fe043783          	ld	a5,-32(s0)
   15968:	0007c783          	lbu	a5,0(a5)
   1596c:	00078713          	mv	a4,a5
   15970:	07800793          	li	a5,120
   15974:	00f71863          	bne	a4,a5,15984 <mpu_enable_region+0x130>
            ctrl.bits.EXEC = 1;
   15978:	fd844783          	lbu	a5,-40(s0)
   1597c:	0047e793          	ori	a5,a5,4
   15980:	fcf40c23          	sb	a5,-40(s0)
        p++;
   15984:	fe043783          	ld	a5,-32(s0)
   15988:	00178793          	addi	a5,a5,1
   1598c:	fef43023          	sd	a5,-32(s0)
    while (*p) {
   15990:	fe043783          	ld	a5,-32(s0)
   15994:	0007c783          	lbu	a5,0(a5)
   15998:	f80796e3          	bnez	a5,15924 <mpu_enable_region+0xd0>
    asm("csrw 0xBC4, %0" : :"r"(ctrl.value));
   1599c:	fd843783          	ld	a5,-40(s0)
   159a0:	bc479073          	csrw	0xbc4,a5
}
   159a4:	00000013          	nop
   159a8:	04813403          	ld	s0,72(sp)
   159ac:	05010113          	addi	sp,sp,80
   159b0:	00008067          	ret

00000000000159b4 <test_mtimer>:
#include <axi_maps.h>
#include "fw_api.h"

static const char TEST_MTIMER_NAME[8] = "mtimer";

void test_mtimer(void) {
   159b4:	fc010113          	addi	sp,sp,-64
   159b8:	02113c23          	sd	ra,56(sp)
   159bc:	02813823          	sd	s0,48(sp)
   159c0:	02913423          	sd	s1,40(sp)
   159c4:	04010413          	addi	s0,sp,64
    pnp_map *pnp = (pnp_map *)ADDR_BUS0_XSLV_PNP;
   159c8:	100ff7b7          	lui	a5,0x100ff
   159cc:	fcf43c23          	sd	a5,-40(s0)
    clint_map *clint = (clint_map *)ADDR_BUS0_XSLV_CLINT;
   159d0:	020007b7          	lui	a5,0x2000
   159d4:	fcf43823          	sd	a5,-48(s0)

    fw_disable_m_interrupts();
   159d8:	ffffd097          	auipc	ra,0xffffd
   159dc:	3b0080e7          	jalr	944(ra) # 12d88 <fw_disable_m_interrupts>
    fw_mie_enable(HART_IRQ_MTIP);
   159e0:	00700513          	li	a0,7
   159e4:	bd0fd0ef          	jal	ra,12db4 <fw_mie_enable>

    clint->mtime = 0ull;
   159e8:	fd043703          	ld	a4,-48(s0)
   159ec:	0000c7b7          	lui	a5,0xc
   159f0:	00f707b3          	add	a5,a4,a5
   159f4:	fe07bc23          	sd	zero,-8(a5) # bff8 <_ftext-0x4008>
    uint64_t t1 = clint->mtime;
   159f8:	fd043703          	ld	a4,-48(s0)
   159fc:	0000c7b7          	lui	a5,0xc
   15a00:	00f707b3          	add	a5,a4,a5
   15a04:	ff87b783          	ld	a5,-8(a5) # bff8 <_ftext-0x4008>
   15a08:	fcf43423          	sd	a5,-56(s0)
    uint64_t t2 = clint->mtime;
   15a0c:	fd043703          	ld	a4,-48(s0)
   15a10:	0000c7b7          	lui	a5,0xc
   15a14:	00f707b3          	add	a5,a4,a5
   15a18:	ff87b783          	ld	a5,-8(a5) # bff8 <_ftext-0x4008>
   15a1c:	fcf43023          	sd	a5,-64(s0)
    if (t2 <= t1) {
   15a20:	fc043703          	ld	a4,-64(s0)
   15a24:	fc843783          	ld	a5,-56(s0)
   15a28:	02e7e063          	bltu	a5,a4,15a48 <test_mtimer+0x94>
        printf_uart("FAIL: mtimer not clocking: %d, %d\r\n", t1, t2);
   15a2c:	fc043603          	ld	a2,-64(s0)
   15a30:	fc843583          	ld	a1,-56(s0)
   15a34:	0001e7b7          	lui	a5,0x1e
   15a38:	ae078513          	addi	a0,a5,-1312 # 1dae0 <FCVT_WU_D_TESTS+0x4a8>
   15a3c:	ffffd097          	auipc	ra,0xffffd
   15a40:	f14080e7          	jalr	-236(ra) # 12950 <printf_uart>
        return;
   15a44:	0900006f          	j	15ad4 <test_mtimer+0x120>
    }

    pnp->fwdbg1 = 0;
   15a48:	fd843783          	ld	a5,-40(s0)
   15a4c:	0207b423          	sd	zero,40(a5)
    clint->mtimecmp[fw_get_cpuid()] = clint->mtime + 3000;
   15a50:	fd043703          	ld	a4,-48(s0)
   15a54:	0000c7b7          	lui	a5,0xc
   15a58:	00f707b3          	add	a5,a4,a5
   15a5c:	ff87b483          	ld	s1,-8(a5) # bff8 <_ftext-0x4008>
   15a60:	ab4fd0ef          	jal	ra,12d14 <fw_get_cpuid>
   15a64:	00050793          	mv	a5,a0
   15a68:	00078613          	mv	a2,a5
   15a6c:	000017b7          	lui	a5,0x1
   15a70:	bb878793          	addi	a5,a5,-1096 # bb8 <_ftext-0xf448>
   15a74:	00f48733          	add	a4,s1,a5
   15a78:	fd043683          	ld	a3,-48(s0)
   15a7c:	000017b7          	lui	a5,0x1
   15a80:	80078793          	addi	a5,a5,-2048 # 800 <_ftext-0xf800>
   15a84:	00f607b3          	add	a5,a2,a5
   15a88:	00379793          	slli	a5,a5,0x3
   15a8c:	00f687b3          	add	a5,a3,a5
   15a90:	00e7b023          	sd	a4,0(a5)

    fw_enable_m_interrupts();
   15a94:	ac8fd0ef          	jal	ra,12d5c <fw_enable_m_interrupts>
    while (pnp->fwdbg1 == 0) {}               // should be update int irq handler
   15a98:	00000013          	nop
   15a9c:	fd843783          	ld	a5,-40(s0)
   15aa0:	0287b783          	ld	a5,40(a5)
   15aa4:	fe078ce3          	beqz	a5,15a9c <test_mtimer+0xe8>
    fw_disable_m_interrupts();
   15aa8:	ffffd097          	auipc	ra,0xffffd
   15aac:	2e0080e7          	jalr	736(ra) # 12d88 <fw_disable_m_interrupts>

    fw_mie_disable(HART_IRQ_MTIP);
   15ab0:	00700513          	li	a0,7
   15ab4:	ffffd097          	auipc	ra,0xffffd
   15ab8:	33c080e7          	jalr	828(ra) # 12df0 <fw_mie_disable>

    printf_uart("MTIMER . . . . .%s", "PASS\r\n");
   15abc:	0001e7b7          	lui	a5,0x1e
   15ac0:	b0878593          	addi	a1,a5,-1272 # 1db08 <FCVT_WU_D_TESTS+0x4d0>
   15ac4:	0001e7b7          	lui	a5,0x1e
   15ac8:	b1078513          	addi	a0,a5,-1264 # 1db10 <FCVT_WU_D_TESTS+0x4d8>
   15acc:	ffffd097          	auipc	ra,0xffffd
   15ad0:	e84080e7          	jalr	-380(ra) # 12950 <printf_uart>
}
   15ad4:	03813083          	ld	ra,56(sp)
   15ad8:	03013403          	ld	s0,48(sp)
   15adc:	02813483          	ld	s1,40(sp)
   15ae0:	04010113          	addi	sp,sp,64
   15ae4:	00008067          	ret
   15ae8:	0000                	unimp
	...

0000000000015aec <get_dev_bar>:
static uint64_t get_dev_bar(pnp_map *pnp, uint16_t vid, uint16_t did) {
   15aec:	fb010113          	addi	sp,sp,-80
   15af0:	04813423          	sd	s0,72(sp)
   15af4:	05010413          	addi	s0,sp,80
   15af8:	faa43c23          	sd	a0,-72(s0)
   15afc:	00058793          	mv	a5,a1
   15b00:	00060713          	mv	a4,a2
   15b04:	faf41b23          	sh	a5,-74(s0)
   15b08:	00070793          	mv	a5,a4
   15b0c:	faf41a23          	sh	a5,-76(s0)
    int slots_total = (pnp->cfg >> 8) & 0xFF;
   15b10:	fb843783          	ld	a5,-72(s0)
   15b14:	0087a783          	lw	a5,8(a5)
   15b18:	0087d79b          	srliw	a5,a5,0x8
   15b1c:	0007879b          	sext.w	a5,a5
   15b20:	0007879b          	sext.w	a5,a5
   15b24:	0ff7f793          	andi	a5,a5,255
   15b28:	fef42223          	sw	a5,-28(s0)
    int off = 0;
   15b2c:	fe042623          	sw	zero,-20(s0)
    for (int i = 0; i < slots_total; i++) {
   15b30:	fe042423          	sw	zero,-24(s0)
   15b34:	09c0006f          	j	15bd0 <get_dev_bar+0xe4>
        dcfg = *(dev_cfg_type *)&pnp->cfg_table[off];
   15b38:	fec42783          	lw	a5,-20(s0)
   15b3c:	04078793          	addi	a5,a5,64
   15b40:	fb843703          	ld	a4,-72(s0)
   15b44:	00f707b3          	add	a5,a4,a5
   15b48:	0007b703          	ld	a4,0(a5)
   15b4c:	fce43023          	sd	a4,-64(s0)
   15b50:	0087b703          	ld	a4,8(a5)
   15b54:	fce43423          	sd	a4,-56(s0)
   15b58:	0107b703          	ld	a4,16(a5)
   15b5c:	fce43823          	sd	a4,-48(s0)
   15b60:	0187b783          	ld	a5,24(a5)
   15b64:	fcf43c23          	sd	a5,-40(s0)
        off += sizeof(dcfg);
   15b68:	fec42783          	lw	a5,-20(s0)
   15b6c:	0207879b          	addiw	a5,a5,32
   15b70:	0007879b          	sext.w	a5,a5
   15b74:	fef42623          	sw	a5,-20(s0)
        if (dcfg.u.descrtype != PNP_CFG_TYPE_SLAVE) {
   15b78:	fc144783          	lbu	a5,-63(s0)
   15b7c:	0037f793          	andi	a5,a5,3
   15b80:	0ff7f793          	andi	a5,a5,255
   15b84:	00078713          	mv	a4,a5
   15b88:	00200793          	li	a5,2
   15b8c:	02f71a63          	bne	a4,a5,15bc0 <get_dev_bar+0xd4>
        if (dcfg.u.vid == vid && dcfg.u.did == did) {
   15b90:	fc645783          	lhu	a5,-58(s0)
   15b94:	fb645703          	lhu	a4,-74(s0)
   15b98:	0007071b          	sext.w	a4,a4
   15b9c:	0007879b          	sext.w	a5,a5
   15ba0:	02f71263          	bne	a4,a5,15bc4 <get_dev_bar+0xd8>
   15ba4:	fc445783          	lhu	a5,-60(s0)
   15ba8:	fb445703          	lhu	a4,-76(s0)
   15bac:	0007071b          	sext.w	a4,a4
   15bb0:	0007879b          	sext.w	a5,a5
   15bb4:	00f71863          	bne	a4,a5,15bc4 <get_dev_bar+0xd8>
            return dcfg.u.addr_start;
   15bb8:	fd043783          	ld	a5,-48(s0)
   15bbc:	02c0006f          	j	15be8 <get_dev_bar+0xfc>
            continue;
   15bc0:	00000013          	nop
    for (int i = 0; i < slots_total; i++) {
   15bc4:	fe842783          	lw	a5,-24(s0)
   15bc8:	0017879b          	addiw	a5,a5,1
   15bcc:	fef42423          	sw	a5,-24(s0)
   15bd0:	fe842703          	lw	a4,-24(s0)
   15bd4:	fe442783          	lw	a5,-28(s0)
   15bd8:	0007071b          	sext.w	a4,a4
   15bdc:	0007879b          	sext.w	a5,a5
   15be0:	f4f74ce3          	blt	a4,a5,15b38 <get_dev_bar+0x4c>
    return DEV_NONE;
   15be4:	fff00793          	li	a5,-1
}
   15be8:	00078513          	mv	a0,a5
   15bec:	04813403          	ld	s0,72(sp)
   15bf0:	05010113          	addi	sp,sp,80
   15bf4:	00008067          	ret

0000000000015bf8 <mpu_region_total>:
static int mpu_region_total() {
   15bf8:	fe010113          	addi	sp,sp,-32
   15bfc:	00813c23          	sd	s0,24(sp)
   15c00:	02010413          	addi	s0,sp,32
    uint64_t val = 0;
   15c04:	fe043423          	sd	zero,-24(s0)
    asm("csrr %0, 0xBC4" : "=r" (val));
   15c08:	bc4027f3          	csrr	a5,0xbc4
   15c0c:	fef43423          	sd	a5,-24(s0)
    return (int)(val >> 8);
   15c10:	fe843783          	ld	a5,-24(s0)
   15c14:	0087d793          	srli	a5,a5,0x8
   15c18:	0007879b          	sext.w	a5,a5
}
   15c1c:	00078513          	mv	a0,a5
   15c20:	01813403          	ld	s0,24(sp)
   15c24:	02010113          	addi	sp,sp,32
   15c28:	00008067          	ret

0000000000015c2c <mpu_disable_region>:
static void mpu_disable_region(int idx) {
   15c2c:	fd010113          	addi	sp,sp,-48
   15c30:	02813423          	sd	s0,40(sp)
   15c34:	03010413          	addi	s0,sp,48
   15c38:	00050793          	mv	a5,a0
   15c3c:	fcf42e23          	sw	a5,-36(s0)
    ctrl.value = 0;
   15c40:	fe043423          	sd	zero,-24(s0)
    ctrl.bits.IDX = idx;
   15c44:	fdc42783          	lw	a5,-36(s0)
   15c48:	0ff7f793          	andi	a5,a5,255
   15c4c:	fef404a3          	sb	a5,-23(s0)
    ctrl.bits.WE = 1;
   15c50:	fe844783          	lbu	a5,-24(s0)
   15c54:	f807e793          	ori	a5,a5,-128
   15c58:	fef40423          	sb	a5,-24(s0)
    asm("csrw 0xBC4, %0" : :"r"(ctrl.value));
   15c5c:	fe843783          	ld	a5,-24(s0)
   15c60:	bc479073          	csrw	0xbc4,a5
}
   15c64:	00000013          	nop
   15c68:	02813403          	ld	s0,40(sp)
   15c6c:	03010113          	addi	sp,sp,48
   15c70:	00008067          	ret

0000000000015c74 <mpu_enable_region>:
                       const char *rwx) {
   15c74:	fb010113          	addi	sp,sp,-80
   15c78:	04813423          	sd	s0,72(sp)
   15c7c:	05010413          	addi	s0,sp,80
   15c80:	00050793          	mv	a5,a0
   15c84:	fcb43023          	sd	a1,-64(s0)
   15c88:	fac43c23          	sd	a2,-72(s0)
   15c8c:	fae43823          	sd	a4,-80(s0)
   15c90:	fcf42623          	sw	a5,-52(s0)
   15c94:	00068793          	mv	a5,a3
   15c98:	fcf42423          	sw	a5,-56(s0)
    uint64_t mask = (~0ull) << 10;
   15c9c:	c0000793          	li	a5,-1024
   15ca0:	fef43423          	sd	a5,-24(s0)
    const char *p = rwx;
   15ca4:	fb043783          	ld	a5,-80(s0)
   15ca8:	fef43023          	sd	a5,-32(s0)
    asm("csrw 0xBC2, %0" : :"r"(bar));
   15cac:	fc043783          	ld	a5,-64(s0)
   15cb0:	bc279073          	csrw	0xbc2,a5
    KB >>= 1;
   15cb4:	fb843783          	ld	a5,-72(s0)
   15cb8:	0017d793          	srli	a5,a5,0x1
   15cbc:	faf43c23          	sd	a5,-72(s0)
    while (KB) {
   15cc0:	01c0006f          	j	15cdc <mpu_enable_region+0x68>
        mask <<= 1;
   15cc4:	fe843783          	ld	a5,-24(s0)
   15cc8:	00179793          	slli	a5,a5,0x1
   15ccc:	fef43423          	sd	a5,-24(s0)
        KB >>= 1;
   15cd0:	fb843783          	ld	a5,-72(s0)
   15cd4:	0017d793          	srli	a5,a5,0x1
   15cd8:	faf43c23          	sd	a5,-72(s0)
    while (KB) {
   15cdc:	fb843783          	ld	a5,-72(s0)
   15ce0:	fe0792e3          	bnez	a5,15cc4 <mpu_enable_region+0x50>
    asm("csrw 0xBC3, %0" : :"r"(mask));
   15ce4:	fe843783          	ld	a5,-24(s0)
   15ce8:	bc379073          	csrw	0xbc3,a5
    ctrl.value = 0;
   15cec:	fc043c23          	sd	zero,-40(s0)
    ctrl.bits.IDX = idx;
   15cf0:	fcc42783          	lw	a5,-52(s0)
   15cf4:	0ff7f793          	andi	a5,a5,255
   15cf8:	fcf40ca3          	sb	a5,-39(s0)
    ctrl.bits.ENA = 1;
   15cfc:	fd844783          	lbu	a5,-40(s0)
   15d00:	0107e793          	ori	a5,a5,16
   15d04:	fcf40c23          	sb	a5,-40(s0)
    ctrl.bits.CACHABLE = cached;
   15d08:	fc842783          	lw	a5,-56(s0)
   15d0c:	0017f793          	andi	a5,a5,1
   15d10:	0ff7f793          	andi	a5,a5,255
   15d14:	0017f793          	andi	a5,a5,1
   15d18:	0037969b          	slliw	a3,a5,0x3
   15d1c:	fd844783          	lbu	a5,-40(s0)
   15d20:	ff77f793          	andi	a5,a5,-9
   15d24:	00078713          	mv	a4,a5
   15d28:	00068793          	mv	a5,a3
   15d2c:	00f767b3          	or	a5,a4,a5
   15d30:	fcf40c23          	sb	a5,-40(s0)
    ctrl.bits.WE = 1; // write into MPU
   15d34:	fd844783          	lbu	a5,-40(s0)
   15d38:	f807e793          	ori	a5,a5,-128
   15d3c:	fcf40c23          	sb	a5,-40(s0)
    while (*p) {
   15d40:	0700006f          	j	15db0 <mpu_enable_region+0x13c>
        if (*p == 'r') {
   15d44:	fe043783          	ld	a5,-32(s0)
   15d48:	0007c783          	lbu	a5,0(a5)
   15d4c:	00078713          	mv	a4,a5
   15d50:	07200793          	li	a5,114
   15d54:	00f71863          	bne	a4,a5,15d64 <mpu_enable_region+0xf0>
            ctrl.bits.RD = 1;
   15d58:	fd844783          	lbu	a5,-40(s0)
   15d5c:	0027e793          	ori	a5,a5,2
   15d60:	fcf40c23          	sb	a5,-40(s0)
        if (*p == 'w') {
   15d64:	fe043783          	ld	a5,-32(s0)
   15d68:	0007c783          	lbu	a5,0(a5)
   15d6c:	00078713          	mv	a4,a5
   15d70:	07700793          	li	a5,119
   15d74:	00f71863          	bne	a4,a5,15d84 <mpu_enable_region+0x110>
            ctrl.bits.WR = 1;
   15d78:	fd844783          	lbu	a5,-40(s0)
   15d7c:	0017e793          	ori	a5,a5,1
   15d80:	fcf40c23          	sb	a5,-40(s0)
        if (*p == 'x') {
   15d84:	fe043783          	ld	a5,-32(s0)
   15d88:	0007c783          	lbu	a5,0(a5)
   15d8c:	00078713          	mv	a4,a5
   15d90:	07800793          	li	a5,120
   15d94:	00f71863          	bne	a4,a5,15da4 <mpu_enable_region+0x130>
            ctrl.bits.EXEC = 1;
   15d98:	fd844783          	lbu	a5,-40(s0)
   15d9c:	0047e793          	ori	a5,a5,4
   15da0:	fcf40c23          	sb	a5,-40(s0)
        p++;
   15da4:	fe043783          	ld	a5,-32(s0)
   15da8:	00178793          	addi	a5,a5,1
   15dac:	fef43023          	sd	a5,-32(s0)
    while (*p) {
   15db0:	fe043783          	ld	a5,-32(s0)
   15db4:	0007c783          	lbu	a5,0(a5)
   15db8:	f80796e3          	bnez	a5,15d44 <mpu_enable_region+0xd0>
    asm("csrw 0xBC4, %0" : :"r"(ctrl.value));
   15dbc:	fd843783          	ld	a5,-40(s0)
   15dc0:	bc479073          	csrw	0xbc4,a5
}
   15dc4:	00000013          	nop
   15dc8:	04813403          	ld	s0,72(sp)
   15dcc:	05010113          	addi	sp,sp,80
   15dd0:	00008067          	ret

0000000000015dd4 <test_swirq>:
#include <axi_maps.h>
#include "fw_api.h"

static const char TEST_SWIRQ_NAME[8] = "swirq";

void test_swirq(void) {
   15dd4:	fd010113          	addi	sp,sp,-48
   15dd8:	02113423          	sd	ra,40(sp)
   15ddc:	02813023          	sd	s0,32(sp)
   15de0:	03010413          	addi	s0,sp,48
    pnp_map *pnp = (pnp_map *)ADDR_BUS0_XSLV_PNP;
   15de4:	100ff7b7          	lui	a5,0x100ff
   15de8:	fef43423          	sd	a5,-24(s0)
    clint_map *clint = (clint_map *)ADDR_BUS0_XSLV_CLINT;
   15dec:	020007b7          	lui	a5,0x2000
   15df0:	fef43023          	sd	a5,-32(s0)
    uint64_t msie = 0x1ull << 3;
   15df4:	00800793          	li	a5,8
   15df8:	fcf43c23          	sd	a5,-40(s0)
    uint64_t mip;

    fw_disable_m_interrupts();
   15dfc:	ffffd097          	auipc	ra,0xffffd
   15e00:	f8c080e7          	jalr	-116(ra) # 12d88 <fw_disable_m_interrupts>
 
    fw_mie_enable(HART_IRQ_MSIP);
   15e04:	00300513          	li	a0,3
   15e08:	fadfc0ef          	jal	ra,12db4 <fw_mie_enable>

    clint->msip[fw_get_cpuid()] = 0x1;
   15e0c:	f09fc0ef          	jal	ra,12d14 <fw_get_cpuid>
   15e10:	00050793          	mv	a5,a0
   15e14:	fe043703          	ld	a4,-32(s0)
   15e18:	00279793          	slli	a5,a5,0x2
   15e1c:	00f707b3          	add	a5,a4,a5
   15e20:	00100713          	li	a4,1
   15e24:	00e7a023          	sw	a4,0(a5) # 2000000 <_end+0x1fe0764>

    // It is necessary to implement memory barrier because
    // memory access could be postponed relative next CSR read:
    pnp->fwdbg1 = 0;
   15e28:	fe843783          	ld	a5,-24(s0)
   15e2c:	0207b423          	sd	zero,40(a5)
    while (pnp->fwdbg1 != 0) {
   15e30:	00c0006f          	j	15e3c <test_swirq+0x68>
        // Instead of membarier use this uncached read-write
        pnp->fwdbg1 = 0;
   15e34:	fe843783          	ld	a5,-24(s0)
   15e38:	0207b423          	sd	zero,40(a5)
    while (pnp->fwdbg1 != 0) {
   15e3c:	fe843783          	ld	a5,-24(s0)
   15e40:	0287b783          	ld	a5,40(a5)
   15e44:	fe0798e3          	bnez	a5,15e34 <test_swirq+0x60>
    }

    // Check mip[3] = msip
    asm("csrr %0, mip" : "=r" (mip));
   15e48:	344027f3          	csrr	a5,mip
   15e4c:	fcf43823          	sd	a5,-48(s0)
    if (((mip >> 3) & 0x1) == 0) {
   15e50:	fd043783          	ld	a5,-48(s0)
   15e54:	0087f793          	andi	a5,a5,8
   15e58:	00079e63          	bnez	a5,15e74 <test_swirq+0xa0>
        printf_uart("FAIL: %s\r\n", "mip[3] = 0");
   15e5c:	0001e7b7          	lui	a5,0x1e
   15e60:	b2878593          	addi	a1,a5,-1240 # 1db28 <FCVT_WU_D_TESTS+0x4f0>
   15e64:	0001e7b7          	lui	a5,0x1e
   15e68:	b3878513          	addi	a0,a5,-1224 # 1db38 <FCVT_WU_D_TESTS+0x500>
   15e6c:	ffffd097          	auipc	ra,0xffffd
   15e70:	ae4080e7          	jalr	-1308(ra) # 12950 <printf_uart>
    }

    fw_enable_m_interrupts();
   15e74:	ee9fc0ef          	jal	ra,12d5c <fw_enable_m_interrupts>

    while (pnp->fwdbg1 == 0) {}               // should be update int irq handler
   15e78:	00000013          	nop
   15e7c:	fe843783          	ld	a5,-24(s0)
   15e80:	0287b783          	ld	a5,40(a5)
   15e84:	fe078ce3          	beqz	a5,15e7c <test_swirq+0xa8>

    fw_mie_disable(HART_IRQ_MSIP);
   15e88:	00300513          	li	a0,3
   15e8c:	ffffd097          	auipc	ra,0xffffd
   15e90:	f64080e7          	jalr	-156(ra) # 12df0 <fw_mie_disable>

    if (pnp->fwdbg1 == MAGIC_SWIRQ_TEST_NUMBER) {
   15e94:	fe843783          	ld	a5,-24(s0)
   15e98:	0287b703          	ld	a4,40(a5)
   15e9c:	0001e7b7          	lui	a5,0x1e
   15ea0:	b707b783          	ld	a5,-1168(a5) # 1db70 <FCVT_WU_D_TESTS+0x538>
   15ea4:	02f71063          	bne	a4,a5,15ec4 <test_swirq+0xf0>
        printf_uart("SWIRQ. . . . . .%s", "PASS\r\n");
   15ea8:	0001e7b7          	lui	a5,0x1e
   15eac:	b4878593          	addi	a1,a5,-1208 # 1db48 <FCVT_WU_D_TESTS+0x510>
   15eb0:	0001e7b7          	lui	a5,0x1e
   15eb4:	b5078513          	addi	a0,a5,-1200 # 1db50 <FCVT_WU_D_TESTS+0x518>
   15eb8:	ffffd097          	auipc	ra,0xffffd
   15ebc:	a98080e7          	jalr	-1384(ra) # 12950 <printf_uart>
    } else {
        printf_uart("SWIRQ. . . . . .%s", "FAIL\r\n");
    }

}
   15ec0:	01c0006f          	j	15edc <test_swirq+0x108>
        printf_uart("SWIRQ. . . . . .%s", "FAIL\r\n");
   15ec4:	0001e7b7          	lui	a5,0x1e
   15ec8:	b6878593          	addi	a1,a5,-1176 # 1db68 <FCVT_WU_D_TESTS+0x530>
   15ecc:	0001e7b7          	lui	a5,0x1e
   15ed0:	b5078513          	addi	a0,a5,-1200 # 1db50 <FCVT_WU_D_TESTS+0x518>
   15ed4:	ffffd097          	auipc	ra,0xffffd
   15ed8:	a7c080e7          	jalr	-1412(ra) # 12950 <printf_uart>
}
   15edc:	00000013          	nop
   15ee0:	02813083          	ld	ra,40(sp)
   15ee4:	02013403          	ld	s0,32(sp)
   15ee8:	03010113          	addi	sp,sp,48
   15eec:	00008067          	ret
   15ef0:	0000                	unimp
	...

0000000000015ef4 <get_dev_bar>:
static uint64_t get_dev_bar(pnp_map *pnp, uint16_t vid, uint16_t did) {
   15ef4:	fb010113          	addi	sp,sp,-80
   15ef8:	04813423          	sd	s0,72(sp)
   15efc:	05010413          	addi	s0,sp,80
   15f00:	faa43c23          	sd	a0,-72(s0)
   15f04:	00058793          	mv	a5,a1
   15f08:	00060713          	mv	a4,a2
   15f0c:	faf41b23          	sh	a5,-74(s0)
   15f10:	00070793          	mv	a5,a4
   15f14:	faf41a23          	sh	a5,-76(s0)
    int slots_total = (pnp->cfg >> 8) & 0xFF;
   15f18:	fb843783          	ld	a5,-72(s0)
   15f1c:	0087a783          	lw	a5,8(a5)
   15f20:	0087d79b          	srliw	a5,a5,0x8
   15f24:	0007879b          	sext.w	a5,a5
   15f28:	0007879b          	sext.w	a5,a5
   15f2c:	0ff7f793          	andi	a5,a5,255
   15f30:	fef42223          	sw	a5,-28(s0)
    int off = 0;
   15f34:	fe042623          	sw	zero,-20(s0)
    for (int i = 0; i < slots_total; i++) {
   15f38:	fe042423          	sw	zero,-24(s0)
   15f3c:	09c0006f          	j	15fd8 <get_dev_bar+0xe4>
        dcfg = *(dev_cfg_type *)&pnp->cfg_table[off];
   15f40:	fec42783          	lw	a5,-20(s0)
   15f44:	04078793          	addi	a5,a5,64
   15f48:	fb843703          	ld	a4,-72(s0)
   15f4c:	00f707b3          	add	a5,a4,a5
   15f50:	0007b703          	ld	a4,0(a5)
   15f54:	fce43023          	sd	a4,-64(s0)
   15f58:	0087b703          	ld	a4,8(a5)
   15f5c:	fce43423          	sd	a4,-56(s0)
   15f60:	0107b703          	ld	a4,16(a5)
   15f64:	fce43823          	sd	a4,-48(s0)
   15f68:	0187b783          	ld	a5,24(a5)
   15f6c:	fcf43c23          	sd	a5,-40(s0)
        off += sizeof(dcfg);
   15f70:	fec42783          	lw	a5,-20(s0)
   15f74:	0207879b          	addiw	a5,a5,32
   15f78:	0007879b          	sext.w	a5,a5
   15f7c:	fef42623          	sw	a5,-20(s0)
        if (dcfg.u.descrtype != PNP_CFG_TYPE_SLAVE) {
   15f80:	fc144783          	lbu	a5,-63(s0)
   15f84:	0037f793          	andi	a5,a5,3
   15f88:	0ff7f793          	andi	a5,a5,255
   15f8c:	00078713          	mv	a4,a5
   15f90:	00200793          	li	a5,2
   15f94:	02f71a63          	bne	a4,a5,15fc8 <get_dev_bar+0xd4>
        if (dcfg.u.vid == vid && dcfg.u.did == did) {
   15f98:	fc645783          	lhu	a5,-58(s0)
   15f9c:	fb645703          	lhu	a4,-74(s0)
   15fa0:	0007071b          	sext.w	a4,a4
   15fa4:	0007879b          	sext.w	a5,a5
   15fa8:	02f71263          	bne	a4,a5,15fcc <get_dev_bar+0xd8>
   15fac:	fc445783          	lhu	a5,-60(s0)
   15fb0:	fb445703          	lhu	a4,-76(s0)
   15fb4:	0007071b          	sext.w	a4,a4
   15fb8:	0007879b          	sext.w	a5,a5
   15fbc:	00f71863          	bne	a4,a5,15fcc <get_dev_bar+0xd8>
            return dcfg.u.addr_start;
   15fc0:	fd043783          	ld	a5,-48(s0)
   15fc4:	02c0006f          	j	15ff0 <get_dev_bar+0xfc>
            continue;
   15fc8:	00000013          	nop
    for (int i = 0; i < slots_total; i++) {
   15fcc:	fe842783          	lw	a5,-24(s0)
   15fd0:	0017879b          	addiw	a5,a5,1
   15fd4:	fef42423          	sw	a5,-24(s0)
   15fd8:	fe842703          	lw	a4,-24(s0)
   15fdc:	fe442783          	lw	a5,-28(s0)
   15fe0:	0007071b          	sext.w	a4,a4
   15fe4:	0007879b          	sext.w	a5,a5
   15fe8:	f4f74ce3          	blt	a4,a5,15f40 <get_dev_bar+0x4c>
    return DEV_NONE;
   15fec:	fff00793          	li	a5,-1
}
   15ff0:	00078513          	mv	a0,a5
   15ff4:	04813403          	ld	s0,72(sp)
   15ff8:	05010113          	addi	sp,sp,80
   15ffc:	00008067          	ret

0000000000016000 <mpu_region_total>:
static int mpu_region_total() {
   16000:	fe010113          	addi	sp,sp,-32
   16004:	00813c23          	sd	s0,24(sp)
   16008:	02010413          	addi	s0,sp,32
    uint64_t val = 0;
   1600c:	fe043423          	sd	zero,-24(s0)
    asm("csrr %0, 0xBC4" : "=r" (val));
   16010:	bc4027f3          	csrr	a5,0xbc4
   16014:	fef43423          	sd	a5,-24(s0)
    return (int)(val >> 8);
   16018:	fe843783          	ld	a5,-24(s0)
   1601c:	0087d793          	srli	a5,a5,0x8
   16020:	0007879b          	sext.w	a5,a5
}
   16024:	00078513          	mv	a0,a5
   16028:	01813403          	ld	s0,24(sp)
   1602c:	02010113          	addi	sp,sp,32
   16030:	00008067          	ret

0000000000016034 <mpu_disable_region>:
static void mpu_disable_region(int idx) {
   16034:	fd010113          	addi	sp,sp,-48
   16038:	02813423          	sd	s0,40(sp)
   1603c:	03010413          	addi	s0,sp,48
   16040:	00050793          	mv	a5,a0
   16044:	fcf42e23          	sw	a5,-36(s0)
    ctrl.value = 0;
   16048:	fe043423          	sd	zero,-24(s0)
    ctrl.bits.IDX = idx;
   1604c:	fdc42783          	lw	a5,-36(s0)
   16050:	0ff7f793          	andi	a5,a5,255
   16054:	fef404a3          	sb	a5,-23(s0)
    ctrl.bits.WE = 1;
   16058:	fe844783          	lbu	a5,-24(s0)
   1605c:	f807e793          	ori	a5,a5,-128
   16060:	fef40423          	sb	a5,-24(s0)
    asm("csrw 0xBC4, %0" : :"r"(ctrl.value));
   16064:	fe843783          	ld	a5,-24(s0)
   16068:	bc479073          	csrw	0xbc4,a5
}
   1606c:	00000013          	nop
   16070:	02813403          	ld	s0,40(sp)
   16074:	03010113          	addi	sp,sp,48
   16078:	00008067          	ret

000000000001607c <mpu_enable_region>:
                       const char *rwx) {
   1607c:	fb010113          	addi	sp,sp,-80
   16080:	04813423          	sd	s0,72(sp)
   16084:	05010413          	addi	s0,sp,80
   16088:	00050793          	mv	a5,a0
   1608c:	fcb43023          	sd	a1,-64(s0)
   16090:	fac43c23          	sd	a2,-72(s0)
   16094:	fae43823          	sd	a4,-80(s0)
   16098:	fcf42623          	sw	a5,-52(s0)
   1609c:	00068793          	mv	a5,a3
   160a0:	fcf42423          	sw	a5,-56(s0)
    uint64_t mask = (~0ull) << 10;
   160a4:	c0000793          	li	a5,-1024
   160a8:	fef43423          	sd	a5,-24(s0)
    const char *p = rwx;
   160ac:	fb043783          	ld	a5,-80(s0)
   160b0:	fef43023          	sd	a5,-32(s0)
    asm("csrw 0xBC2, %0" : :"r"(bar));
   160b4:	fc043783          	ld	a5,-64(s0)
   160b8:	bc279073          	csrw	0xbc2,a5
    KB >>= 1;
   160bc:	fb843783          	ld	a5,-72(s0)
   160c0:	0017d793          	srli	a5,a5,0x1
   160c4:	faf43c23          	sd	a5,-72(s0)
    while (KB) {
   160c8:	01c0006f          	j	160e4 <mpu_enable_region+0x68>
        mask <<= 1;
   160cc:	fe843783          	ld	a5,-24(s0)
   160d0:	00179793          	slli	a5,a5,0x1
   160d4:	fef43423          	sd	a5,-24(s0)
        KB >>= 1;
   160d8:	fb843783          	ld	a5,-72(s0)
   160dc:	0017d793          	srli	a5,a5,0x1
   160e0:	faf43c23          	sd	a5,-72(s0)
    while (KB) {
   160e4:	fb843783          	ld	a5,-72(s0)
   160e8:	fe0792e3          	bnez	a5,160cc <mpu_enable_region+0x50>
    asm("csrw 0xBC3, %0" : :"r"(mask));
   160ec:	fe843783          	ld	a5,-24(s0)
   160f0:	bc379073          	csrw	0xbc3,a5
    ctrl.value = 0;
   160f4:	fc043c23          	sd	zero,-40(s0)
    ctrl.bits.IDX = idx;
   160f8:	fcc42783          	lw	a5,-52(s0)
   160fc:	0ff7f793          	andi	a5,a5,255
   16100:	fcf40ca3          	sb	a5,-39(s0)
    ctrl.bits.ENA = 1;
   16104:	fd844783          	lbu	a5,-40(s0)
   16108:	0107e793          	ori	a5,a5,16
   1610c:	fcf40c23          	sb	a5,-40(s0)
    ctrl.bits.CACHABLE = cached;
   16110:	fc842783          	lw	a5,-56(s0)
   16114:	0017f793          	andi	a5,a5,1
   16118:	0ff7f793          	andi	a5,a5,255
   1611c:	0017f793          	andi	a5,a5,1
   16120:	0037969b          	slliw	a3,a5,0x3
   16124:	fd844783          	lbu	a5,-40(s0)
   16128:	ff77f793          	andi	a5,a5,-9
   1612c:	00078713          	mv	a4,a5
   16130:	00068793          	mv	a5,a3
   16134:	00f767b3          	or	a5,a4,a5
   16138:	fcf40c23          	sb	a5,-40(s0)
    ctrl.bits.WE = 1; // write into MPU
   1613c:	fd844783          	lbu	a5,-40(s0)
   16140:	f807e793          	ori	a5,a5,-128
   16144:	fcf40c23          	sb	a5,-40(s0)
    while (*p) {
   16148:	0700006f          	j	161b8 <mpu_enable_region+0x13c>
        if (*p == 'r') {
   1614c:	fe043783          	ld	a5,-32(s0)
   16150:	0007c783          	lbu	a5,0(a5)
   16154:	00078713          	mv	a4,a5
   16158:	07200793          	li	a5,114
   1615c:	00f71863          	bne	a4,a5,1616c <mpu_enable_region+0xf0>
            ctrl.bits.RD = 1;
   16160:	fd844783          	lbu	a5,-40(s0)
   16164:	0027e793          	ori	a5,a5,2
   16168:	fcf40c23          	sb	a5,-40(s0)
        if (*p == 'w') {
   1616c:	fe043783          	ld	a5,-32(s0)
   16170:	0007c783          	lbu	a5,0(a5)
   16174:	00078713          	mv	a4,a5
   16178:	07700793          	li	a5,119
   1617c:	00f71863          	bne	a4,a5,1618c <mpu_enable_region+0x110>
            ctrl.bits.WR = 1;
   16180:	fd844783          	lbu	a5,-40(s0)
   16184:	0017e793          	ori	a5,a5,1
   16188:	fcf40c23          	sb	a5,-40(s0)
        if (*p == 'x') {
   1618c:	fe043783          	ld	a5,-32(s0)
   16190:	0007c783          	lbu	a5,0(a5)
   16194:	00078713          	mv	a4,a5
   16198:	07800793          	li	a5,120
   1619c:	00f71863          	bne	a4,a5,161ac <mpu_enable_region+0x130>
            ctrl.bits.EXEC = 1;
   161a0:	fd844783          	lbu	a5,-40(s0)
   161a4:	0047e793          	ori	a5,a5,4
   161a8:	fcf40c23          	sb	a5,-40(s0)
        p++;
   161ac:	fe043783          	ld	a5,-32(s0)
   161b0:	00178793          	addi	a5,a5,1
   161b4:	fef43023          	sd	a5,-32(s0)
    while (*p) {
   161b8:	fe043783          	ld	a5,-32(s0)
   161bc:	0007c783          	lbu	a5,0(a5)
   161c0:	f80796e3          	bnez	a5,1614c <mpu_enable_region+0xd0>
    asm("csrw 0xBC4, %0" : :"r"(ctrl.value));
   161c4:	fd843783          	ld	a5,-40(s0)
   161c8:	bc479073          	csrw	0xbc4,a5
}
   161cc:	00000013          	nop
   161d0:	04813403          	ld	s0,72(sp)
   161d4:	05010113          	addi	sp,sp,80
   161d8:	00008067          	ret

00000000000161dc <test_l2coherence>:
#include <string.h>
#include <axi_maps.h>
#include "fw_api.h"

// coherence test
void test_l2coherence(void) {
   161dc:	fd010113          	addi	sp,sp,-48
   161e0:	02113423          	sd	ra,40(sp)
   161e4:	02813023          	sd	s0,32(sp)
   161e8:	03010413          	addi	s0,sp,48
    pnp_map *pnp = (pnp_map *)ADDR_BUS0_XSLV_PNP;
   161ec:	100ff7b7          	lui	a5,0x100ff
   161f0:	fef43423          	sd	a5,-24(s0)
    clint_map *clint = (clint_map *)ADDR_BUS0_XSLV_CLINT;
   161f4:	020007b7          	lui	a5,0x2000
   161f8:	fef43023          	sd	a5,-32(s0)
    uint32_t cpu_max = pnp->cfg >> 28;
   161fc:	fe843783          	ld	a5,-24(s0)
   16200:	0087a783          	lw	a5,8(a5) # 2000008 <_end+0x1fe076c>
   16204:	01c7d79b          	srliw	a5,a5,0x1c
   16208:	fcf42e23          	sw	a5,-36(s0)
    uint32_t l2cache_ena = (pnp->cfg >> 24) & 1;
   1620c:	fe843783          	ld	a5,-24(s0)
   16210:	0087a783          	lw	a5,8(a5)
   16214:	0187d79b          	srliw	a5,a5,0x18
   16218:	0007879b          	sext.w	a5,a5
   1621c:	0017f793          	andi	a5,a5,1
   16220:	fcf42c23          	sw	a5,-40(s0)
    uint32_t cohtestcnt = 0;
   16224:	fc042823          	sw	zero,-48(s0)
    uint32_t mod40;

    pnp->fwdbg1 = (uint64_t)&cohtestcnt;     // shared variable in local stack
   16228:	fd040713          	addi	a4,s0,-48
   1622c:	fe843783          	ld	a5,-24(s0)
   16230:	02e7b423          	sd	a4,40(a5)
    pnp->fwdbg2 = fw_get_cpuid();  // to debug in RTL and see CPU index
   16234:	ae1fc0ef          	jal	ra,12d14 <fw_get_cpuid>
   16238:	00050793          	mv	a5,a0
   1623c:	00078713          	mv	a4,a5
   16240:	fe843783          	ld	a5,-24(s0)
   16244:	02e7b823          	sd	a4,48(a5)

    printf_uart("%s", "L2.Coherence . .");
   16248:	0001e7b7          	lui	a5,0x1e
   1624c:	b7878593          	addi	a1,a5,-1160 # 1db78 <FCVT_WU_D_TESTS+0x540>
   16250:	0001e7b7          	lui	a5,0x1e
   16254:	b9078513          	addi	a0,a5,-1136 # 1db90 <FCVT_WU_D_TESTS+0x558>
   16258:	ffffc097          	auipc	ra,0xffffc
   1625c:	6f8080e7          	jalr	1784(ra) # 12950 <printf_uart>
    if (l2cache_ena == 0) {
   16260:	fd842783          	lw	a5,-40(s0)
   16264:	0007879b          	sext.w	a5,a5
   16268:	02079063          	bnez	a5,16288 <test_l2coherence+0xac>
        printf_uart("%s\r\n", "Disabled");
   1626c:	0001e7b7          	lui	a5,0x1e
   16270:	b9878593          	addi	a1,a5,-1128 # 1db98 <FCVT_WU_D_TESTS+0x560>
   16274:	0001e7b7          	lui	a5,0x1e
   16278:	ba878513          	addi	a0,a5,-1112 # 1dba8 <FCVT_WU_D_TESTS+0x570>
   1627c:	ffffc097          	auipc	ra,0xffffc
   16280:	6d4080e7          	jalr	1748(ra) # 12950 <printf_uart>
        return;
   16284:	0c80006f          	j	1634c <test_l2coherence+0x170>
    } else if (cpu_max <= 1) {
   16288:	fdc42783          	lw	a5,-36(s0)
   1628c:	0007871b          	sext.w	a4,a5
   16290:	00100793          	li	a5,1
   16294:	02e7e063          	bltu	a5,a4,162b4 <test_l2coherence+0xd8>
        printf_uart("%s\r\n", "SKIPPED");
   16298:	0001e7b7          	lui	a5,0x1e
   1629c:	bb078593          	addi	a1,a5,-1104 # 1dbb0 <FCVT_WU_D_TESTS+0x578>
   162a0:	0001e7b7          	lui	a5,0x1e
   162a4:	ba878513          	addi	a0,a5,-1112 # 1dba8 <FCVT_WU_D_TESTS+0x570>
   162a8:	ffffc097          	auipc	ra,0xffffc
   162ac:	6a8080e7          	jalr	1704(ra) # 12950 <printf_uart>
        return;
   162b0:	09c0006f          	j	1634c <test_l2coherence+0x170>
    }

    // wake-up hwthreads
    clint->msip[1] = 0x1;
   162b4:	fe043783          	ld	a5,-32(s0)
   162b8:	00100713          	li	a4,1
   162bc:	00e7a223          	sw	a4,4(a5)
    clint->msip[2] = 0x1;
   162c0:	fe043783          	ld	a5,-32(s0)
   162c4:	00100713          	li	a4,1
   162c8:	00e7a423          	sw	a4,8(a5)
    clint->msip[3] = 0x1;
   162cc:	fe043783          	ld	a5,-32(s0)
   162d0:	00100713          	li	a4,1
   162d4:	00e7a623          	sw	a4,12(a5)

    while (cohtestcnt < 75) {
   162d8:	04c0006f          	j	16324 <test_l2coherence+0x148>
        mod40 = cohtestcnt % 40;
   162dc:	fd042783          	lw	a5,-48(s0)
   162e0:	00078713          	mv	a4,a5
   162e4:	02800793          	li	a5,40
   162e8:	02f777bb          	remuw	a5,a4,a5
   162ec:	fcf42a23          	sw	a5,-44(s0)
        if (mod40 >= 0 && mod40 < 10) {
   162f0:	fd442783          	lw	a5,-44(s0)
   162f4:	0007871b          	sext.w	a4,a5
   162f8:	00900793          	li	a5,9
   162fc:	02e7e463          	bltu	a5,a4,16324 <test_l2coherence+0x148>
            pnp->fwdbg2 = cohtestcnt;//fw_get_cpuid();  // to debug in RTL and see CPU index
   16300:	fd042783          	lw	a5,-48(s0)
   16304:	02079713          	slli	a4,a5,0x20
   16308:	02075713          	srli	a4,a4,0x20
   1630c:	fe843783          	ld	a5,-24(s0)
   16310:	02e7b823          	sd	a4,48(a5)
            cohtestcnt++;
   16314:	fd042783          	lw	a5,-48(s0)
   16318:	0017879b          	addiw	a5,a5,1
   1631c:	0007879b          	sext.w	a5,a5
   16320:	fcf42823          	sw	a5,-48(s0)
    while (cohtestcnt < 75) {
   16324:	fd042783          	lw	a5,-48(s0)
   16328:	00078713          	mv	a4,a5
   1632c:	04a00793          	li	a5,74
   16330:	fae7f6e3          	bleu	a4,a5,162dc <test_l2coherence+0x100>
        }
    }
    printf_uart("%s\r\n", "PASS");
   16334:	0001e7b7          	lui	a5,0x1e
   16338:	bb878593          	addi	a1,a5,-1096 # 1dbb8 <FCVT_WU_D_TESTS+0x580>
   1633c:	0001e7b7          	lui	a5,0x1e
   16340:	ba878513          	addi	a0,a5,-1112 # 1dba8 <FCVT_WU_D_TESTS+0x570>
   16344:	ffffc097          	auipc	ra,0xffffc
   16348:	60c080e7          	jalr	1548(ra) # 12950 <printf_uart>
}
   1634c:	02813083          	ld	ra,40(sp)
   16350:	02013403          	ld	s0,32(sp)
   16354:	03010113          	addi	sp,sp,48
   16358:	00008067          	ret
   1635c:	0000                	unimp
	...

0000000000016360 <get_dev_bar>:
static uint64_t get_dev_bar(pnp_map *pnp, uint16_t vid, uint16_t did) {
   16360:	fb010113          	addi	sp,sp,-80
   16364:	04813423          	sd	s0,72(sp)
   16368:	05010413          	addi	s0,sp,80
   1636c:	faa43c23          	sd	a0,-72(s0)
   16370:	00058793          	mv	a5,a1
   16374:	00060713          	mv	a4,a2
   16378:	faf41b23          	sh	a5,-74(s0)
   1637c:	00070793          	mv	a5,a4
   16380:	faf41a23          	sh	a5,-76(s0)
    int slots_total = (pnp->cfg >> 8) & 0xFF;
   16384:	fb843783          	ld	a5,-72(s0)
   16388:	0087a783          	lw	a5,8(a5)
   1638c:	0087d79b          	srliw	a5,a5,0x8
   16390:	0007879b          	sext.w	a5,a5
   16394:	0007879b          	sext.w	a5,a5
   16398:	0ff7f793          	andi	a5,a5,255
   1639c:	fef42223          	sw	a5,-28(s0)
    int off = 0;
   163a0:	fe042623          	sw	zero,-20(s0)
    for (int i = 0; i < slots_total; i++) {
   163a4:	fe042423          	sw	zero,-24(s0)
   163a8:	09c0006f          	j	16444 <get_dev_bar+0xe4>
        dcfg = *(dev_cfg_type *)&pnp->cfg_table[off];
   163ac:	fec42783          	lw	a5,-20(s0)
   163b0:	04078793          	addi	a5,a5,64
   163b4:	fb843703          	ld	a4,-72(s0)
   163b8:	00f707b3          	add	a5,a4,a5
   163bc:	0007b703          	ld	a4,0(a5)
   163c0:	fce43023          	sd	a4,-64(s0)
   163c4:	0087b703          	ld	a4,8(a5)
   163c8:	fce43423          	sd	a4,-56(s0)
   163cc:	0107b703          	ld	a4,16(a5)
   163d0:	fce43823          	sd	a4,-48(s0)
   163d4:	0187b783          	ld	a5,24(a5)
   163d8:	fcf43c23          	sd	a5,-40(s0)
        off += sizeof(dcfg);
   163dc:	fec42783          	lw	a5,-20(s0)
   163e0:	0207879b          	addiw	a5,a5,32
   163e4:	0007879b          	sext.w	a5,a5
   163e8:	fef42623          	sw	a5,-20(s0)
        if (dcfg.u.descrtype != PNP_CFG_TYPE_SLAVE) {
   163ec:	fc144783          	lbu	a5,-63(s0)
   163f0:	0037f793          	andi	a5,a5,3
   163f4:	0ff7f793          	andi	a5,a5,255
   163f8:	00078713          	mv	a4,a5
   163fc:	00200793          	li	a5,2
   16400:	02f71a63          	bne	a4,a5,16434 <get_dev_bar+0xd4>
        if (dcfg.u.vid == vid && dcfg.u.did == did) {
   16404:	fc645783          	lhu	a5,-58(s0)
   16408:	fb645703          	lhu	a4,-74(s0)
   1640c:	0007071b          	sext.w	a4,a4
   16410:	0007879b          	sext.w	a5,a5
   16414:	02f71263          	bne	a4,a5,16438 <get_dev_bar+0xd8>
   16418:	fc445783          	lhu	a5,-60(s0)
   1641c:	fb445703          	lhu	a4,-76(s0)
   16420:	0007071b          	sext.w	a4,a4
   16424:	0007879b          	sext.w	a5,a5
   16428:	00f71863          	bne	a4,a5,16438 <get_dev_bar+0xd8>
            return dcfg.u.addr_start;
   1642c:	fd043783          	ld	a5,-48(s0)
   16430:	02c0006f          	j	1645c <get_dev_bar+0xfc>
            continue;
   16434:	00000013          	nop
    for (int i = 0; i < slots_total; i++) {
   16438:	fe842783          	lw	a5,-24(s0)
   1643c:	0017879b          	addiw	a5,a5,1
   16440:	fef42423          	sw	a5,-24(s0)
   16444:	fe842703          	lw	a4,-24(s0)
   16448:	fe442783          	lw	a5,-28(s0)
   1644c:	0007071b          	sext.w	a4,a4
   16450:	0007879b          	sext.w	a5,a5
   16454:	f4f74ce3          	blt	a4,a5,163ac <get_dev_bar+0x4c>
    return DEV_NONE;
   16458:	fff00793          	li	a5,-1
}
   1645c:	00078513          	mv	a0,a5
   16460:	04813403          	ld	s0,72(sp)
   16464:	05010113          	addi	sp,sp,80
   16468:	00008067          	ret

000000000001646c <mpu_region_total>:
static int mpu_region_total() {
   1646c:	fe010113          	addi	sp,sp,-32
   16470:	00813c23          	sd	s0,24(sp)
   16474:	02010413          	addi	s0,sp,32
    uint64_t val = 0;
   16478:	fe043423          	sd	zero,-24(s0)
    asm("csrr %0, 0xBC4" : "=r" (val));
   1647c:	bc4027f3          	csrr	a5,0xbc4
   16480:	fef43423          	sd	a5,-24(s0)
    return (int)(val >> 8);
   16484:	fe843783          	ld	a5,-24(s0)
   16488:	0087d793          	srli	a5,a5,0x8
   1648c:	0007879b          	sext.w	a5,a5
}
   16490:	00078513          	mv	a0,a5
   16494:	01813403          	ld	s0,24(sp)
   16498:	02010113          	addi	sp,sp,32
   1649c:	00008067          	ret

00000000000164a0 <mpu_disable_region>:
static void mpu_disable_region(int idx) {
   164a0:	fd010113          	addi	sp,sp,-48
   164a4:	02813423          	sd	s0,40(sp)
   164a8:	03010413          	addi	s0,sp,48
   164ac:	00050793          	mv	a5,a0
   164b0:	fcf42e23          	sw	a5,-36(s0)
    ctrl.value = 0;
   164b4:	fe043423          	sd	zero,-24(s0)
    ctrl.bits.IDX = idx;
   164b8:	fdc42783          	lw	a5,-36(s0)
   164bc:	0ff7f793          	andi	a5,a5,255
   164c0:	fef404a3          	sb	a5,-23(s0)
    ctrl.bits.WE = 1;
   164c4:	fe844783          	lbu	a5,-24(s0)
   164c8:	f807e793          	ori	a5,a5,-128
   164cc:	fef40423          	sb	a5,-24(s0)
    asm("csrw 0xBC4, %0" : :"r"(ctrl.value));
   164d0:	fe843783          	ld	a5,-24(s0)
   164d4:	bc479073          	csrw	0xbc4,a5
}
   164d8:	00000013          	nop
   164dc:	02813403          	ld	s0,40(sp)
   164e0:	03010113          	addi	sp,sp,48
   164e4:	00008067          	ret

00000000000164e8 <mpu_enable_region>:
                       const char *rwx) {
   164e8:	fb010113          	addi	sp,sp,-80
   164ec:	04813423          	sd	s0,72(sp)
   164f0:	05010413          	addi	s0,sp,80
   164f4:	00050793          	mv	a5,a0
   164f8:	fcb43023          	sd	a1,-64(s0)
   164fc:	fac43c23          	sd	a2,-72(s0)
   16500:	fae43823          	sd	a4,-80(s0)
   16504:	fcf42623          	sw	a5,-52(s0)
   16508:	00068793          	mv	a5,a3
   1650c:	fcf42423          	sw	a5,-56(s0)
    uint64_t mask = (~0ull) << 10;
   16510:	c0000793          	li	a5,-1024
   16514:	fef43423          	sd	a5,-24(s0)
    const char *p = rwx;
   16518:	fb043783          	ld	a5,-80(s0)
   1651c:	fef43023          	sd	a5,-32(s0)
    asm("csrw 0xBC2, %0" : :"r"(bar));
   16520:	fc043783          	ld	a5,-64(s0)
   16524:	bc279073          	csrw	0xbc2,a5
    KB >>= 1;
   16528:	fb843783          	ld	a5,-72(s0)
   1652c:	0017d793          	srli	a5,a5,0x1
   16530:	faf43c23          	sd	a5,-72(s0)
    while (KB) {
   16534:	01c0006f          	j	16550 <mpu_enable_region+0x68>
        mask <<= 1;
   16538:	fe843783          	ld	a5,-24(s0)
   1653c:	00179793          	slli	a5,a5,0x1
   16540:	fef43423          	sd	a5,-24(s0)
        KB >>= 1;
   16544:	fb843783          	ld	a5,-72(s0)
   16548:	0017d793          	srli	a5,a5,0x1
   1654c:	faf43c23          	sd	a5,-72(s0)
    while (KB) {
   16550:	fb843783          	ld	a5,-72(s0)
   16554:	fe0792e3          	bnez	a5,16538 <mpu_enable_region+0x50>
    asm("csrw 0xBC3, %0" : :"r"(mask));
   16558:	fe843783          	ld	a5,-24(s0)
   1655c:	bc379073          	csrw	0xbc3,a5
    ctrl.value = 0;
   16560:	fc043c23          	sd	zero,-40(s0)
    ctrl.bits.IDX = idx;
   16564:	fcc42783          	lw	a5,-52(s0)
   16568:	0ff7f793          	andi	a5,a5,255
   1656c:	fcf40ca3          	sb	a5,-39(s0)
    ctrl.bits.ENA = 1;
   16570:	fd844783          	lbu	a5,-40(s0)
   16574:	0107e793          	ori	a5,a5,16
   16578:	fcf40c23          	sb	a5,-40(s0)
    ctrl.bits.CACHABLE = cached;
   1657c:	fc842783          	lw	a5,-56(s0)
   16580:	0017f793          	andi	a5,a5,1
   16584:	0ff7f793          	andi	a5,a5,255
   16588:	0017f793          	andi	a5,a5,1
   1658c:	0037969b          	slliw	a3,a5,0x3
   16590:	fd844783          	lbu	a5,-40(s0)
   16594:	ff77f793          	andi	a5,a5,-9
   16598:	00078713          	mv	a4,a5
   1659c:	00068793          	mv	a5,a3
   165a0:	00f767b3          	or	a5,a4,a5
   165a4:	fcf40c23          	sb	a5,-40(s0)
    ctrl.bits.WE = 1; // write into MPU
   165a8:	fd844783          	lbu	a5,-40(s0)
   165ac:	f807e793          	ori	a5,a5,-128
   165b0:	fcf40c23          	sb	a5,-40(s0)
    while (*p) {
   165b4:	0700006f          	j	16624 <mpu_enable_region+0x13c>
        if (*p == 'r') {
   165b8:	fe043783          	ld	a5,-32(s0)
   165bc:	0007c783          	lbu	a5,0(a5)
   165c0:	00078713          	mv	a4,a5
   165c4:	07200793          	li	a5,114
   165c8:	00f71863          	bne	a4,a5,165d8 <mpu_enable_region+0xf0>
            ctrl.bits.RD = 1;
   165cc:	fd844783          	lbu	a5,-40(s0)
   165d0:	0027e793          	ori	a5,a5,2
   165d4:	fcf40c23          	sb	a5,-40(s0)
        if (*p == 'w') {
   165d8:	fe043783          	ld	a5,-32(s0)
   165dc:	0007c783          	lbu	a5,0(a5)
   165e0:	00078713          	mv	a4,a5
   165e4:	07700793          	li	a5,119
   165e8:	00f71863          	bne	a4,a5,165f8 <mpu_enable_region+0x110>
            ctrl.bits.WR = 1;
   165ec:	fd844783          	lbu	a5,-40(s0)
   165f0:	0017e793          	ori	a5,a5,1
   165f4:	fcf40c23          	sb	a5,-40(s0)
        if (*p == 'x') {
   165f8:	fe043783          	ld	a5,-32(s0)
   165fc:	0007c783          	lbu	a5,0(a5)
   16600:	00078713          	mv	a4,a5
   16604:	07800793          	li	a5,120
   16608:	00f71863          	bne	a4,a5,16618 <mpu_enable_region+0x130>
            ctrl.bits.EXEC = 1;
   1660c:	fd844783          	lbu	a5,-40(s0)
   16610:	0047e793          	ori	a5,a5,4
   16614:	fcf40c23          	sb	a5,-40(s0)
        p++;
   16618:	fe043783          	ld	a5,-32(s0)
   1661c:	00178793          	addi	a5,a5,1
   16620:	fef43023          	sd	a5,-32(s0)
    while (*p) {
   16624:	fe043783          	ld	a5,-32(s0)
   16628:	0007c783          	lbu	a5,0(a5)
   1662c:	f80796e3          	bnez	a5,165b8 <mpu_enable_region+0xd0>
    asm("csrw 0xBC4, %0" : :"r"(ctrl.value));
   16630:	fd843783          	ld	a5,-40(s0)
   16634:	bc479073          	csrw	0xbc4,a5
}
   16638:	00000013          	nop
   1663c:	04813403          	ld	s0,72(sp)
   16640:	05010113          	addi	sp,sp,80
   16644:	00008067          	ret

0000000000016648 <setup_pmp>:
#include <encoding.h>
#include <fw_api.h>
#include <axi_maps.h>

void setup_pmp(void)
{
   16648:	fe010113          	addi	sp,sp,-32
   1664c:	00813c23          	sd	s0,24(sp)
   16650:	02010413          	addi	s0,sp,32
  // Set up a PMP to permit access to all of memory.
  // Ignore the illegal-instruction trap if PMPs aren't supported.
  uintptr_t pmpc = PMP_NAPOT | PMP_R | PMP_W | PMP_X;
   16654:	01f00793          	li	a5,31
   16658:	fef43423          	sd	a5,-24(s0)
  asm volatile ("la t0, 1f\n\t"
   1665c:	fe843783          	ld	a5,-24(s0)
   16660:	fff00713          	li	a4,-1
   16664:	00000297          	auipc	t0,0x0
   16668:	01428293          	addi	t0,t0,20 # 16678 <setup_pmp+0x30>
   1666c:	305292f3          	csrrw	t0,mtvec,t0
   16670:	3b071073          	csrw	pmpaddr0,a4
   16674:	3a079073          	csrw	pmpcfg0,a5
   16678:	30529073          	csrw	mtvec,t0
                "csrw pmpaddr0, %1\n\t"
                "csrw pmpcfg0, %0\n\t"
                ".align 2\n\t"
                "1: csrw mtvec, t0"
                : : "r" (pmpc), "r" (-1UL) : "t0");
}
   1667c:	00000013          	nop
   16680:	01813403          	ld	s0,24(sp)
   16684:	02010113          	addi	sp,sp,32
   16688:	00008067          	ret

000000000001668c <protect_memory>:

void protect_memory(void)
{
   1668c:	fc010113          	addi	sp,sp,-64
   16690:	02113c23          	sd	ra,56(sp)
   16694:	02813823          	sd	s0,48(sp)
   16698:	04010413          	addi	s0,sp,64
  // Check to see if up to four PMP registers are implemented.
  // Ignore the illegal-instruction trap if PMPs aren't supported.
  uintptr_t a0 = 0, a1 = 0, a2 = 0, a3 = 0, tmp, cfg;
   1669c:	fe043423          	sd	zero,-24(s0)
   166a0:	fe043023          	sd	zero,-32(s0)
   166a4:	fc043c23          	sd	zero,-40(s0)
   166a8:	fc043823          	sd	zero,-48(s0)
  asm volatile ("la %[tmp], 1f\n\t"
   166ac:	fff00593          	li	a1,-1
   166b0:	fe843603          	ld	a2,-24(s0)
   166b4:	fe043683          	ld	a3,-32(s0)
   166b8:	fd843703          	ld	a4,-40(s0)
   166bc:	fd043783          	ld	a5,-48(s0)
   166c0:	00000517          	auipc	a0,0x0
   166c4:	02c50513          	addi	a0,a0,44 # 166ec <protect_memory+0x60>
   166c8:	30551573          	csrrw	a0,mtvec,a0
   166cc:	3b059073          	csrw	pmpaddr0,a1
   166d0:	3b002673          	csrr	a2,pmpaddr0
   166d4:	3b159073          	csrw	pmpaddr1,a1
   166d8:	3b1026f3          	csrr	a3,pmpaddr1
   166dc:	3b259073          	csrw	pmpaddr2,a1
   166e0:	3b202773          	csrr	a4,pmpaddr2
   166e4:	3b359073          	csrw	pmpaddr3,a1
   166e8:	3b3027f3          	csrr	a5,pmpaddr3
   166ec:	30551073          	csrw	mtvec,a0
   166f0:	fca43423          	sd	a0,-56(s0)
   166f4:	fec43423          	sd	a2,-24(s0)
   166f8:	fed43023          	sd	a3,-32(s0)
   166fc:	fce43c23          	sd	a4,-40(s0)
   16700:	fcf43823          	sd	a5,-48(s0)
                : [tmp] "=&r" (tmp),
                  [a0] "+r" (a0), [a1] "+r" (a1), [a2] "+r" (a2), [a3] "+r" (a3)
                : [m1] "r" (-1UL));

  // We need at least four PMP registers to protect M-mode from S-mode.
  if (!(a0 & a1 & a2 & a3))
   16704:	fe843703          	ld	a4,-24(s0)
   16708:	fe043783          	ld	a5,-32(s0)
   1670c:	00f77733          	and	a4,a4,a5
   16710:	fd843783          	ld	a5,-40(s0)
   16714:	00f77733          	and	a4,a4,a5
   16718:	fd043783          	ld	a5,-48(s0)
   1671c:	00f777b3          	and	a5,a4,a5
   16720:	00079863          	bnez	a5,16730 <protect_memory+0xa4>
    return setup_pmp();
   16724:	00000097          	auipc	ra,0x0
   16728:	f24080e7          	jalr	-220(ra) # 16648 <setup_pmp>
   1672c:	0740006f          	j	167a0 <protect_memory+0x114>

  // Prevent S-mode access to our part of memory.
  extern char _ftext, _end;
  a0 = (uintptr_t)&_ftext >> PMP_SHIFT;
   16730:	000107b7          	lui	a5,0x10
   16734:	00078793          	mv	a5,a5
   16738:	0027d793          	srli	a5,a5,0x2
   1673c:	fef43423          	sd	a5,-24(s0)
  a1 = (uintptr_t)&_end >> PMP_SHIFT;
   16740:	000207b7          	lui	a5,0x20
   16744:	89c78793          	addi	a5,a5,-1892 # 1f89c <_end>
   16748:	0027d793          	srli	a5,a5,0x2
   1674c:	fef43023          	sd	a5,-32(s0)
  cfg = PMP_TOR << 8;
   16750:	000017b7          	lui	a5,0x1
   16754:	80078793          	addi	a5,a5,-2048 # 800 <_ftext-0xf800>
   16758:	fcf43023          	sd	a5,-64(s0)
  // Give S-mode free rein of everything else.
  a2 = -1;
   1675c:	fff00793          	li	a5,-1
   16760:	fcf43c23          	sd	a5,-40(s0)
  cfg |= (PMP_NAPOT | PMP_R | PMP_W | PMP_X) << 16;
   16764:	fc043703          	ld	a4,-64(s0)
   16768:	001f07b7          	lui	a5,0x1f0
   1676c:	00f767b3          	or	a5,a4,a5
   16770:	fcf43023          	sd	a5,-64(s0)
  // No use for PMP 3 just yet.
  a3 = 0;
   16774:	fc043823          	sd	zero,-48(s0)

  // Plug it all in.
  asm volatile ("csrw pmpaddr0, %[a0]\n\t"
   16778:	fe843783          	ld	a5,-24(s0)
   1677c:	fe043703          	ld	a4,-32(s0)
   16780:	fd843683          	ld	a3,-40(s0)
   16784:	fd043603          	ld	a2,-48(s0)
   16788:	fc043583          	ld	a1,-64(s0)
   1678c:	3b079073          	csrw	pmpaddr0,a5
   16790:	3b171073          	csrw	pmpaddr1,a4
   16794:	3b269073          	csrw	pmpaddr2,a3
   16798:	3b361073          	csrw	pmpaddr3,a2
   1679c:	3a059073          	csrw	pmpcfg0,a1
                "csrw pmpaddr2, %[a2]\n\t"
                "csrw pmpaddr3, %[a3]\n\t"
                "csrw pmpcfg0, %[cfg]"
                :: [a0] "r" (a0), [a1] "r" (a1), [a2] "r" (a2), [a3] "r" (a3),
                   [cfg] "r" (cfg));
}
   167a0:	03813083          	ld	ra,56(sp)
   167a4:	03013403          	ld	s0,48(sp)
   167a8:	04010113          	addi	sp,sp,64
   167ac:	00008067          	ret

00000000000167b0 <init_pmp>:

#define W32_NO_INTERRUPT 0x33445566

// Enable U,S,MPRV for all regions
void init_pmp() {
   167b0:	fe010113          	addi	sp,sp,-32
   167b4:	00813c23          	sd	s0,24(sp)
   167b8:	02010413          	addi	s0,sp,32
    uint64_t a0 = -1;  // Give S-mode free rein of everything else.
   167bc:	fff00793          	li	a5,-1
   167c0:	fef43423          	sd	a5,-24(s0)
    uint64_t cfg = (PMP_NAPOT | PMP_R | PMP_W | PMP_X) << 0; // [] channel: whole memory range
   167c4:	01f00793          	li	a5,31
   167c8:	fef43023          	sd	a5,-32(s0)

    // Plug it all in.
    asm volatile ("csrw pmpaddr0, %[a0]\n\t"
   167cc:	fe843783          	ld	a5,-24(s0)
   167d0:	fe043703          	ld	a4,-32(s0)
   167d4:	3b079073          	csrw	pmpaddr0,a5
   167d8:	3a071073          	csrw	pmpcfg0,a4
                  "csrw pmpcfg0, %[cfg]"
                  :: [a0] "r" (a0),
                     [cfg] "r" (cfg));
}
   167dc:	00000013          	nop
   167e0:	01813403          	ld	s0,24(sp)
   167e4:	02010113          	addi	sp,sp,32
   167e8:	00008067          	ret

00000000000167ec <restore_state>:

// Restore state before the test:
void restore_state(uint64_t vec, uint64_t status) {
   167ec:	fe010113          	addi	sp,sp,-32
   167f0:	00113c23          	sd	ra,24(sp)
   167f4:	00813823          	sd	s0,16(sp)
   167f8:	02010413          	addi	s0,sp,32
   167fc:	fea43423          	sd	a0,-24(s0)
   16800:	feb43023          	sd	a1,-32(s0)
    asm volatile ("csrw mtvec, %[vec]\n\t"
   16804:	fe843783          	ld	a5,-24(s0)
   16808:	fe043703          	ld	a4,-32(s0)
   1680c:	00000693          	li	a3,0
   16810:	30579073          	csrw	mtvec,a5
   16814:	30071073          	csrw	mstatus,a4
   16818:	3a069073          	csrw	pmpcfg0,a3
                  "csrw mstatus, %[status]\n\t"
                  "csrw pmpcfg0, %[cfg]"
                  :: [vec] "r" (vec),
                     [status] "r" (status),
                     [cfg] "r" (0));
    init_pmp();
   1681c:	00000097          	auipc	ra,0x0
   16820:	f94080e7          	jalr	-108(ra) # 167b0 <init_pmp>

}
   16824:	00000013          	nop
   16828:	01813083          	ld	ra,24(sp)
   1682c:	01013403          	ld	s0,16(sp)
   16830:	02010113          	addi	sp,sp,32
   16834:	00008067          	ret

0000000000016838 <test_pmp>:
    volatile uint32_t r_only;
    volatile uint32_t *p_r_only;
    volatile uint64_t w_only;
} pmp_type;

void test_pmp() {
   16838:	fa010113          	addi	sp,sp,-96
   1683c:	04113c23          	sd	ra,88(sp)
   16840:	04813823          	sd	s0,80(sp)
   16844:	06010413          	addi	s0,sp,96
    uintptr_t a0 = 0, a1 = 0, a2 = 0, a3 = 0, tlabel;
   16848:	fe043423          	sd	zero,-24(s0)
   1684c:	fe043023          	sd	zero,-32(s0)
   16850:	fc043c23          	sd	zero,-40(s0)
   16854:	fc043823          	sd	zero,-48(s0)
    uint64_t cfg;
    uint32_t wValue;

    pmp_type *pmp = (pmp_type *)fw_malloc(sizeof(pmp_type));
   16858:	02800513          	li	a0,40
   1685c:	ffffb097          	auipc	ra,0xffffb
   16860:	2dc080e7          	jalr	732(ra) # 11b38 <fw_malloc>
   16864:	fca43423          	sd	a0,-56(s0)
    fw_register_ram_data("pmp", pmp);
   16868:	fc843583          	ld	a1,-56(s0)
   1686c:	0001e7b7          	lui	a5,0x1e
   16870:	bc078513          	addi	a0,a5,-1088 # 1dbc0 <FCVT_WU_D_TESTS+0x588>
   16874:	b64fb0ef          	jal	ra,11bd8 <fw_register_ram_data>

    printf_uart("%s", "PMP. . . . . . .");
   16878:	0001e7b7          	lui	a5,0x1e
   1687c:	bc878593          	addi	a1,a5,-1080 # 1dbc8 <FCVT_WU_D_TESTS+0x590>
   16880:	0001e7b7          	lui	a5,0x1e
   16884:	be078513          	addi	a0,a5,-1056 # 1dbe0 <FCVT_WU_D_TESTS+0x5a8>
   16888:	ffffc097          	auipc	ra,0xffffc
   1688c:	0c8080e7          	jalr	200(ra) # 12950 <printf_uart>

    pmp->p_r_only = &pmp->r_only;
   16890:	fc843783          	ld	a5,-56(s0)
   16894:	01078713          	addi	a4,a5,16
   16898:	fc843783          	ld	a5,-56(s0)
   1689c:	00e7bc23          	sd	a4,24(a5)
    asm volatile ("mv t0, %[p_r_only]\n\t" : [p_r_only] "+r" (pmp->p_r_only));
   168a0:	fc843783          	ld	a5,-56(s0)
   168a4:	0187b783          	ld	a5,24(a5)
   168a8:	00078293          	mv	t0,a5
   168ac:	fc843703          	ld	a4,-56(s0)
   168b0:	00f73c23          	sd	a5,24(a4) # 10018 <trap_table+0x14>
    pmp->mstatus = read_csr(mstatus);
   168b4:	300027f3          	csrr	a5,mstatus
   168b8:	fcf43023          	sd	a5,-64(s0)
   168bc:	fc043703          	ld	a4,-64(s0)
   168c0:	fc843783          	ld	a5,-56(s0)
   168c4:	00e7b423          	sd	a4,8(a5)

    asm volatile ("csrr %[mtvec_z], mtvec\n\t" :
   168c8:	30502773          	csrr	a4,mtvec
   168cc:	fc843783          	ld	a5,-56(s0)
   168d0:	00e7b023          	sd	a4,0(a5)
                  [mtvec_z] "=r" (pmp->mtvec));

    a0 = (uintptr_t)&pmp->r_only >> PMP_SHIFT;
   168d4:	fc843783          	ld	a5,-56(s0)
   168d8:	01078793          	addi	a5,a5,16
   168dc:	0027d793          	srli	a5,a5,0x2
   168e0:	fef43423          	sd	a5,-24(s0)
    a1 = (uintptr_t)&pmp->w_only >> PMP_SHIFT;
   168e4:	fc843783          	ld	a5,-56(s0)
   168e8:	02078793          	addi	a5,a5,32
   168ec:	0027d793          	srli	a5,a5,0x2
   168f0:	fef43023          	sd	a5,-32(s0)
    a2 = -1;  // Give S-mode free rein of everything else.
   168f4:	fff00793          	li	a5,-1
   168f8:	fcf43c23          	sd	a5,-40(s0)

    cfg = (PMP_NA4 | PMP_R) << 0;     // [0] channel 0: 4 bytes region
   168fc:	01100793          	li	a5,17
   16900:	faf43c23          	sd	a5,-72(s0)
    cfg |= (PMP_NAPOT | PMP_W) << 8;  // [1] channel 1: 8 bytes region
   16904:	fb843703          	ld	a4,-72(s0)
   16908:	000027b7          	lui	a5,0x2
   1690c:	a0078793          	addi	a5,a5,-1536 # 1a00 <_ftext-0xe600>
   16910:	00f767b3          	or	a5,a4,a5
   16914:	faf43c23          	sd	a5,-72(s0)
    cfg |= (PMP_NAPOT | PMP_R | PMP_W | PMP_X) << 16; // [2] channel: whole memory range
   16918:	fb843703          	ld	a4,-72(s0)
   1691c:	001f07b7          	lui	a5,0x1f0
   16920:	00f767b3          	or	a5,a4,a5
   16924:	faf43c23          	sd	a5,-72(s0)

    // Plug it all in.
    asm volatile ("csrw pmpaddr0, %[a0]\n\t"
   16928:	fe843783          	ld	a5,-24(s0)
   1692c:	fe043703          	ld	a4,-32(s0)
   16930:	fd843683          	ld	a3,-40(s0)
   16934:	fb843603          	ld	a2,-72(s0)
   16938:	3b079073          	csrw	pmpaddr0,a5
   1693c:	3b171073          	csrw	pmpaddr1,a4
   16940:	3b269073          	csrw	pmpaddr2,a3
   16944:	3a061073          	csrw	pmpcfg0,a2
                  "csrw pmpcfg0, %[cfg]"
                  :: [a0] "r" (a0), [a1] "r" (a1), [a2] "r" (a2),
                     [cfg] "r" (cfg));

    // Check read32 write without interrupt
    wValue = W32_NO_INTERRUPT;
   16948:	334457b7          	lui	a5,0x33445
   1694c:	5667879b          	addiw	a5,a5,1382
   16950:	faf42a23          	sw	a5,-76(s0)
    *pmp->p_r_only = 0;
   16954:	fc843783          	ld	a5,-56(s0)
   16958:	0187b783          	ld	a5,24(a5) # 33445018 <_end+0x3342577c>
   1695c:	0007a023          	sw	zero,0(a5)
    asm volatile ("la %[tlabel], 1f\n\t"
   16960:	fff00693          	li	a3,-1
   16964:	fb442783          	lw	a5,-76(s0)
   16968:	00000717          	auipc	a4,0x0
   1696c:	01870713          	addi	a4,a4,24 # 16980 <test_pmp+0x148>
   16970:	30571773          	csrrw	a4,mtvec,a4
   16974:	00f2a023          	sw	a5,0(t0)
   16978:	0000100f          	fence.i
   1697c:	0080006f          	j	16984 <test_pmp+0x14c>
   16980:	00068793          	mv	a5,a3
   16984:	00000013          	nop
   16988:	fae43423          	sd	a4,-88(s0)
   1698c:	faf42a23          	sw	a5,-76(s0)
                  "2: nop\r\n"
                : [tlabel] "=&r" (tlabel),
                  [wValue] "+r" (wValue)
                : [m1] "r" (-1U));

    if (wValue != W32_NO_INTERRUPT || *pmp->p_r_only != W32_NO_INTERRUPT) {
   16990:	fb442783          	lw	a5,-76(s0)
   16994:	0007871b          	sext.w	a4,a5
   16998:	334457b7          	lui	a5,0x33445
   1699c:	56678793          	addi	a5,a5,1382 # 33445566 <_end+0x33425cca>
   169a0:	02f71263          	bne	a4,a5,169c4 <test_pmp+0x18c>
   169a4:	fc843783          	ld	a5,-56(s0)
   169a8:	0187b783          	ld	a5,24(a5)
   169ac:	0007a783          	lw	a5,0(a5)
   169b0:	0007879b          	sext.w	a5,a5
   169b4:	00078713          	mv	a4,a5
   169b8:	334457b7          	lui	a5,0x33445
   169bc:	56678793          	addi	a5,a5,1382 # 33445566 <_end+0x33425cca>
   169c0:	04f70663          	beq	a4,a5,16a0c <test_pmp+0x1d4>
        printf_uart("FAIL(1), wValue=%08x r_only=%08x\r\b", wValue, *pmp->p_r_only);
   169c4:	fc843783          	ld	a5,-56(s0)
   169c8:	0187b783          	ld	a5,24(a5)
   169cc:	0007a783          	lw	a5,0(a5)
   169d0:	0007871b          	sext.w	a4,a5
   169d4:	fb442783          	lw	a5,-76(s0)
   169d8:	00070613          	mv	a2,a4
   169dc:	00078593          	mv	a1,a5
   169e0:	0001e7b7          	lui	a5,0x1e
   169e4:	be878513          	addi	a0,a5,-1048 # 1dbe8 <FCVT_WU_D_TESTS+0x5b0>
   169e8:	f69fb0ef          	jal	ra,12950 <printf_uart>
        restore_state(pmp->mtvec, pmp->mstatus);
   169ec:	fc843783          	ld	a5,-56(s0)
   169f0:	0007b703          	ld	a4,0(a5)
   169f4:	fc843783          	ld	a5,-56(s0)
   169f8:	0087b783          	ld	a5,8(a5)
   169fc:	00078593          	mv	a1,a5
   16a00:	00070513          	mv	a0,a4
   16a04:	de9ff0ef          	jal	ra,167ec <restore_state>
        return;
   16a08:	1480006f          	j	16b50 <test_pmp+0x318>
    }

    uint64_t mstatus_s = pmp->mstatus;
   16a0c:	fc843783          	ld	a5,-56(s0)
   16a10:	0087b783          	ld	a5,8(a5)
   16a14:	faf43023          	sd	a5,-96(s0)
    mstatus_s &= ~(MSTATUS_MPP_M);
   16a18:	fa043703          	ld	a4,-96(s0)
   16a1c:	ffffe7b7          	lui	a5,0xffffe
   16a20:	7ff78793          	addi	a5,a5,2047 # ffffffffffffe7ff <_end+0xfffffffffffdef63>
   16a24:	00f777b3          	and	a5,a4,a5
   16a28:	faf43023          	sd	a5,-96(s0)
    mstatus_s |= MSTATUS_MPP_S;  // set MPP to S-mode
   16a2c:	fa043703          	ld	a4,-96(s0)
   16a30:	000017b7          	lui	a5,0x1
   16a34:	80078793          	addi	a5,a5,-2048 # 800 <_ftext-0xf800>
   16a38:	00f767b3          	or	a5,a4,a5
   16a3c:	faf43023          	sd	a5,-96(s0)
    mstatus_s |= MSTATUS_MPRV;
   16a40:	fa043703          	ld	a4,-96(s0)
   16a44:	000207b7          	lui	a5,0x20
   16a48:	00f767b3          	or	a5,a4,a5
   16a4c:	faf43023          	sd	a5,-96(s0)
    write_csr(mstatus, mstatus_s);
   16a50:	fa043783          	ld	a5,-96(s0)
   16a54:	30079073          	csrw	mstatus,a5

    // Check write32 and read32 access to RO with interrupt
    wValue = W32_NO_INTERRUPT;
   16a58:	334457b7          	lui	a5,0x33445
   16a5c:	5667879b          	addiw	a5,a5,1382
   16a60:	faf42a23          	sw	a5,-76(s0)
    asm volatile ("la %[tlabel], 1f\n\t"
   16a64:	fff00693          	li	a3,-1
   16a68:	fb442783          	lw	a5,-76(s0)
   16a6c:	00000717          	auipc	a4,0x0
   16a70:	01c70713          	addi	a4,a4,28 # 16a88 <test_pmp+0x250>
   16a74:	30571773          	csrrw	a4,mtvec,a4
   16a78:	0000100f          	fence.i
   16a7c:	00f2a023          	sw	a5,0(t0)
   16a80:	0000100f          	fence.i
   16a84:	0080006f          	j	16a8c <test_pmp+0x254>
   16a88:	00068793          	mv	a5,a3
   16a8c:	00000013          	nop
   16a90:	fae43423          	sd	a4,-88(s0)
   16a94:	faf42a23          	sw	a5,-76(s0)
                  "2: nop\r\n"
                : [tlabel] "=&r" (tlabel),
                  [wValue] "+r" (wValue)
                : [m1] "r" (-1U));

    if (wValue != ~0 || *pmp->p_r_only != W32_NO_INTERRUPT) {
   16a98:	fb442783          	lw	a5,-76(s0)
   16a9c:	0007871b          	sext.w	a4,a5
   16aa0:	fff00793          	li	a5,-1
   16aa4:	02f71263          	bne	a4,a5,16ac8 <test_pmp+0x290>
   16aa8:	fc843783          	ld	a5,-56(s0)
   16aac:	0187b783          	ld	a5,24(a5) # 33445018 <_end+0x3342577c>
   16ab0:	0007a783          	lw	a5,0(a5)
   16ab4:	0007879b          	sext.w	a5,a5
   16ab8:	00078713          	mv	a4,a5
   16abc:	334457b7          	lui	a5,0x33445
   16ac0:	56678793          	addi	a5,a5,1382 # 33445566 <_end+0x33425cca>
   16ac4:	04f70a63          	beq	a4,a5,16b18 <test_pmp+0x2e0>
        printf_uart("FAIL(2), wValue=%08x, r_only=%08x\r\n", wValue, *pmp->p_r_only);
   16ac8:	fc843783          	ld	a5,-56(s0)
   16acc:	0187b783          	ld	a5,24(a5)
   16ad0:	0007a783          	lw	a5,0(a5)
   16ad4:	0007871b          	sext.w	a4,a5
   16ad8:	fb442783          	lw	a5,-76(s0)
   16adc:	00070613          	mv	a2,a4
   16ae0:	00078593          	mv	a1,a5
   16ae4:	0001e7b7          	lui	a5,0x1e
   16ae8:	c1078513          	addi	a0,a5,-1008 # 1dc10 <FCVT_WU_D_TESTS+0x5d8>
   16aec:	ffffc097          	auipc	ra,0xffffc
   16af0:	e64080e7          	jalr	-412(ra) # 12950 <printf_uart>
        restore_state(pmp->mtvec, pmp->mstatus);
   16af4:	fc843783          	ld	a5,-56(s0)
   16af8:	0007b703          	ld	a4,0(a5)
   16afc:	fc843783          	ld	a5,-56(s0)
   16b00:	0087b783          	ld	a5,8(a5)
   16b04:	00078593          	mv	a1,a5
   16b08:	00070513          	mv	a0,a4
   16b0c:	00000097          	auipc	ra,0x0
   16b10:	ce0080e7          	jalr	-800(ra) # 167ec <restore_state>
        return;
   16b14:	03c0006f          	j	16b50 <test_pmp+0x318>
    }

    restore_state(pmp->mtvec, pmp->mstatus);
   16b18:	fc843783          	ld	a5,-56(s0)
   16b1c:	0007b703          	ld	a4,0(a5)
   16b20:	fc843783          	ld	a5,-56(s0)
   16b24:	0087b783          	ld	a5,8(a5)
   16b28:	00078593          	mv	a1,a5
   16b2c:	00070513          	mv	a0,a4
   16b30:	00000097          	auipc	ra,0x0
   16b34:	cbc080e7          	jalr	-836(ra) # 167ec <restore_state>
    printf_uart("%s", "PASS\r\n");
   16b38:	0001e7b7          	lui	a5,0x1e
   16b3c:	c3878593          	addi	a1,a5,-968 # 1dc38 <FCVT_WU_D_TESTS+0x600>
   16b40:	0001e7b7          	lui	a5,0x1e
   16b44:	be078513          	addi	a0,a5,-1056 # 1dbe0 <FCVT_WU_D_TESTS+0x5a8>
   16b48:	ffffc097          	auipc	ra,0xffffc
   16b4c:	e08080e7          	jalr	-504(ra) # 12950 <printf_uart>
}
   16b50:	05813083          	ld	ra,88(sp)
   16b54:	05013403          	ld	s0,80(sp)
   16b58:	06010113          	addi	sp,sp,96
   16b5c:	00008067          	ret
   16b60:	0000                	unimp
	...

0000000000016b64 <get_dev_bar>:
static uint64_t get_dev_bar(pnp_map *pnp, uint16_t vid, uint16_t did) {
   16b64:	fb010113          	addi	sp,sp,-80
   16b68:	04813423          	sd	s0,72(sp)
   16b6c:	05010413          	addi	s0,sp,80
   16b70:	faa43c23          	sd	a0,-72(s0)
   16b74:	00058793          	mv	a5,a1
   16b78:	00060713          	mv	a4,a2
   16b7c:	faf41b23          	sh	a5,-74(s0)
   16b80:	00070793          	mv	a5,a4
   16b84:	faf41a23          	sh	a5,-76(s0)
    int slots_total = (pnp->cfg >> 8) & 0xFF;
   16b88:	fb843783          	ld	a5,-72(s0)
   16b8c:	0087a783          	lw	a5,8(a5)
   16b90:	0087d79b          	srliw	a5,a5,0x8
   16b94:	0007879b          	sext.w	a5,a5
   16b98:	0007879b          	sext.w	a5,a5
   16b9c:	0ff7f793          	andi	a5,a5,255
   16ba0:	fef42223          	sw	a5,-28(s0)
    int off = 0;
   16ba4:	fe042623          	sw	zero,-20(s0)
    for (int i = 0; i < slots_total; i++) {
   16ba8:	fe042423          	sw	zero,-24(s0)
   16bac:	09c0006f          	j	16c48 <get_dev_bar+0xe4>
        dcfg = *(dev_cfg_type *)&pnp->cfg_table[off];
   16bb0:	fec42783          	lw	a5,-20(s0)
   16bb4:	04078793          	addi	a5,a5,64
   16bb8:	fb843703          	ld	a4,-72(s0)
   16bbc:	00f707b3          	add	a5,a4,a5
   16bc0:	0007b703          	ld	a4,0(a5)
   16bc4:	fce43023          	sd	a4,-64(s0)
   16bc8:	0087b703          	ld	a4,8(a5)
   16bcc:	fce43423          	sd	a4,-56(s0)
   16bd0:	0107b703          	ld	a4,16(a5)
   16bd4:	fce43823          	sd	a4,-48(s0)
   16bd8:	0187b783          	ld	a5,24(a5)
   16bdc:	fcf43c23          	sd	a5,-40(s0)
        off += sizeof(dcfg);
   16be0:	fec42783          	lw	a5,-20(s0)
   16be4:	0207879b          	addiw	a5,a5,32
   16be8:	0007879b          	sext.w	a5,a5
   16bec:	fef42623          	sw	a5,-20(s0)
        if (dcfg.u.descrtype != PNP_CFG_TYPE_SLAVE) {
   16bf0:	fc144783          	lbu	a5,-63(s0)
   16bf4:	0037f793          	andi	a5,a5,3
   16bf8:	0ff7f793          	andi	a5,a5,255
   16bfc:	00078713          	mv	a4,a5
   16c00:	00200793          	li	a5,2
   16c04:	02f71a63          	bne	a4,a5,16c38 <get_dev_bar+0xd4>
        if (dcfg.u.vid == vid && dcfg.u.did == did) {
   16c08:	fc645783          	lhu	a5,-58(s0)
   16c0c:	fb645703          	lhu	a4,-74(s0)
   16c10:	0007071b          	sext.w	a4,a4
   16c14:	0007879b          	sext.w	a5,a5
   16c18:	02f71263          	bne	a4,a5,16c3c <get_dev_bar+0xd8>
   16c1c:	fc445783          	lhu	a5,-60(s0)
   16c20:	fb445703          	lhu	a4,-76(s0)
   16c24:	0007071b          	sext.w	a4,a4
   16c28:	0007879b          	sext.w	a5,a5
   16c2c:	00f71863          	bne	a4,a5,16c3c <get_dev_bar+0xd8>
            return dcfg.u.addr_start;
   16c30:	fd043783          	ld	a5,-48(s0)
   16c34:	02c0006f          	j	16c60 <get_dev_bar+0xfc>
            continue;
   16c38:	00000013          	nop
    for (int i = 0; i < slots_total; i++) {
   16c3c:	fe842783          	lw	a5,-24(s0)
   16c40:	0017879b          	addiw	a5,a5,1
   16c44:	fef42423          	sw	a5,-24(s0)
   16c48:	fe842703          	lw	a4,-24(s0)
   16c4c:	fe442783          	lw	a5,-28(s0)
   16c50:	0007071b          	sext.w	a4,a4
   16c54:	0007879b          	sext.w	a5,a5
   16c58:	f4f74ce3          	blt	a4,a5,16bb0 <get_dev_bar+0x4c>
    return DEV_NONE;
   16c5c:	fff00793          	li	a5,-1
}
   16c60:	00078513          	mv	a0,a5
   16c64:	04813403          	ld	s0,72(sp)
   16c68:	05010113          	addi	sp,sp,80
   16c6c:	00008067          	ret

0000000000016c70 <mpu_region_total>:
static int mpu_region_total() {
   16c70:	fe010113          	addi	sp,sp,-32
   16c74:	00813c23          	sd	s0,24(sp)
   16c78:	02010413          	addi	s0,sp,32
    uint64_t val = 0;
   16c7c:	fe043423          	sd	zero,-24(s0)
    asm("csrr %0, 0xBC4" : "=r" (val));
   16c80:	bc4027f3          	csrr	a5,0xbc4
   16c84:	fef43423          	sd	a5,-24(s0)
    return (int)(val >> 8);
   16c88:	fe843783          	ld	a5,-24(s0)
   16c8c:	0087d793          	srli	a5,a5,0x8
   16c90:	0007879b          	sext.w	a5,a5
}
   16c94:	00078513          	mv	a0,a5
   16c98:	01813403          	ld	s0,24(sp)
   16c9c:	02010113          	addi	sp,sp,32
   16ca0:	00008067          	ret

0000000000016ca4 <mpu_disable_region>:
static void mpu_disable_region(int idx) {
   16ca4:	fd010113          	addi	sp,sp,-48
   16ca8:	02813423          	sd	s0,40(sp)
   16cac:	03010413          	addi	s0,sp,48
   16cb0:	00050793          	mv	a5,a0
   16cb4:	fcf42e23          	sw	a5,-36(s0)
    ctrl.value = 0;
   16cb8:	fe043423          	sd	zero,-24(s0)
    ctrl.bits.IDX = idx;
   16cbc:	fdc42783          	lw	a5,-36(s0)
   16cc0:	0ff7f793          	andi	a5,a5,255
   16cc4:	fef404a3          	sb	a5,-23(s0)
    ctrl.bits.WE = 1;
   16cc8:	fe844783          	lbu	a5,-24(s0)
   16ccc:	f807e793          	ori	a5,a5,-128
   16cd0:	fef40423          	sb	a5,-24(s0)
    asm("csrw 0xBC4, %0" : :"r"(ctrl.value));
   16cd4:	fe843783          	ld	a5,-24(s0)
   16cd8:	bc479073          	csrw	0xbc4,a5
}
   16cdc:	00000013          	nop
   16ce0:	02813403          	ld	s0,40(sp)
   16ce4:	03010113          	addi	sp,sp,48
   16ce8:	00008067          	ret

0000000000016cec <mpu_enable_region>:
                       const char *rwx) {
   16cec:	fb010113          	addi	sp,sp,-80
   16cf0:	04813423          	sd	s0,72(sp)
   16cf4:	05010413          	addi	s0,sp,80
   16cf8:	00050793          	mv	a5,a0
   16cfc:	fcb43023          	sd	a1,-64(s0)
   16d00:	fac43c23          	sd	a2,-72(s0)
   16d04:	fae43823          	sd	a4,-80(s0)
   16d08:	fcf42623          	sw	a5,-52(s0)
   16d0c:	00068793          	mv	a5,a3
   16d10:	fcf42423          	sw	a5,-56(s0)
    uint64_t mask = (~0ull) << 10;
   16d14:	c0000793          	li	a5,-1024
   16d18:	fef43423          	sd	a5,-24(s0)
    const char *p = rwx;
   16d1c:	fb043783          	ld	a5,-80(s0)
   16d20:	fef43023          	sd	a5,-32(s0)
    asm("csrw 0xBC2, %0" : :"r"(bar));
   16d24:	fc043783          	ld	a5,-64(s0)
   16d28:	bc279073          	csrw	0xbc2,a5
    KB >>= 1;
   16d2c:	fb843783          	ld	a5,-72(s0)
   16d30:	0017d793          	srli	a5,a5,0x1
   16d34:	faf43c23          	sd	a5,-72(s0)
    while (KB) {
   16d38:	01c0006f          	j	16d54 <mpu_enable_region+0x68>
        mask <<= 1;
   16d3c:	fe843783          	ld	a5,-24(s0)
   16d40:	00179793          	slli	a5,a5,0x1
   16d44:	fef43423          	sd	a5,-24(s0)
        KB >>= 1;
   16d48:	fb843783          	ld	a5,-72(s0)
   16d4c:	0017d793          	srli	a5,a5,0x1
   16d50:	faf43c23          	sd	a5,-72(s0)
    while (KB) {
   16d54:	fb843783          	ld	a5,-72(s0)
   16d58:	fe0792e3          	bnez	a5,16d3c <mpu_enable_region+0x50>
    asm("csrw 0xBC3, %0" : :"r"(mask));
   16d5c:	fe843783          	ld	a5,-24(s0)
   16d60:	bc379073          	csrw	0xbc3,a5
    ctrl.value = 0;
   16d64:	fc043c23          	sd	zero,-40(s0)
    ctrl.bits.IDX = idx;
   16d68:	fcc42783          	lw	a5,-52(s0)
   16d6c:	0ff7f793          	andi	a5,a5,255
   16d70:	fcf40ca3          	sb	a5,-39(s0)
    ctrl.bits.ENA = 1;
   16d74:	fd844783          	lbu	a5,-40(s0)
   16d78:	0107e793          	ori	a5,a5,16
   16d7c:	fcf40c23          	sb	a5,-40(s0)
    ctrl.bits.CACHABLE = cached;
   16d80:	fc842783          	lw	a5,-56(s0)
   16d84:	0017f793          	andi	a5,a5,1
   16d88:	0ff7f793          	andi	a5,a5,255
   16d8c:	0017f793          	andi	a5,a5,1
   16d90:	0037969b          	slliw	a3,a5,0x3
   16d94:	fd844783          	lbu	a5,-40(s0)
   16d98:	ff77f793          	andi	a5,a5,-9
   16d9c:	00078713          	mv	a4,a5
   16da0:	00068793          	mv	a5,a3
   16da4:	00f767b3          	or	a5,a4,a5
   16da8:	fcf40c23          	sb	a5,-40(s0)
    ctrl.bits.WE = 1; // write into MPU
   16dac:	fd844783          	lbu	a5,-40(s0)
   16db0:	f807e793          	ori	a5,a5,-128
   16db4:	fcf40c23          	sb	a5,-40(s0)
    while (*p) {
   16db8:	0700006f          	j	16e28 <mpu_enable_region+0x13c>
        if (*p == 'r') {
   16dbc:	fe043783          	ld	a5,-32(s0)
   16dc0:	0007c783          	lbu	a5,0(a5)
   16dc4:	00078713          	mv	a4,a5
   16dc8:	07200793          	li	a5,114
   16dcc:	00f71863          	bne	a4,a5,16ddc <mpu_enable_region+0xf0>
            ctrl.bits.RD = 1;
   16dd0:	fd844783          	lbu	a5,-40(s0)
   16dd4:	0027e793          	ori	a5,a5,2
   16dd8:	fcf40c23          	sb	a5,-40(s0)
        if (*p == 'w') {
   16ddc:	fe043783          	ld	a5,-32(s0)
   16de0:	0007c783          	lbu	a5,0(a5)
   16de4:	00078713          	mv	a4,a5
   16de8:	07700793          	li	a5,119
   16dec:	00f71863          	bne	a4,a5,16dfc <mpu_enable_region+0x110>
            ctrl.bits.WR = 1;
   16df0:	fd844783          	lbu	a5,-40(s0)
   16df4:	0017e793          	ori	a5,a5,1
   16df8:	fcf40c23          	sb	a5,-40(s0)
        if (*p == 'x') {
   16dfc:	fe043783          	ld	a5,-32(s0)
   16e00:	0007c783          	lbu	a5,0(a5)
   16e04:	00078713          	mv	a4,a5
   16e08:	07800793          	li	a5,120
   16e0c:	00f71863          	bne	a4,a5,16e1c <mpu_enable_region+0x130>
            ctrl.bits.EXEC = 1;
   16e10:	fd844783          	lbu	a5,-40(s0)
   16e14:	0047e793          	ori	a5,a5,4
   16e18:	fcf40c23          	sb	a5,-40(s0)
        p++;
   16e1c:	fe043783          	ld	a5,-32(s0)
   16e20:	00178793          	addi	a5,a5,1
   16e24:	fef43023          	sd	a5,-32(s0)
    while (*p) {
   16e28:	fe043783          	ld	a5,-32(s0)
   16e2c:	0007c783          	lbu	a5,0(a5)
   16e30:	f80796e3          	bnez	a5,16dbc <mpu_enable_region+0xd0>
    asm("csrw 0xBC4, %0" : :"r"(ctrl.value));
   16e34:	fd843783          	ld	a5,-40(s0)
   16e38:	bc479073          	csrw	0xbc4,a5
}
   16e3c:	00000013          	nop
   16e40:	04813403          	ld	s0,72(sp)
   16e44:	05010113          	addi	sp,sp,80
   16e48:	00008067          	ret

0000000000016e4c <error>:
};

static virtual_memory_system_t *vms = &sv39;

void error()
{
   16e4c:	ff010113          	addi	sp,sp,-16
   16e50:	00813423          	sd	s0,8(sp)
   16e54:	01010413          	addi	s0,sp,16
    while (1)
   16e58:	0000006f          	j	16e58 <error+0xc>

0000000000016e5c <assert>:
        ;
}

void assert(int condition)
{
   16e5c:	fe010113          	addi	sp,sp,-32
   16e60:	00113c23          	sd	ra,24(sp)
   16e64:	00813823          	sd	s0,16(sp)
   16e68:	02010413          	addi	s0,sp,32
   16e6c:	00050793          	mv	a5,a0
   16e70:	fef42623          	sw	a5,-20(s0)
    if (!condition) {
   16e74:	fec42783          	lw	a5,-20(s0)
   16e78:	0007879b          	sext.w	a5,a5
   16e7c:	02079063          	bnez	a5,16e9c <assert+0x40>
        printf_uart("%s", "FAIL,ASSERT\r\n");
   16e80:	0001e7b7          	lui	a5,0x1e
   16e84:	c4078593          	addi	a1,a5,-960 # 1dc40 <FCVT_WU_D_TESTS+0x608>
   16e88:	0001e7b7          	lui	a5,0x1e
   16e8c:	c5078513          	addi	a0,a5,-944 # 1dc50 <FCVT_WU_D_TESTS+0x618>
   16e90:	ac1fb0ef          	jal	ra,12950 <printf_uart>
        error();
   16e94:	00000097          	auipc	ra,0x0
   16e98:	fb8080e7          	jalr	-72(ra) # 16e4c <error>
    }
}
   16e9c:	00000013          	nop
   16ea0:	01813083          	ld	ra,24(sp)
   16ea4:	01013403          	ld	s0,16(sp)
   16ea8:	02010113          	addi	sp,sp,32
   16eac:	00008067          	ret

0000000000016eb0 <get_page>:

// Return a 4Kb, aligned, page.
void *get_page(mmu_type *mmu)
{
   16eb0:	fd010113          	addi	sp,sp,-48
   16eb4:	02813423          	sd	s0,40(sp)
   16eb8:	03010413          	addi	s0,sp,48
   16ebc:	fca43c23          	sd	a0,-40(s0)
    mmu->next = (char *) (((unsigned long) mmu->next + 4095) & ~0xfff);
   16ec0:	fd843703          	ld	a4,-40(s0)
   16ec4:	000087b7          	lui	a5,0x8
   16ec8:	00f707b3          	add	a5,a4,a5
   16ecc:	0007b783          	ld	a5,0(a5) # 8000 <_ftext-0x8000>
   16ed0:	00078713          	mv	a4,a5
   16ed4:	000017b7          	lui	a5,0x1
   16ed8:	fff78793          	addi	a5,a5,-1 # fff <_ftext-0xf001>
   16edc:	00f70733          	add	a4,a4,a5
   16ee0:	fffff7b7          	lui	a5,0xfffff
   16ee4:	00f777b3          	and	a5,a4,a5
   16ee8:	00078693          	mv	a3,a5
   16eec:	fd843703          	ld	a4,-40(s0)
   16ef0:	000087b7          	lui	a5,0x8
   16ef4:	00f707b3          	add	a5,a4,a5
   16ef8:	00d7b023          	sd	a3,0(a5) # 8000 <_ftext-0x8000>
    while (mmu->next + 4096 >= mmu->buf + sizeof(mmu->buf))
   16efc:	00000013          	nop
   16f00:	fd843703          	ld	a4,-40(s0)
   16f04:	000087b7          	lui	a5,0x8
   16f08:	00f707b3          	add	a5,a4,a5
   16f0c:	0007b703          	ld	a4,0(a5) # 8000 <_ftext-0x8000>
   16f10:	000017b7          	lui	a5,0x1
   16f14:	00f70733          	add	a4,a4,a5
   16f18:	fd843683          	ld	a3,-40(s0)
   16f1c:	000087b7          	lui	a5,0x8
   16f20:	00f687b3          	add	a5,a3,a5
   16f24:	fcf77ee3          	bleu	a5,a4,16f00 <get_page+0x50>
        ;
    void *result = mmu->next;
   16f28:	fd843703          	ld	a4,-40(s0)
   16f2c:	000087b7          	lui	a5,0x8
   16f30:	00f707b3          	add	a5,a4,a5
   16f34:	0007b783          	ld	a5,0(a5) # 8000 <_ftext-0x8000>
   16f38:	fef43423          	sd	a5,-24(s0)
    mmu->next += 4096;
   16f3c:	fd843703          	ld	a4,-40(s0)
   16f40:	000087b7          	lui	a5,0x8
   16f44:	00f707b3          	add	a5,a4,a5
   16f48:	0007b703          	ld	a4,0(a5) # 8000 <_ftext-0x8000>
   16f4c:	000017b7          	lui	a5,0x1
   16f50:	00f70733          	add	a4,a4,a5
   16f54:	fd843683          	ld	a3,-40(s0)
   16f58:	000087b7          	lui	a5,0x8
   16f5c:	00f687b3          	add	a5,a3,a5
   16f60:	00e7b023          	sd	a4,0(a5) # 8000 <_ftext-0x8000>
    return result;
   16f64:	fe843783          	ld	a5,-24(s0)
}
   16f68:	00078513          	mv	a0,a5
   16f6c:	02813403          	ld	s0,40(sp)
   16f70:	03010113          	addi	sp,sp,48
   16f74:	00008067          	ret

0000000000016f78 <entry>:

reg_t entry(char *table, unsigned index)
{
   16f78:	fe010113          	addi	sp,sp,-32
   16f7c:	00113c23          	sd	ra,24(sp)
   16f80:	00813823          	sd	s0,16(sp)
   16f84:	02010413          	addi	s0,sp,32
   16f88:	fea43423          	sd	a0,-24(s0)
   16f8c:	00058793          	mv	a5,a1
   16f90:	fef42223          	sw	a5,-28(s0)
    if (vms->entry_width_bytes == 4)
   16f94:	0001f7b7          	lui	a5,0x1f
   16f98:	6087b783          	ld	a5,1544(a5) # 1f608 <vms>
   16f9c:	0307a783          	lw	a5,48(a5)
   16fa0:	00078713          	mv	a4,a5
   16fa4:	00400793          	li	a5,4
   16fa8:	02f71263          	bne	a4,a5,16fcc <entry+0x54>
        return ((uint32_t *) table)[index];
   16fac:	fe446783          	lwu	a5,-28(s0)
   16fb0:	00279793          	slli	a5,a5,0x2
   16fb4:	fe843703          	ld	a4,-24(s0)
   16fb8:	00f707b3          	add	a5,a4,a5
   16fbc:	0007a783          	lw	a5,0(a5)
   16fc0:	02079793          	slli	a5,a5,0x20
   16fc4:	0207d793          	srli	a5,a5,0x20
   16fc8:	03c0006f          	j	17004 <entry+0x8c>
    else if (vms->entry_width_bytes == 8)
   16fcc:	0001f7b7          	lui	a5,0x1f
   16fd0:	6087b783          	ld	a5,1544(a5) # 1f608 <vms>
   16fd4:	0307a783          	lw	a5,48(a5)
   16fd8:	00078713          	mv	a4,a5
   16fdc:	00800793          	li	a5,8
   16fe0:	00f71e63          	bne	a4,a5,16ffc <entry+0x84>
        return ((uint64_t *) table)[index];
   16fe4:	fe446783          	lwu	a5,-28(s0)
   16fe8:	00379793          	slli	a5,a5,0x3
   16fec:	fe843703          	ld	a4,-24(s0)
   16ff0:	00f707b3          	add	a5,a4,a5
   16ff4:	0007b783          	ld	a5,0(a5)
   16ff8:	00c0006f          	j	17004 <entry+0x8c>
    else
        assert(0);
   16ffc:	00000513          	li	a0,0
   17000:	e5dff0ef          	jal	ra,16e5c <assert>
}
   17004:	00078513          	mv	a0,a5
   17008:	01813083          	ld	ra,24(sp)
   1700c:	01013403          	ld	s0,16(sp)
   17010:	02010113          	addi	sp,sp,32
   17014:	00008067          	ret

0000000000017018 <entry_set>:

void entry_set(char *table, unsigned index, uint64_t value)
{
   17018:	fd010113          	addi	sp,sp,-48
   1701c:	02113423          	sd	ra,40(sp)
   17020:	02813023          	sd	s0,32(sp)
   17024:	03010413          	addi	s0,sp,48
   17028:	fea43423          	sd	a0,-24(s0)
   1702c:	00058793          	mv	a5,a1
   17030:	fcc43c23          	sd	a2,-40(s0)
   17034:	fef42223          	sw	a5,-28(s0)
    if (vms->entry_width_bytes == 4)
   17038:	0001f7b7          	lui	a5,0x1f
   1703c:	6087b783          	ld	a5,1544(a5) # 1f608 <vms>
   17040:	0307a783          	lw	a5,48(a5)
   17044:	00078713          	mv	a4,a5
   17048:	00400793          	li	a5,4
   1704c:	02f71263          	bne	a4,a5,17070 <entry_set+0x58>
        ((uint32_t *) table)[index] = value;
   17050:	fe446783          	lwu	a5,-28(s0)
   17054:	00279793          	slli	a5,a5,0x2
   17058:	fe843703          	ld	a4,-24(s0)
   1705c:	00f707b3          	add	a5,a4,a5
   17060:	fd843703          	ld	a4,-40(s0)
   17064:	0007071b          	sext.w	a4,a4
   17068:	00e7a023          	sw	a4,0(a5)
    else if (vms->entry_width_bytes == 8)
        ((uint64_t *) table)[index] = value;
    else
        assert(0);
}
   1706c:	0440006f          	j	170b0 <entry_set+0x98>
    else if (vms->entry_width_bytes == 8)
   17070:	0001f7b7          	lui	a5,0x1f
   17074:	6087b783          	ld	a5,1544(a5) # 1f608 <vms>
   17078:	0307a783          	lw	a5,48(a5)
   1707c:	00078713          	mv	a4,a5
   17080:	00800793          	li	a5,8
   17084:	02f71063          	bne	a4,a5,170a4 <entry_set+0x8c>
        ((uint64_t *) table)[index] = value;
   17088:	fe446783          	lwu	a5,-28(s0)
   1708c:	00379793          	slli	a5,a5,0x3
   17090:	fe843703          	ld	a4,-24(s0)
   17094:	00f707b3          	add	a5,a4,a5
   17098:	fd843703          	ld	a4,-40(s0)
   1709c:	00e7b023          	sd	a4,0(a5)
}
   170a0:	0100006f          	j	170b0 <entry_set+0x98>
        assert(0);
   170a4:	00000513          	li	a0,0
   170a8:	00000097          	auipc	ra,0x0
   170ac:	db4080e7          	jalr	-588(ra) # 16e5c <assert>
}
   170b0:	00000013          	nop
   170b4:	02813083          	ld	ra,40(sp)
   170b8:	02013403          	ld	s0,32(sp)
   170bc:	03010113          	addi	sp,sp,48
   170c0:	00008067          	ret

00000000000170c4 <setup_page_table>:

// Set up 1-to-1 for this entire table.
void setup_page_table(char *table, unsigned level, uint64_t physical)
{
   170c4:	fa010113          	addi	sp,sp,-96
   170c8:	04113c23          	sd	ra,88(sp)
   170cc:	04813823          	sd	s0,80(sp)
   170d0:	06010413          	addi	s0,sp,96
   170d4:	faa43c23          	sd	a0,-72(s0)
   170d8:	00058793          	mv	a5,a1
   170dc:	fac43423          	sd	a2,-88(s0)
   170e0:	faf42a23          	sw	a5,-76(s0)
#ifdef MMU_FAST_TEST
    for (unsigned i = 0; i < 4; i++) {
   170e4:	fe042623          	sw	zero,-20(s0)
   170e8:	0c00006f          	j	171a8 <setup_page_table+0xe4>
#else
    for (unsigned i = 0; i < (1<<vms->vpn_width_bits); i++) {
#endif
        uint64_t pte = PTE_V | PTE_R | PTE_W | PTE_X | PTE_U | PTE_A | PTE_D;
   170ec:	0df00793          	li	a5,223
   170f0:	fcf43423          	sd	a5,-56(s0)
        // Add in portion of physical address.
        pte |= physical & (((1LL<<vms->vpn_width_bits)-1) <<
   170f4:	0001f7b7          	lui	a5,0x1f
   170f8:	6087b783          	ld	a5,1544(a5) # 1f608 <vms>
   170fc:	0347a783          	lw	a5,52(a5)
   17100:	00100713          	li	a4,1
   17104:	00f717b3          	sll	a5,a4,a5
   17108:	fff78713          	addi	a4,a5,-1
                (PTE_PPN_SHIFT + (level+1) * vms->vpn_width_bits));
   1710c:	fb442783          	lw	a5,-76(s0)
   17110:	0017879b          	addiw	a5,a5,1
   17114:	0007869b          	sext.w	a3,a5
   17118:	0001f7b7          	lui	a5,0x1f
   1711c:	6087b783          	ld	a5,1544(a5) # 1f608 <vms>
   17120:	0347a783          	lw	a5,52(a5)
   17124:	02f687bb          	mulw	a5,a3,a5
   17128:	0007879b          	sext.w	a5,a5
   1712c:	00a7879b          	addiw	a5,a5,10
   17130:	0007879b          	sext.w	a5,a5
        pte |= physical & (((1LL<<vms->vpn_width_bits)-1) <<
   17134:	00f717b3          	sll	a5,a4,a5
   17138:	00078713          	mv	a4,a5
   1713c:	fa843783          	ld	a5,-88(s0)
   17140:	00f777b3          	and	a5,a4,a5
   17144:	fc843703          	ld	a4,-56(s0)
   17148:	00f767b3          	or	a5,a4,a5
   1714c:	fcf43423          	sd	a5,-56(s0)
        // Add in the index.
        pte |= ((reg_t) i) << (PTE_PPN_SHIFT + level * vms->vpn_width_bits);
   17150:	fec46703          	lwu	a4,-20(s0)
   17154:	0001f7b7          	lui	a5,0x1f
   17158:	6087b783          	ld	a5,1544(a5) # 1f608 <vms>
   1715c:	0347a783          	lw	a5,52(a5)
   17160:	fb442683          	lw	a3,-76(s0)
   17164:	02f687bb          	mulw	a5,a3,a5
   17168:	0007879b          	sext.w	a5,a5
   1716c:	00a7879b          	addiw	a5,a5,10
   17170:	0007879b          	sext.w	a5,a5
   17174:	00f717b3          	sll	a5,a4,a5
   17178:	fc843703          	ld	a4,-56(s0)
   1717c:	00f767b3          	or	a5,a4,a5
   17180:	fcf43423          	sd	a5,-56(s0)
        entry_set(table, i, pte);
   17184:	fec42783          	lw	a5,-20(s0)
   17188:	fc843603          	ld	a2,-56(s0)
   1718c:	00078593          	mv	a1,a5
   17190:	fb843503          	ld	a0,-72(s0)
   17194:	00000097          	auipc	ra,0x0
   17198:	e84080e7          	jalr	-380(ra) # 17018 <entry_set>
    for (unsigned i = 0; i < 4; i++) {
   1719c:	fec42783          	lw	a5,-20(s0)
   171a0:	0017879b          	addiw	a5,a5,1
   171a4:	fef42623          	sw	a5,-20(s0)
   171a8:	fec42783          	lw	a5,-20(s0)
   171ac:	0007871b          	sext.w	a4,a5
   171b0:	00300793          	li	a5,3
   171b4:	f2e7fce3          	bleu	a4,a5,170ec <setup_page_table+0x28>
    // level0 bits 47:39 = 1.1110.0000
    // sv39
    // va = 0xff.ff80.0800.3004
    // level0 bits 38:30 = 1.1110.0000
    {
        unsigned i = 0x1e0;
   171b8:	1e000793          	li	a5,480
   171bc:	fef42423          	sw	a5,-24(s0)

        uint64_t pte = PTE_V | PTE_R | PTE_W | PTE_X | PTE_U | PTE_A | PTE_D;
   171c0:	0df00793          	li	a5,223
   171c4:	fef43023          	sd	a5,-32(s0)
        // Add in portion of physical address.
        pte |= physical & (((1LL<<vms->vpn_width_bits)-1) <<
   171c8:	0001f7b7          	lui	a5,0x1f
   171cc:	6087b783          	ld	a5,1544(a5) # 1f608 <vms>
   171d0:	0347a783          	lw	a5,52(a5)
   171d4:	00100713          	li	a4,1
   171d8:	00f717b3          	sll	a5,a4,a5
   171dc:	fff78713          	addi	a4,a5,-1
                (PTE_PPN_SHIFT + (level+1) * vms->vpn_width_bits));
   171e0:	fb442783          	lw	a5,-76(s0)
   171e4:	0017879b          	addiw	a5,a5,1
   171e8:	0007869b          	sext.w	a3,a5
   171ec:	0001f7b7          	lui	a5,0x1f
   171f0:	6087b783          	ld	a5,1544(a5) # 1f608 <vms>
   171f4:	0347a783          	lw	a5,52(a5)
   171f8:	02f687bb          	mulw	a5,a3,a5
   171fc:	0007879b          	sext.w	a5,a5
   17200:	00a7879b          	addiw	a5,a5,10
   17204:	0007879b          	sext.w	a5,a5
        pte |= physical & (((1LL<<vms->vpn_width_bits)-1) <<
   17208:	00f717b3          	sll	a5,a4,a5
   1720c:	00078713          	mv	a4,a5
   17210:	fa843783          	ld	a5,-88(s0)
   17214:	00f777b3          	and	a5,a4,a5
   17218:	fe043703          	ld	a4,-32(s0)
   1721c:	00f767b3          	or	a5,a4,a5
   17220:	fef43023          	sd	a5,-32(s0)
        // Add in the index.
        pte |= ((reg_t) i) << (PTE_PPN_SHIFT + level * vms->vpn_width_bits);
   17224:	fe846703          	lwu	a4,-24(s0)
   17228:	0001f7b7          	lui	a5,0x1f
   1722c:	6087b783          	ld	a5,1544(a5) # 1f608 <vms>
   17230:	0347a783          	lw	a5,52(a5)
   17234:	fb442683          	lw	a3,-76(s0)
   17238:	02f687bb          	mulw	a5,a3,a5
   1723c:	0007879b          	sext.w	a5,a5
   17240:	00a7879b          	addiw	a5,a5,10
   17244:	0007879b          	sext.w	a5,a5
   17248:	00f717b3          	sll	a5,a4,a5
   1724c:	fe043703          	ld	a4,-32(s0)
   17250:	00f767b3          	or	a5,a4,a5
   17254:	fef43023          	sd	a5,-32(s0)
        entry_set(table, i, pte);
   17258:	fe842783          	lw	a5,-24(s0)
   1725c:	fe043603          	ld	a2,-32(s0)
   17260:	00078593          	mv	a1,a5
   17264:	fb843503          	ld	a0,-72(s0)
   17268:	00000097          	auipc	ra,0x0
   1726c:	db0080e7          	jalr	-592(ra) # 17018 <entry_set>
    // sv48
    // level2 bits 29:21 = 0.0100.0000
    // sv39
    // level2 bits 20:12 = 0.0000.0011 (first 4 element initialized in cycle)
    {
        unsigned i = 0x040;
   17270:	04000793          	li	a5,64
   17274:	fcf42e23          	sw	a5,-36(s0)

        uint64_t pte = PTE_V | PTE_R | PTE_W | PTE_X | PTE_U | PTE_A | PTE_D;
   17278:	0df00793          	li	a5,223
   1727c:	fcf43823          	sd	a5,-48(s0)
        // Add in portion of physical address.
        pte |= physical & (((1LL<<vms->vpn_width_bits)-1) <<
   17280:	0001f7b7          	lui	a5,0x1f
   17284:	6087b783          	ld	a5,1544(a5) # 1f608 <vms>
   17288:	0347a783          	lw	a5,52(a5)
   1728c:	00100713          	li	a4,1
   17290:	00f717b3          	sll	a5,a4,a5
   17294:	fff78713          	addi	a4,a5,-1
                (PTE_PPN_SHIFT + (level+1) * vms->vpn_width_bits));
   17298:	fb442783          	lw	a5,-76(s0)
   1729c:	0017879b          	addiw	a5,a5,1
   172a0:	0007869b          	sext.w	a3,a5
   172a4:	0001f7b7          	lui	a5,0x1f
   172a8:	6087b783          	ld	a5,1544(a5) # 1f608 <vms>
   172ac:	0347a783          	lw	a5,52(a5)
   172b0:	02f687bb          	mulw	a5,a3,a5
   172b4:	0007879b          	sext.w	a5,a5
   172b8:	00a7879b          	addiw	a5,a5,10
   172bc:	0007879b          	sext.w	a5,a5
        pte |= physical & (((1LL<<vms->vpn_width_bits)-1) <<
   172c0:	00f717b3          	sll	a5,a4,a5
   172c4:	00078713          	mv	a4,a5
   172c8:	fa843783          	ld	a5,-88(s0)
   172cc:	00f777b3          	and	a5,a4,a5
   172d0:	fd043703          	ld	a4,-48(s0)
   172d4:	00f767b3          	or	a5,a4,a5
   172d8:	fcf43823          	sd	a5,-48(s0)
        // Add in the index.
        pte |= ((reg_t) i) << (PTE_PPN_SHIFT + level * vms->vpn_width_bits);
   172dc:	fdc46703          	lwu	a4,-36(s0)
   172e0:	0001f7b7          	lui	a5,0x1f
   172e4:	6087b783          	ld	a5,1544(a5) # 1f608 <vms>
   172e8:	0347a783          	lw	a5,52(a5)
   172ec:	fb442683          	lw	a3,-76(s0)
   172f0:	02f687bb          	mulw	a5,a3,a5
   172f4:	0007879b          	sext.w	a5,a5
   172f8:	00a7879b          	addiw	a5,a5,10
   172fc:	0007879b          	sext.w	a5,a5
   17300:	00f717b3          	sll	a5,a4,a5
   17304:	fd043703          	ld	a4,-48(s0)
   17308:	00f767b3          	or	a5,a4,a5
   1730c:	fcf43823          	sd	a5,-48(s0)
        entry_set(table, i, pte);
   17310:	fdc42783          	lw	a5,-36(s0)
   17314:	fd043603          	ld	a2,-48(s0)
   17318:	00078593          	mv	a1,a5
   1731c:	fb843503          	ld	a0,-72(s0)
   17320:	00000097          	auipc	ra,0x0
   17324:	cf8080e7          	jalr	-776(ra) # 17018 <entry_set>
    }
    // level3 bits 20:12 = 0.0000.0011
#endif

}
   17328:	00000013          	nop
   1732c:	05813083          	ld	ra,88(sp)
   17330:	05013403          	ld	s0,80(sp)
   17334:	06010113          	addi	sp,sp,96
   17338:	00008067          	ret

000000000001733c <vpn>:

// Return contents of vpn field for the given virtual address and level.
unsigned vpn(uint64_t virtual, unsigned level)
{
   1733c:	fe010113          	addi	sp,sp,-32
   17340:	00813c23          	sd	s0,24(sp)
   17344:	02010413          	addi	s0,sp,32
   17348:	fea43423          	sd	a0,-24(s0)
   1734c:	00058793          	mv	a5,a1
   17350:	fef42223          	sw	a5,-28(s0)
    virtual >>= 12 + vms->vpn_width_bits * level;
   17354:	0001f7b7          	lui	a5,0x1f
   17358:	6087b783          	ld	a5,1544(a5) # 1f608 <vms>
   1735c:	0347a783          	lw	a5,52(a5)
   17360:	fe442703          	lw	a4,-28(s0)
   17364:	02f707bb          	mulw	a5,a4,a5
   17368:	0007879b          	sext.w	a5,a5
   1736c:	00c7879b          	addiw	a5,a5,12
   17370:	0007879b          	sext.w	a5,a5
   17374:	fe843703          	ld	a4,-24(s0)
   17378:	00f757b3          	srl	a5,a4,a5
   1737c:	fef43423          	sd	a5,-24(s0)
    return virtual & ((1<<vms->vpn_width_bits)-1);
   17380:	0001f7b7          	lui	a5,0x1f
   17384:	6087b783          	ld	a5,1544(a5) # 1f608 <vms>
   17388:	0347a783          	lw	a5,52(a5)
   1738c:	00100713          	li	a4,1
   17390:	00f717bb          	sllw	a5,a4,a5
   17394:	0007879b          	sext.w	a5,a5
   17398:	fff7879b          	addiw	a5,a5,-1
   1739c:	0007879b          	sext.w	a5,a5
   173a0:	0007871b          	sext.w	a4,a5
   173a4:	fe843783          	ld	a5,-24(s0)
   173a8:	0007879b          	sext.w	a5,a5
   173ac:	00f777b3          	and	a5,a4,a5
   173b0:	0007879b          	sext.w	a5,a5
}
   173b4:	00078513          	mv	a0,a5
   173b8:	01813403          	ld	s0,24(sp)
   173bc:	02010113          	addi	sp,sp,32
   173c0:	00008067          	ret

00000000000173c4 <add_entry>:
 
// Add an entry to the given table, at the given level (0 for 4Kb page).
void add_entry(mmu_type *mmu, char *table, unsigned level, uint64_t virtual, uint64_t physical)
{
   173c4:	fa010113          	addi	sp,sp,-96
   173c8:	04113c23          	sd	ra,88(sp)
   173cc:	04813823          	sd	s0,80(sp)
   173d0:	06010413          	addi	s0,sp,96
   173d4:	fca43423          	sd	a0,-56(s0)
   173d8:	fcb43023          	sd	a1,-64(s0)
   173dc:	00060793          	mv	a5,a2
   173e0:	fad43823          	sd	a3,-80(s0)
   173e4:	fae43423          	sd	a4,-88(s0)
   173e8:	faf42e23          	sw	a5,-68(s0)
    unsigned current_level = vms->levels - 1;
   173ec:	0001f7b7          	lui	a5,0x1f
   173f0:	6087b783          	ld	a5,1544(a5) # 1f608 <vms>
   173f4:	0047a783          	lw	a5,4(a5)
   173f8:	fff7879b          	addiw	a5,a5,-1
   173fc:	fef42623          	sw	a5,-20(s0)
    while (1) {
        unsigned index = vpn(virtual, current_level);
   17400:	fec42783          	lw	a5,-20(s0)
   17404:	00078593          	mv	a1,a5
   17408:	fb043503          	ld	a0,-80(s0)
   1740c:	00000097          	auipc	ra,0x0
   17410:	f30080e7          	jalr	-208(ra) # 1733c <vpn>
   17414:	00050793          	mv	a5,a0
   17418:	fef42423          	sw	a5,-24(s0)
        if (current_level <= level) {
   1741c:	fec42703          	lw	a4,-20(s0)
   17420:	fbc42783          	lw	a5,-68(s0)
   17424:	0007071b          	sext.w	a4,a4
   17428:	0007879b          	sext.w	a5,a5
   1742c:	06e7e263          	bltu	a5,a4,17490 <add_entry+0xcc>
            // Add the new entry.
            entry_set(table, index, PTE_V | PTE_R | PTE_W | PTE_X | PTE_U | PTE_A | PTE_D |
                    ((physical >> 2) & ~((1 <<
   17430:	fa843783          	ld	a5,-88(s0)
   17434:	0027d793          	srli	a5,a5,0x2
                            (PTE_PPN_SHIFT + current_level * vms->vpn_width_bits)) - 1)));
   17438:	0001f737          	lui	a4,0x1f
   1743c:	60873703          	ld	a4,1544(a4) # 1f608 <vms>
   17440:	03472703          	lw	a4,52(a4)
   17444:	fec42683          	lw	a3,-20(s0)
   17448:	02e6873b          	mulw	a4,a3,a4
   1744c:	0007071b          	sext.w	a4,a4
   17450:	00a7071b          	addiw	a4,a4,10
   17454:	0007071b          	sext.w	a4,a4
                    ((physical >> 2) & ~((1 <<
   17458:	00100693          	li	a3,1
   1745c:	00e6973b          	sllw	a4,a3,a4
   17460:	0007071b          	sext.w	a4,a4
   17464:	40e0073b          	negw	a4,a4
   17468:	0007071b          	sext.w	a4,a4
   1746c:	00e7f7b3          	and	a5,a5,a4
            entry_set(table, index, PTE_V | PTE_R | PTE_W | PTE_X | PTE_U | PTE_A | PTE_D |
   17470:	0df7e713          	ori	a4,a5,223
   17474:	fe842783          	lw	a5,-24(s0)
   17478:	00070613          	mv	a2,a4
   1747c:	00078593          	mv	a1,a5
   17480:	fc043503          	ld	a0,-64(s0)
   17484:	00000097          	auipc	ra,0x0
   17488:	b94080e7          	jalr	-1132(ra) # 17018 <entry_set>
            return;
   1748c:	0bc0006f          	j	17548 <add_entry+0x184>
        }
        reg_t pte = entry(table, index);
   17490:	fe842783          	lw	a5,-24(s0)
   17494:	00078593          	mv	a1,a5
   17498:	fc043503          	ld	a0,-64(s0)
   1749c:	addff0ef          	jal	ra,16f78 <entry>
   174a0:	fea43023          	sd	a0,-32(s0)
        if (!(pte & PTE_V) ||
   174a4:	fe043783          	ld	a5,-32(s0)
   174a8:	0017f793          	andi	a5,a5,1
   174ac:	00078e63          	beqz	a5,174c8 <add_entry+0x104>
                ((pte & PTE_R) && (pte & PTE_W))) {
   174b0:	fe043783          	ld	a5,-32(s0)
   174b4:	0027f793          	andi	a5,a5,2
        if (!(pte & PTE_V) ||
   174b8:	06078863          	beqz	a5,17528 <add_entry+0x164>
                ((pte & PTE_R) && (pte & PTE_W))) {
   174bc:	fe043783          	ld	a5,-32(s0)
   174c0:	0047f793          	andi	a5,a5,4
   174c4:	06078263          	beqz	a5,17528 <add_entry+0x164>
            // Create a new page
            void *new_page = get_page(mmu);
   174c8:	fc843503          	ld	a0,-56(s0)
   174cc:	00000097          	auipc	ra,0x0
   174d0:	9e4080e7          	jalr	-1564(ra) # 16eb0 <get_page>
   174d4:	fca43c23          	sd	a0,-40(s0)
            setup_page_table(new_page, current_level - 1, virtual);
   174d8:	fec42783          	lw	a5,-20(s0)
   174dc:	fff7879b          	addiw	a5,a5,-1
   174e0:	0007879b          	sext.w	a5,a5
   174e4:	fb043603          	ld	a2,-80(s0)
   174e8:	00078593          	mv	a1,a5
   174ec:	fd843503          	ld	a0,-40(s0)
   174f0:	bd5ff0ef          	jal	ra,170c4 <setup_page_table>
            entry_set(table, index, PTE_V |
                    ((((reg_t) new_page) >> 2) & ~((1 << 10) - 1)));
   174f4:	fd843783          	ld	a5,-40(s0)
   174f8:	0027d793          	srli	a5,a5,0x2
   174fc:	c007f793          	andi	a5,a5,-1024
            entry_set(table, index, PTE_V |
   17500:	0017e713          	ori	a4,a5,1
   17504:	fe842783          	lw	a5,-24(s0)
   17508:	00070613          	mv	a2,a4
   1750c:	00078593          	mv	a1,a5
   17510:	fc043503          	ld	a0,-64(s0)
   17514:	00000097          	auipc	ra,0x0
   17518:	b04080e7          	jalr	-1276(ra) # 17018 <entry_set>
            table = new_page;
   1751c:	fd843783          	ld	a5,-40(s0)
   17520:	fcf43023          	sd	a5,-64(s0)
                ((pte & PTE_R) && (pte & PTE_W))) {
   17524:	0140006f          	j	17538 <add_entry+0x174>
        } else {
            table = (char *) (pte & ~0xfff);
   17528:	fe043703          	ld	a4,-32(s0)
   1752c:	fffff7b7          	lui	a5,0xfffff
   17530:	00f777b3          	and	a5,a4,a5
   17534:	fcf43023          	sd	a5,-64(s0)
        }
        current_level--;
   17538:	fec42783          	lw	a5,-20(s0)
   1753c:	fff7879b          	addiw	a5,a5,-1
   17540:	fef42623          	sw	a5,-20(s0)
    while (1) {
   17544:	ebdff06f          	j	17400 <add_entry+0x3c>
    }
}
   17548:	05813083          	ld	ra,88(sp)
   1754c:	05013403          	ld	s0,80(sp)
   17550:	06010113          	addi	sp,sp,96
   17554:	00008067          	ret

0000000000017558 <test_mmu>:

int test_mmu()
{
   17558:	fa010113          	addi	sp,sp,-96
   1755c:	04113c23          	sd	ra,88(sp)
   17560:	04813823          	sd	s0,80(sp)
   17564:	06010413          	addi	s0,sp,96
    mmu_type *pages = (mmu_type *)fw_malloc(sizeof(mmu_type));
   17568:	000087b7          	lui	a5,0x8
   1756c:	00878513          	addi	a0,a5,8 # 8008 <_ftext-0x7ff8>
   17570:	ffffa097          	auipc	ra,0xffffa
   17574:	5c8080e7          	jalr	1480(ra) # 11b38 <fw_malloc>
   17578:	fea43023          	sd	a0,-32(s0)
    pages->next = pages->buf;
   1757c:	fe043703          	ld	a4,-32(s0)
   17580:	fe043683          	ld	a3,-32(s0)
   17584:	000087b7          	lui	a5,0x8
   17588:	00f687b3          	add	a5,a3,a5
   1758c:	00e7b023          	sd	a4,0(a5) # 8000 <_ftext-0x8000>

    fw_register_ram_data("mmu", pages);
   17590:	fe043583          	ld	a1,-32(s0)
   17594:	0001e7b7          	lui	a5,0x1e
   17598:	c5878513          	addi	a0,a5,-936 # 1dc58 <FCVT_WU_D_TESTS+0x620>
   1759c:	e3cfa0ef          	jal	ra,11bd8 <fw_register_ram_data>

    flush_tlb();  // Check sfence.vma
   175a0:	ffffb097          	auipc	ra,0xffffb
   175a4:	79c080e7          	jalr	1948(ra) # 12d3c <flush_tlb>

    printf_uart("%s", "MMU.MPRV . . . .");
   175a8:	0001e7b7          	lui	a5,0x1e
   175ac:	c6078593          	addi	a1,a5,-928 # 1dc60 <FCVT_WU_D_TESTS+0x628>
   175b0:	0001e7b7          	lui	a5,0x1e
   175b4:	c5078513          	addi	a0,a5,-944 # 1dc50 <FCVT_WU_D_TESTS+0x618>
   175b8:	ffffb097          	auipc	ra,0xffffb
   175bc:	398080e7          	jalr	920(ra) # 12950 <printf_uart>

    void *master_table = get_page(pages);
   175c0:	fe043503          	ld	a0,-32(s0)
   175c4:	8edff0ef          	jal	ra,16eb0 <get_page>
   175c8:	fca43c23          	sd	a0,-40(s0)
    setup_page_table(master_table, vms->levels-1, 0);
   175cc:	0001f7b7          	lui	a5,0x1f
   175d0:	6087b783          	ld	a5,1544(a5) # 1f608 <vms>
   175d4:	0047a783          	lw	a5,4(a5)
   175d8:	fff7879b          	addiw	a5,a5,-1
   175dc:	0007879b          	sext.w	a5,a5
   175e0:	00000613          	li	a2,0
   175e4:	00078593          	mv	a1,a5
   175e8:	fd843503          	ld	a0,-40(s0)
   175ec:	00000097          	auipc	ra,0x0
   175f0:	ad8080e7          	jalr	-1320(ra) # 170c4 <setup_page_table>
    uint32_t *physical = get_page(pages);
   175f4:	fe043503          	ld	a0,-32(s0)
   175f8:	8b9ff0ef          	jal	ra,16eb0 <get_page>
   175fc:	fca43823          	sd	a0,-48(s0)
    uint32_t *virtual = (uint32_t *) (((reg_t) physical) ^ (((reg_t) 0xf) << (vms->vaddr_bits - 4)));
   17600:	0001f7b7          	lui	a5,0x1f
   17604:	6087b783          	ld	a5,1544(a5) # 1f608 <vms>
   17608:	0387a783          	lw	a5,56(a5)
   1760c:	ffc7879b          	addiw	a5,a5,-4
   17610:	0007879b          	sext.w	a5,a5
   17614:	00f00713          	li	a4,15
   17618:	00f71733          	sll	a4,a4,a5
   1761c:	fd043783          	ld	a5,-48(s0)
   17620:	00f747b3          	xor	a5,a4,a5
   17624:	fef43423          	sd	a5,-24(s0)

    // Virtual addresses must be sign-extended.
    if (vms->vaddr_bits < sizeof(virtual) * 8 && (reg_t) virtual & ((reg_t) 1<<(vms->vaddr_bits-1))) {
   17628:	0001f7b7          	lui	a5,0x1f
   1762c:	6087b783          	ld	a5,1544(a5) # 1f608 <vms>
   17630:	0387a783          	lw	a5,56(a5)
   17634:	00078713          	mv	a4,a5
   17638:	03f00793          	li	a5,63
   1763c:	04e7e663          	bltu	a5,a4,17688 <test_mmu+0x130>
   17640:	fe843703          	ld	a4,-24(s0)
   17644:	0001f7b7          	lui	a5,0x1f
   17648:	6087b783          	ld	a5,1544(a5) # 1f608 <vms>
   1764c:	0387a783          	lw	a5,56(a5)
   17650:	fff7879b          	addiw	a5,a5,-1
   17654:	0007879b          	sext.w	a5,a5
   17658:	00f757b3          	srl	a5,a4,a5
   1765c:	0017f793          	andi	a5,a5,1
   17660:	02078463          	beqz	a5,17688 <test_mmu+0x130>
        virtual = (uint32_t *) (
                (reg_t) virtual | ~(((reg_t) 1 << vms->vaddr_bits) - 1));
   17664:	0001f7b7          	lui	a5,0x1f
   17668:	6087b783          	ld	a5,1544(a5) # 1f608 <vms>
   1766c:	0387a783          	lw	a5,56(a5)
   17670:	00100713          	li	a4,1
   17674:	00f717b3          	sll	a5,a4,a5
   17678:	40f00733          	neg	a4,a5
   1767c:	fe843783          	ld	a5,-24(s0)
   17680:	00f767b3          	or	a5,a4,a5
        virtual = (uint32_t *) (
   17684:	fef43423          	sd	a5,-24(s0)
    }
    add_entry(pages, master_table, 0, (reg_t) virtual, (reg_t) physical);
   17688:	fe843783          	ld	a5,-24(s0)
   1768c:	fd043703          	ld	a4,-48(s0)
   17690:	00078693          	mv	a3,a5
   17694:	00000613          	li	a2,0
   17698:	fd843583          	ld	a1,-40(s0)
   1769c:	fe043503          	ld	a0,-32(s0)
   176a0:	00000097          	auipc	ra,0x0
   176a4:	d24080e7          	jalr	-732(ra) # 173c4 <add_entry>

    unsigned long satp = set_field(0, SATP_MODE, vms->mode);
   176a8:	0001f7b7          	lui	a5,0x1f
   176ac:	6087b783          	ld	a5,1544(a5) # 1f608 <vms>
   176b0:	0007a783          	lw	a5,0(a5)
   176b4:	02079793          	slli	a5,a5,0x20
   176b8:	0207d793          	srli	a5,a5,0x20
   176bc:	03c79793          	slli	a5,a5,0x3c
   176c0:	fcf43423          	sd	a5,-56(s0)
    satp = set_field(satp, SATP_PPN, ((unsigned long) master_table) >> 12);
   176c4:	fc843703          	ld	a4,-56(s0)
   176c8:	fff00793          	li	a5,-1
   176cc:	02c79793          	slli	a5,a5,0x2c
   176d0:	00f77733          	and	a4,a4,a5
   176d4:	fd843783          	ld	a5,-40(s0)
   176d8:	00c7d693          	srli	a3,a5,0xc
   176dc:	fff00793          	li	a5,-1
   176e0:	0147d793          	srli	a5,a5,0x14
   176e4:	00f6f7b3          	and	a5,a3,a5
   176e8:	00f767b3          	or	a5,a4,a5
   176ec:	fcf43423          	sd	a5,-56(s0)
    write_csr(0x180, satp);  // csr 180 = satp
   176f0:	fc843783          	ld	a5,-56(s0)
   176f4:	18079073          	csrw	sptbr,a5
    satp = read_csr(0x180);
   176f8:	180027f3          	csrr	a5,sptbr
   176fc:	fcf43023          	sd	a5,-64(s0)
   17700:	fc043783          	ld	a5,-64(s0)
   17704:	fcf43423          	sd	a5,-56(s0)
    if (get_field(satp, SATP_MODE) != vms->mode) {
   17708:	fc843783          	ld	a5,-56(s0)
   1770c:	03c7d713          	srli	a4,a5,0x3c
   17710:	0001f7b7          	lui	a5,0x1f
   17714:	6087b783          	ld	a5,1544(a5) # 1f608 <vms>
   17718:	0007a783          	lw	a5,0(a5)
   1771c:	02079793          	slli	a5,a5,0x20
   17720:	0207d793          	srli	a5,a5,0x20
   17724:	02f70263          	beq	a4,a5,17748 <test_mmu+0x1f0>
        printf_uart("%s", "FAIL,SATP_MODE\r\n");
   17728:	0001e7b7          	lui	a5,0x1e
   1772c:	c7878593          	addi	a1,a5,-904 # 1dc78 <FCVT_WU_D_TESTS+0x640>
   17730:	0001e7b7          	lui	a5,0x1e
   17734:	c5078513          	addi	a0,a5,-944 # 1dc50 <FCVT_WU_D_TESTS+0x618>
   17738:	ffffb097          	auipc	ra,0xffffb
   1773c:	218080e7          	jalr	536(ra) # 12950 <printf_uart>
        return -1;
   17740:	fff00793          	li	a5,-1
   17744:	18c0006f          	j	178d0 <test_mmu+0x378>
    }

    setup_pmp();
   17748:	f01fe0ef          	jal	ra,16648 <setup_pmp>
    reg_t mstatus = read_csr(mstatus);
   1774c:	300027f3          	csrr	a5,mstatus
   17750:	faf43c23          	sd	a5,-72(s0)
   17754:	fb843783          	ld	a5,-72(s0)
   17758:	faf43823          	sd	a5,-80(s0)
    mstatus &= ~(MSTATUS_MPP_M);
   1775c:	fb043703          	ld	a4,-80(s0)
   17760:	ffffe7b7          	lui	a5,0xffffe
   17764:	7ff78793          	addi	a5,a5,2047 # ffffffffffffe7ff <_end+0xfffffffffffdef63>
   17768:	00f777b3          	and	a5,a4,a5
   1776c:	faf43823          	sd	a5,-80(s0)
    mstatus |= MSTATUS_MPP_S;  // set MPP to S-mode
   17770:	fb043703          	ld	a4,-80(s0)
   17774:	000017b7          	lui	a5,0x1
   17778:	80078793          	addi	a5,a5,-2048 # 800 <_ftext-0xf800>
   1777c:	00f767b3          	or	a5,a4,a5
   17780:	faf43823          	sd	a5,-80(s0)
    mstatus |= MSTATUS_MPRV;
   17784:	fb043703          	ld	a4,-80(s0)
   17788:	000207b7          	lui	a5,0x20
   1778c:	00f767b3          	or	a5,a4,a5
   17790:	faf43823          	sd	a5,-80(s0)
    write_csr(mstatus, mstatus);
   17794:	fb043783          	ld	a5,-80(s0)
   17798:	30079073          	csrw	mstatus,a5

    // Address translation is enabled.
    physical[0] = 0xdeadbeef;
   1779c:	fd043783          	ld	a5,-48(s0)
   177a0:	deadc737          	lui	a4,0xdeadc
   177a4:	eef7071b          	addiw	a4,a4,-273
   177a8:	00e7a023          	sw	a4,0(a5) # 20000 <_end+0x764>
    virtual[1] = 0x55667788;
   177ac:	fe843783          	ld	a5,-24(s0)
   177b0:	00478793          	addi	a5,a5,4
   177b4:	55667737          	lui	a4,0x55667
   177b8:	7887071b          	addiw	a4,a4,1928
   177bc:	00e7a023          	sw	a4,0(a5)
    if (!(virtual[0] == 0xdeadbeef)) {
   177c0:	fe843783          	ld	a5,-24(s0)
   177c4:	0007a783          	lw	a5,0(a5)
   177c8:	00078713          	mv	a4,a5
   177cc:	deadc7b7          	lui	a5,0xdeadc
   177d0:	eef78793          	addi	a5,a5,-273 # ffffffffdeadbeef <_end+0xffffffffdeabc653>
   177d4:	02f70263          	beq	a4,a5,177f8 <test_mmu+0x2a0>
        printf_uart("%s", "FAIL2\r\n");
   177d8:	0001e7b7          	lui	a5,0x1e
   177dc:	c9078593          	addi	a1,a5,-880 # 1dc90 <FCVT_WU_D_TESTS+0x658>
   177e0:	0001e7b7          	lui	a5,0x1e
   177e4:	c5078513          	addi	a0,a5,-944 # 1dc50 <FCVT_WU_D_TESTS+0x618>
   177e8:	ffffb097          	auipc	ra,0xffffb
   177ec:	168080e7          	jalr	360(ra) # 12950 <printf_uart>
        return -2;
   177f0:	ffe00793          	li	a5,-2
   177f4:	0dc0006f          	j	178d0 <test_mmu+0x378>
    }
    if (!(physical[0] == 0xdeadbeef)) {
   177f8:	fd043783          	ld	a5,-48(s0)
   177fc:	0007a783          	lw	a5,0(a5)
   17800:	00078713          	mv	a4,a5
   17804:	deadc7b7          	lui	a5,0xdeadc
   17808:	eef78793          	addi	a5,a5,-273 # ffffffffdeadbeef <_end+0xffffffffdeabc653>
   1780c:	02f70263          	beq	a4,a5,17830 <test_mmu+0x2d8>
        printf_uart("%s", "FAIL3\r\n");
   17810:	0001e7b7          	lui	a5,0x1e
   17814:	c9878593          	addi	a1,a5,-872 # 1dc98 <FCVT_WU_D_TESTS+0x660>
   17818:	0001e7b7          	lui	a5,0x1e
   1781c:	c5078513          	addi	a0,a5,-944 # 1dc50 <FCVT_WU_D_TESTS+0x618>
   17820:	ffffb097          	auipc	ra,0xffffb
   17824:	130080e7          	jalr	304(ra) # 12950 <printf_uart>
        return -3;
   17828:	ffd00793          	li	a5,-3
   1782c:	0a40006f          	j	178d0 <test_mmu+0x378>
    }
    if (!(virtual[1] == 0x55667788)) {
   17830:	fe843783          	ld	a5,-24(s0)
   17834:	00478793          	addi	a5,a5,4
   17838:	0007a783          	lw	a5,0(a5)
   1783c:	00078713          	mv	a4,a5
   17840:	556677b7          	lui	a5,0x55667
   17844:	78878793          	addi	a5,a5,1928 # 55667788 <_end+0x55647eec>
   17848:	02f70263          	beq	a4,a5,1786c <test_mmu+0x314>
        printf_uart("%s", "FAIL4\r\n");
   1784c:	0001e7b7          	lui	a5,0x1e
   17850:	ca078593          	addi	a1,a5,-864 # 1dca0 <FCVT_WU_D_TESTS+0x668>
   17854:	0001e7b7          	lui	a5,0x1e
   17858:	c5078513          	addi	a0,a5,-944 # 1dc50 <FCVT_WU_D_TESTS+0x618>
   1785c:	ffffb097          	auipc	ra,0xffffb
   17860:	0f4080e7          	jalr	244(ra) # 12950 <printf_uart>
        return -4;
   17864:	ffc00793          	li	a5,-4
   17868:	0680006f          	j	178d0 <test_mmu+0x378>
    }
    if (!(physical[1] == 0x55667788)) {
   1786c:	fd043783          	ld	a5,-48(s0)
   17870:	00478793          	addi	a5,a5,4
   17874:	0007a783          	lw	a5,0(a5)
   17878:	00078713          	mv	a4,a5
   1787c:	556677b7          	lui	a5,0x55667
   17880:	78878793          	addi	a5,a5,1928 # 55667788 <_end+0x55647eec>
   17884:	02f70263          	beq	a4,a5,178a8 <test_mmu+0x350>
        printf_uart("%s", "FAIL5\r\n");
   17888:	0001e7b7          	lui	a5,0x1e
   1788c:	ca878593          	addi	a1,a5,-856 # 1dca8 <FCVT_WU_D_TESTS+0x670>
   17890:	0001e7b7          	lui	a5,0x1e
   17894:	c5078513          	addi	a0,a5,-944 # 1dc50 <FCVT_WU_D_TESTS+0x618>
   17898:	ffffb097          	auipc	ra,0xffffb
   1789c:	0b8080e7          	jalr	184(ra) # 12950 <printf_uart>
        return -5;
   178a0:	ffb00793          	li	a5,-5
   178a4:	02c0006f          	j	178d0 <test_mmu+0x378>
    }

    clear_csr(mstatus, MSTATUS_MPRV);
   178a8:	000207b7          	lui	a5,0x20
   178ac:	3007b7f3          	csrrc	a5,mstatus,a5
   178b0:	faf43423          	sd	a5,-88(s0)
    printf_uart("%s", "PASS\r\n");
   178b4:	0001e7b7          	lui	a5,0x1e
   178b8:	cb078593          	addi	a1,a5,-848 # 1dcb0 <FCVT_WU_D_TESTS+0x678>
   178bc:	0001e7b7          	lui	a5,0x1e
   178c0:	c5078513          	addi	a0,a5,-944 # 1dc50 <FCVT_WU_D_TESTS+0x618>
   178c4:	ffffb097          	auipc	ra,0xffffb
   178c8:	08c080e7          	jalr	140(ra) # 12950 <printf_uart>
    return 0;
   178cc:	00000793          	li	a5,0
}
   178d0:	00078513          	mv	a0,a5
   178d4:	05813083          	ld	ra,88(sp)
   178d8:	05013403          	ld	s0,80(sp)
   178dc:	06010113          	addi	sp,sp,96
   178e0:	00008067          	ret
   178e4:	0000                	unimp
	...

00000000000178e8 <get_dev_bar>:
static uint64_t get_dev_bar(pnp_map *pnp, uint16_t vid, uint16_t did) {
   178e8:	fb010113          	addi	sp,sp,-80
   178ec:	04813423          	sd	s0,72(sp)
   178f0:	05010413          	addi	s0,sp,80
   178f4:	faa43c23          	sd	a0,-72(s0)
   178f8:	00058793          	mv	a5,a1
   178fc:	00060713          	mv	a4,a2
   17900:	faf41b23          	sh	a5,-74(s0)
   17904:	00070793          	mv	a5,a4
   17908:	faf41a23          	sh	a5,-76(s0)
    int slots_total = (pnp->cfg >> 8) & 0xFF;
   1790c:	fb843783          	ld	a5,-72(s0)
   17910:	0087a783          	lw	a5,8(a5)
   17914:	0087d79b          	srliw	a5,a5,0x8
   17918:	0007879b          	sext.w	a5,a5
   1791c:	0007879b          	sext.w	a5,a5
   17920:	0ff7f793          	andi	a5,a5,255
   17924:	fef42223          	sw	a5,-28(s0)
    int off = 0;
   17928:	fe042623          	sw	zero,-20(s0)
    for (int i = 0; i < slots_total; i++) {
   1792c:	fe042423          	sw	zero,-24(s0)
   17930:	09c0006f          	j	179cc <get_dev_bar+0xe4>
        dcfg = *(dev_cfg_type *)&pnp->cfg_table[off];
   17934:	fec42783          	lw	a5,-20(s0)
   17938:	04078793          	addi	a5,a5,64
   1793c:	fb843703          	ld	a4,-72(s0)
   17940:	00f707b3          	add	a5,a4,a5
   17944:	0007b703          	ld	a4,0(a5)
   17948:	fce43023          	sd	a4,-64(s0)
   1794c:	0087b703          	ld	a4,8(a5)
   17950:	fce43423          	sd	a4,-56(s0)
   17954:	0107b703          	ld	a4,16(a5)
   17958:	fce43823          	sd	a4,-48(s0)
   1795c:	0187b783          	ld	a5,24(a5)
   17960:	fcf43c23          	sd	a5,-40(s0)
        off += sizeof(dcfg);
   17964:	fec42783          	lw	a5,-20(s0)
   17968:	0207879b          	addiw	a5,a5,32
   1796c:	0007879b          	sext.w	a5,a5
   17970:	fef42623          	sw	a5,-20(s0)
        if (dcfg.u.descrtype != PNP_CFG_TYPE_SLAVE) {
   17974:	fc144783          	lbu	a5,-63(s0)
   17978:	0037f793          	andi	a5,a5,3
   1797c:	0ff7f793          	andi	a5,a5,255
   17980:	00078713          	mv	a4,a5
   17984:	00200793          	li	a5,2
   17988:	02f71a63          	bne	a4,a5,179bc <get_dev_bar+0xd4>
        if (dcfg.u.vid == vid && dcfg.u.did == did) {
   1798c:	fc645783          	lhu	a5,-58(s0)
   17990:	fb645703          	lhu	a4,-74(s0)
   17994:	0007071b          	sext.w	a4,a4
   17998:	0007879b          	sext.w	a5,a5
   1799c:	02f71263          	bne	a4,a5,179c0 <get_dev_bar+0xd8>
   179a0:	fc445783          	lhu	a5,-60(s0)
   179a4:	fb445703          	lhu	a4,-76(s0)
   179a8:	0007071b          	sext.w	a4,a4
   179ac:	0007879b          	sext.w	a5,a5
   179b0:	00f71863          	bne	a4,a5,179c0 <get_dev_bar+0xd8>
            return dcfg.u.addr_start;
   179b4:	fd043783          	ld	a5,-48(s0)
   179b8:	02c0006f          	j	179e4 <get_dev_bar+0xfc>
            continue;
   179bc:	00000013          	nop
    for (int i = 0; i < slots_total; i++) {
   179c0:	fe842783          	lw	a5,-24(s0)
   179c4:	0017879b          	addiw	a5,a5,1
   179c8:	fef42423          	sw	a5,-24(s0)
   179cc:	fe842703          	lw	a4,-24(s0)
   179d0:	fe442783          	lw	a5,-28(s0)
   179d4:	0007071b          	sext.w	a4,a4
   179d8:	0007879b          	sext.w	a5,a5
   179dc:	f4f74ce3          	blt	a4,a5,17934 <get_dev_bar+0x4c>
    return DEV_NONE;
   179e0:	fff00793          	li	a5,-1
}
   179e4:	00078513          	mv	a0,a5
   179e8:	04813403          	ld	s0,72(sp)
   179ec:	05010113          	addi	sp,sp,80
   179f0:	00008067          	ret

00000000000179f4 <mpu_region_total>:
static int mpu_region_total() {
   179f4:	fe010113          	addi	sp,sp,-32
   179f8:	00813c23          	sd	s0,24(sp)
   179fc:	02010413          	addi	s0,sp,32
    uint64_t val = 0;
   17a00:	fe043423          	sd	zero,-24(s0)
    asm("csrr %0, 0xBC4" : "=r" (val));
   17a04:	bc4027f3          	csrr	a5,0xbc4
   17a08:	fef43423          	sd	a5,-24(s0)
    return (int)(val >> 8);
   17a0c:	fe843783          	ld	a5,-24(s0)
   17a10:	0087d793          	srli	a5,a5,0x8
   17a14:	0007879b          	sext.w	a5,a5
}
   17a18:	00078513          	mv	a0,a5
   17a1c:	01813403          	ld	s0,24(sp)
   17a20:	02010113          	addi	sp,sp,32
   17a24:	00008067          	ret

0000000000017a28 <mpu_disable_region>:
static void mpu_disable_region(int idx) {
   17a28:	fd010113          	addi	sp,sp,-48
   17a2c:	02813423          	sd	s0,40(sp)
   17a30:	03010413          	addi	s0,sp,48
   17a34:	00050793          	mv	a5,a0
   17a38:	fcf42e23          	sw	a5,-36(s0)
    ctrl.value = 0;
   17a3c:	fe043423          	sd	zero,-24(s0)
    ctrl.bits.IDX = idx;
   17a40:	fdc42783          	lw	a5,-36(s0)
   17a44:	0ff7f793          	andi	a5,a5,255
   17a48:	fef404a3          	sb	a5,-23(s0)
    ctrl.bits.WE = 1;
   17a4c:	fe844783          	lbu	a5,-24(s0)
   17a50:	f807e793          	ori	a5,a5,-128
   17a54:	fef40423          	sb	a5,-24(s0)
    asm("csrw 0xBC4, %0" : :"r"(ctrl.value));
   17a58:	fe843783          	ld	a5,-24(s0)
   17a5c:	bc479073          	csrw	0xbc4,a5
}
   17a60:	00000013          	nop
   17a64:	02813403          	ld	s0,40(sp)
   17a68:	03010113          	addi	sp,sp,48
   17a6c:	00008067          	ret

0000000000017a70 <mpu_enable_region>:
                       const char *rwx) {
   17a70:	fb010113          	addi	sp,sp,-80
   17a74:	04813423          	sd	s0,72(sp)
   17a78:	05010413          	addi	s0,sp,80
   17a7c:	00050793          	mv	a5,a0
   17a80:	fcb43023          	sd	a1,-64(s0)
   17a84:	fac43c23          	sd	a2,-72(s0)
   17a88:	fae43823          	sd	a4,-80(s0)
   17a8c:	fcf42623          	sw	a5,-52(s0)
   17a90:	00068793          	mv	a5,a3
   17a94:	fcf42423          	sw	a5,-56(s0)
    uint64_t mask = (~0ull) << 10;
   17a98:	c0000793          	li	a5,-1024
   17a9c:	fef43423          	sd	a5,-24(s0)
    const char *p = rwx;
   17aa0:	fb043783          	ld	a5,-80(s0)
   17aa4:	fef43023          	sd	a5,-32(s0)
    asm("csrw 0xBC2, %0" : :"r"(bar));
   17aa8:	fc043783          	ld	a5,-64(s0)
   17aac:	bc279073          	csrw	0xbc2,a5
    KB >>= 1;
   17ab0:	fb843783          	ld	a5,-72(s0)
   17ab4:	0017d793          	srli	a5,a5,0x1
   17ab8:	faf43c23          	sd	a5,-72(s0)
    while (KB) {
   17abc:	01c0006f          	j	17ad8 <mpu_enable_region+0x68>
        mask <<= 1;
   17ac0:	fe843783          	ld	a5,-24(s0)
   17ac4:	00179793          	slli	a5,a5,0x1
   17ac8:	fef43423          	sd	a5,-24(s0)
        KB >>= 1;
   17acc:	fb843783          	ld	a5,-72(s0)
   17ad0:	0017d793          	srli	a5,a5,0x1
   17ad4:	faf43c23          	sd	a5,-72(s0)
    while (KB) {
   17ad8:	fb843783          	ld	a5,-72(s0)
   17adc:	fe0792e3          	bnez	a5,17ac0 <mpu_enable_region+0x50>
    asm("csrw 0xBC3, %0" : :"r"(mask));
   17ae0:	fe843783          	ld	a5,-24(s0)
   17ae4:	bc379073          	csrw	0xbc3,a5
    ctrl.value = 0;
   17ae8:	fc043c23          	sd	zero,-40(s0)
    ctrl.bits.IDX = idx;
   17aec:	fcc42783          	lw	a5,-52(s0)
   17af0:	0ff7f793          	andi	a5,a5,255
   17af4:	fcf40ca3          	sb	a5,-39(s0)
    ctrl.bits.ENA = 1;
   17af8:	fd844783          	lbu	a5,-40(s0)
   17afc:	0107e793          	ori	a5,a5,16
   17b00:	fcf40c23          	sb	a5,-40(s0)
    ctrl.bits.CACHABLE = cached;
   17b04:	fc842783          	lw	a5,-56(s0)
   17b08:	0017f793          	andi	a5,a5,1
   17b0c:	0ff7f793          	andi	a5,a5,255
   17b10:	0017f793          	andi	a5,a5,1
   17b14:	0037969b          	slliw	a3,a5,0x3
   17b18:	fd844783          	lbu	a5,-40(s0)
   17b1c:	ff77f793          	andi	a5,a5,-9
   17b20:	00078713          	mv	a4,a5
   17b24:	00068793          	mv	a5,a3
   17b28:	00f767b3          	or	a5,a4,a5
   17b2c:	fcf40c23          	sb	a5,-40(s0)
    ctrl.bits.WE = 1; // write into MPU
   17b30:	fd844783          	lbu	a5,-40(s0)
   17b34:	f807e793          	ori	a5,a5,-128
   17b38:	fcf40c23          	sb	a5,-40(s0)
    while (*p) {
   17b3c:	0700006f          	j	17bac <mpu_enable_region+0x13c>
        if (*p == 'r') {
   17b40:	fe043783          	ld	a5,-32(s0)
   17b44:	0007c783          	lbu	a5,0(a5)
   17b48:	00078713          	mv	a4,a5
   17b4c:	07200793          	li	a5,114
   17b50:	00f71863          	bne	a4,a5,17b60 <mpu_enable_region+0xf0>
            ctrl.bits.RD = 1;
   17b54:	fd844783          	lbu	a5,-40(s0)
   17b58:	0027e793          	ori	a5,a5,2
   17b5c:	fcf40c23          	sb	a5,-40(s0)
        if (*p == 'w') {
   17b60:	fe043783          	ld	a5,-32(s0)
   17b64:	0007c783          	lbu	a5,0(a5)
   17b68:	00078713          	mv	a4,a5
   17b6c:	07700793          	li	a5,119
   17b70:	00f71863          	bne	a4,a5,17b80 <mpu_enable_region+0x110>
            ctrl.bits.WR = 1;
   17b74:	fd844783          	lbu	a5,-40(s0)
   17b78:	0017e793          	ori	a5,a5,1
   17b7c:	fcf40c23          	sb	a5,-40(s0)
        if (*p == 'x') {
   17b80:	fe043783          	ld	a5,-32(s0)
   17b84:	0007c783          	lbu	a5,0(a5)
   17b88:	00078713          	mv	a4,a5
   17b8c:	07800793          	li	a5,120
   17b90:	00f71863          	bne	a4,a5,17ba0 <mpu_enable_region+0x130>
            ctrl.bits.EXEC = 1;
   17b94:	fd844783          	lbu	a5,-40(s0)
   17b98:	0047e793          	ori	a5,a5,4
   17b9c:	fcf40c23          	sb	a5,-40(s0)
        p++;
   17ba0:	fe043783          	ld	a5,-32(s0)
   17ba4:	00178793          	addi	a5,a5,1
   17ba8:	fef43023          	sd	a5,-32(s0)
    while (*p) {
   17bac:	fe043783          	ld	a5,-32(s0)
   17bb0:	0007c783          	lbu	a5,0(a5)
   17bb4:	f80796e3          	bnez	a5,17b40 <mpu_enable_region+0xd0>
    asm("csrw 0xBC4, %0" : :"r"(ctrl.value));
   17bb8:	fd843783          	ld	a5,-40(s0)
   17bbc:	bc479073          	csrw	0xbc4,a5
}
   17bc0:	00000013          	nop
   17bc4:	04813403          	ld	s0,72(sp)
   17bc8:	05010113          	addi	sp,sp,80
   17bcc:	00008067          	ret

0000000000017bd0 <test_ddr>:
#include <inttypes.h>
#include <string.h>
#include <axi_maps.h>
#include "fw_api.h"

int test_ddr(void) {
   17bd0:	fc010113          	addi	sp,sp,-64
   17bd4:	02113c23          	sd	ra,56(sp)
   17bd8:	02813823          	sd	s0,48(sp)
   17bdc:	04010413          	addi	s0,sp,64
    prci_map *prci = (prci_map *)ADDR_BUS1_APB_PRCI;
   17be0:	100127b7          	lui	a5,0x10012
   17be4:	fcf43c23          	sd	a5,-40(s0)
    clint_map *clint = (clint_map *)ADDR_BUS0_XSLV_CLINT;
   17be8:	020007b7          	lui	a5,0x2000
   17bec:	fcf43823          	sd	a5,-48(s0)
    uint64_t *ddr = (uint64_t *)ADDR_BUS0_XSLV_DDR;
   17bf0:	00100793          	li	a5,1
   17bf4:	01f79793          	slli	a5,a5,0x1f
   17bf8:	fcf43423          	sd	a5,-56(s0)

    printf_uart("%s", "DDR Init . .");
   17bfc:	0001e7b7          	lui	a5,0x1e
   17c00:	cb878593          	addi	a1,a5,-840 # 1dcb8 <FCVT_WU_D_TESTS+0x680>
   17c04:	0001e7b7          	lui	a5,0x1e
   17c08:	cc878513          	addi	a0,a5,-824 # 1dcc8 <FCVT_WU_D_TESTS+0x690>
   17c0c:	ffffb097          	auipc	ra,0xffffb
   17c10:	d44080e7          	jalr	-700(ra) # 12950 <printf_uart>

    uint64_t t_start = clint->mtime;
   17c14:	fd043703          	ld	a4,-48(s0)
   17c18:	0000c7b7          	lui	a5,0xc
   17c1c:	00f707b3          	add	a5,a4,a5
   17c20:	ff87b783          	ld	a5,-8(a5) # bff8 <_ftext-0x4008>
   17c24:	fcf43023          	sd	a5,-64(s0)

    while ((prci->pll_status & PRCI_PLL_STATUS_DDR_CALIB_DONE) == 0) {
   17c28:	0480006f          	j	17c70 <test_ddr+0xa0>
        // 3 seconds timeout:
        if ((clint->mtime - t_start) > 3 * SYS_HZ) {
   17c2c:	fd043703          	ld	a4,-48(s0)
   17c30:	0000c7b7          	lui	a5,0xc
   17c34:	00f707b3          	add	a5,a4,a5
   17c38:	ff87b703          	ld	a4,-8(a5) # bff8 <_ftext-0x4008>
   17c3c:	fc043783          	ld	a5,-64(s0)
   17c40:	40f70733          	sub	a4,a4,a5
   17c44:	072717b7          	lui	a5,0x7271
   17c48:	e0078793          	addi	a5,a5,-512 # 7270e00 <_end+0x7251564>
   17c4c:	02e7f263          	bleu	a4,a5,17c70 <test_ddr+0xa0>
            printf_uart("%s", "NO_CALIB\r\n");
   17c50:	0001e7b7          	lui	a5,0x1e
   17c54:	cd078593          	addi	a1,a5,-816 # 1dcd0 <FCVT_WU_D_TESTS+0x698>
   17c58:	0001e7b7          	lui	a5,0x1e
   17c5c:	cc878513          	addi	a0,a5,-824 # 1dcc8 <FCVT_WU_D_TESTS+0x690>
   17c60:	ffffb097          	auipc	ra,0xffffb
   17c64:	cf0080e7          	jalr	-784(ra) # 12950 <printf_uart>
            return -1;
   17c68:	fff00793          	li	a5,-1
   17c6c:	2180006f          	j	17e84 <test_ddr+0x2b4>
    while ((prci->pll_status & PRCI_PLL_STATUS_DDR_CALIB_DONE) == 0) {
   17c70:	fd843783          	ld	a5,-40(s0)
   17c74:	0007a783          	lw	a5,0(a5)
   17c78:	0027f793          	andi	a5,a5,2
   17c7c:	0007879b          	sext.w	a5,a5
   17c80:	fa0786e3          	beqz	a5,17c2c <test_ddr+0x5c>
        }
    }
    printf_uart("%s", "DONE\r\n");
   17c84:	0001e7b7          	lui	a5,0x1e
   17c88:	ce078593          	addi	a1,a5,-800 # 1dce0 <FCVT_WU_D_TESTS+0x6a8>
   17c8c:	0001e7b7          	lui	a5,0x1e
   17c90:	cc878513          	addi	a0,a5,-824 # 1dcc8 <FCVT_WU_D_TESTS+0x690>
   17c94:	ffffb097          	auipc	ra,0xffffb
   17c98:	cbc080e7          	jalr	-836(ra) # 12950 <printf_uart>

    // Cache L1 associativity is 4, write more than 4 lines to trigger cache offloading.    
    ddr[0] = 0x1122334455667788ull;
   17c9c:	fc843783          	ld	a5,-56(s0)
   17ca0:	0001e737          	lui	a4,0x1e
   17ca4:	de873703          	ld	a4,-536(a4) # 1dde8 <FCVT_WU_D_TESTS+0x7b0>
   17ca8:	00e7b023          	sd	a4,0(a5)
    ddr[1] = 0xffeeddccbbaa9988ull;
   17cac:	fc843783          	ld	a5,-56(s0)
   17cb0:	00878793          	addi	a5,a5,8
   17cb4:	0001e737          	lui	a4,0x1e
   17cb8:	df073703          	ld	a4,-528(a4) # 1ddf0 <FCVT_WU_D_TESTS+0x7b8>
   17cbc:	00e7b023          	sd	a4,0(a5)
    for (int i = 1; i < 18; i++) {
   17cc0:	00100793          	li	a5,1
   17cc4:	fef42623          	sw	a5,-20(s0)
   17cc8:	0400006f          	j	17d08 <test_ddr+0x138>
        ddr[i*1024*1024] = 0xcafef00ddead0001ull + 0x100*i;
   17ccc:	fec42783          	lw	a5,-20(s0)
   17cd0:	0087979b          	slliw	a5,a5,0x8
   17cd4:	0007879b          	sext.w	a5,a5
   17cd8:	00078693          	mv	a3,a5
   17cdc:	fec42783          	lw	a5,-20(s0)
   17ce0:	01779793          	slli	a5,a5,0x17
   17ce4:	fc843703          	ld	a4,-56(s0)
   17ce8:	00f707b3          	add	a5,a4,a5
   17cec:	0001e737          	lui	a4,0x1e
   17cf0:	df873703          	ld	a4,-520(a4) # 1ddf8 <FCVT_WU_D_TESTS+0x7c0>
   17cf4:	00e68733          	add	a4,a3,a4
   17cf8:	00e7b023          	sd	a4,0(a5)
    for (int i = 1; i < 18; i++) {
   17cfc:	fec42783          	lw	a5,-20(s0)
   17d00:	0017879b          	addiw	a5,a5,1
   17d04:	fef42623          	sw	a5,-20(s0)
   17d08:	fec42783          	lw	a5,-20(s0)
   17d0c:	0007871b          	sext.w	a4,a5
   17d10:	01100793          	li	a5,17
   17d14:	fae7dce3          	ble	a4,a5,17ccc <test_ddr+0xfc>
    }
    printf_uart("DDR[0] . . . . .0x%016llx expected 0x1122334455667788ull\r\n", ddr[0]);
   17d18:	fc843783          	ld	a5,-56(s0)
   17d1c:	0007b783          	ld	a5,0(a5)
   17d20:	00078593          	mv	a1,a5
   17d24:	0001e7b7          	lui	a5,0x1e
   17d28:	ce878513          	addi	a0,a5,-792 # 1dce8 <FCVT_WU_D_TESTS+0x6b0>
   17d2c:	ffffb097          	auipc	ra,0xffffb
   17d30:	c24080e7          	jalr	-988(ra) # 12950 <printf_uart>
    printf_uart("DDR[1] . . . . .0x%016llx expected 0xffeeddccbbaa9988ull\r\n", ddr[1]);
   17d34:	fc843783          	ld	a5,-56(s0)
   17d38:	00878793          	addi	a5,a5,8
   17d3c:	0007b783          	ld	a5,0(a5)
   17d40:	00078593          	mv	a1,a5
   17d44:	0001e7b7          	lui	a5,0x1e
   17d48:	d2878513          	addi	a0,a5,-728 # 1dd28 <FCVT_WU_D_TESTS+0x6f0>
   17d4c:	ffffb097          	auipc	ra,0xffffb
   17d50:	c04080e7          	jalr	-1020(ra) # 12950 <printf_uart>
    printf_uart("DDR[9MB] . . . .0x%016llx expected 0xcafef00ddead0901ull\r\n", ddr[9*1024*1024]);
   17d54:	fc843703          	ld	a4,-56(s0)
   17d58:	048007b7          	lui	a5,0x4800
   17d5c:	00f707b3          	add	a5,a4,a5
   17d60:	0007b783          	ld	a5,0(a5) # 4800000 <_end+0x47e0764>
   17d64:	00078593          	mv	a1,a5
   17d68:	0001e7b7          	lui	a5,0x1e
   17d6c:	d6878513          	addi	a0,a5,-664 # 1dd68 <FCVT_WU_D_TESTS+0x730>
   17d70:	ffffb097          	auipc	ra,0xffffb
   17d74:	be0080e7          	jalr	-1056(ra) # 12950 <printf_uart>

    int err = 0;
   17d78:	fe042423          	sw	zero,-24(s0)

    if (ddr[0] != 0x1122334455667788ull) {
   17d7c:	fc843783          	ld	a5,-56(s0)
   17d80:	0007b703          	ld	a4,0(a5)
   17d84:	0001e7b7          	lui	a5,0x1e
   17d88:	de87b783          	ld	a5,-536(a5) # 1dde8 <FCVT_WU_D_TESTS+0x7b0>
   17d8c:	00f70663          	beq	a4,a5,17d98 <test_ddr+0x1c8>
        err = 1;
   17d90:	00100793          	li	a5,1
   17d94:	fef42423          	sw	a5,-24(s0)
    }
    if (err == 0 && ddr[1] != 0xffeeddccbbaa9988ull) {
   17d98:	fe842783          	lw	a5,-24(s0)
   17d9c:	0007879b          	sext.w	a5,a5
   17da0:	02079263          	bnez	a5,17dc4 <test_ddr+0x1f4>
   17da4:	fc843783          	ld	a5,-56(s0)
   17da8:	00878793          	addi	a5,a5,8
   17dac:	0007b703          	ld	a4,0(a5)
   17db0:	0001e7b7          	lui	a5,0x1e
   17db4:	df07b783          	ld	a5,-528(a5) # 1ddf0 <FCVT_WU_D_TESTS+0x7b8>
   17db8:	00f70663          	beq	a4,a5,17dc4 <test_ddr+0x1f4>
        err = 2;
   17dbc:	00200793          	li	a5,2
   17dc0:	fef42423          	sw	a5,-24(s0)
    }
    if (err == 0) {
   17dc4:	fe842783          	lw	a5,-24(s0)
   17dc8:	0007879b          	sext.w	a5,a5
   17dcc:	06079863          	bnez	a5,17e3c <test_ddr+0x26c>
        for (int i = 1; i < 18; i++) {
   17dd0:	00100793          	li	a5,1
   17dd4:	fef42223          	sw	a5,-28(s0)
   17dd8:	0540006f          	j	17e2c <test_ddr+0x25c>
            if (ddr[i*1024*1024] != 0xcafef00ddead0001ull + 0x100*i) {
   17ddc:	fe442783          	lw	a5,-28(s0)
   17de0:	01779793          	slli	a5,a5,0x17
   17de4:	fc843703          	ld	a4,-56(s0)
   17de8:	00f707b3          	add	a5,a4,a5
   17dec:	0007b703          	ld	a4,0(a5)
   17df0:	fe442783          	lw	a5,-28(s0)
   17df4:	0087979b          	slliw	a5,a5,0x8
   17df8:	0007879b          	sext.w	a5,a5
   17dfc:	00078693          	mv	a3,a5
   17e00:	0001e7b7          	lui	a5,0x1e
   17e04:	df87b783          	ld	a5,-520(a5) # 1ddf8 <FCVT_WU_D_TESTS+0x7c0>
   17e08:	00f687b3          	add	a5,a3,a5
   17e0c:	00f70a63          	beq	a4,a5,17e20 <test_ddr+0x250>
                err = 2 + i;
   17e10:	fe442783          	lw	a5,-28(s0)
   17e14:	0027879b          	addiw	a5,a5,2
   17e18:	fef42423          	sw	a5,-24(s0)
                break;
   17e1c:	0200006f          	j	17e3c <test_ddr+0x26c>
        for (int i = 1; i < 18; i++) {
   17e20:	fe442783          	lw	a5,-28(s0)
   17e24:	0017879b          	addiw	a5,a5,1
   17e28:	fef42223          	sw	a5,-28(s0)
   17e2c:	fe442783          	lw	a5,-28(s0)
   17e30:	0007871b          	sext.w	a4,a5
   17e34:	01100793          	li	a5,17
   17e38:	fae7d2e3          	ble	a4,a5,17ddc <test_ddr+0x20c>
            }
        }
    }

    if (err == 0) {
   17e3c:	fe842783          	lw	a5,-24(s0)
   17e40:	0007879b          	sext.w	a5,a5
   17e44:	02079263          	bnez	a5,17e68 <test_ddr+0x298>
        printf_uart("DDR. . . . . . .%s\r\n", "PASS");
   17e48:	0001e7b7          	lui	a5,0x1e
   17e4c:	da878593          	addi	a1,a5,-600 # 1dda8 <FCVT_WU_D_TESTS+0x770>
   17e50:	0001e7b7          	lui	a5,0x1e
   17e54:	db078513          	addi	a0,a5,-592 # 1ddb0 <FCVT_WU_D_TESTS+0x778>
   17e58:	ffffb097          	auipc	ra,0xffffb
   17e5c:	af8080e7          	jalr	-1288(ra) # 12950 <printf_uart>
        return 0;
   17e60:	00000793          	li	a5,0
   17e64:	0200006f          	j	17e84 <test_ddr+0x2b4>
    }
    printf_uart("DDR. . . . . . .FAILED,err=%d\r\n", err);
   17e68:	fe842783          	lw	a5,-24(s0)
   17e6c:	00078593          	mv	a1,a5
   17e70:	0001e7b7          	lui	a5,0x1e
   17e74:	dc878513          	addi	a0,a5,-568 # 1ddc8 <FCVT_WU_D_TESTS+0x790>
   17e78:	ffffb097          	auipc	ra,0xffffb
   17e7c:	ad8080e7          	jalr	-1320(ra) # 12950 <printf_uart>
    return -2;
   17e80:	ffe00793          	li	a5,-2
}
   17e84:	00078513          	mv	a0,a5
   17e88:	03813083          	ld	ra,56(sp)
   17e8c:	03013403          	ld	s0,48(sp)
   17e90:	04010113          	addi	sp,sp,64
   17e94:	00008067          	ret
   17e98:	0000                	unimp
	...

0000000000017e9c <get_dev_bar>:
static uint64_t get_dev_bar(pnp_map *pnp, uint16_t vid, uint16_t did) {
   17e9c:	fb010113          	addi	sp,sp,-80
   17ea0:	04813423          	sd	s0,72(sp)
   17ea4:	05010413          	addi	s0,sp,80
   17ea8:	faa43c23          	sd	a0,-72(s0)
   17eac:	00058793          	mv	a5,a1
   17eb0:	00060713          	mv	a4,a2
   17eb4:	faf41b23          	sh	a5,-74(s0)
   17eb8:	00070793          	mv	a5,a4
   17ebc:	faf41a23          	sh	a5,-76(s0)
    int slots_total = (pnp->cfg >> 8) & 0xFF;
   17ec0:	fb843783          	ld	a5,-72(s0)
   17ec4:	0087a783          	lw	a5,8(a5)
   17ec8:	0087d79b          	srliw	a5,a5,0x8
   17ecc:	0007879b          	sext.w	a5,a5
   17ed0:	0007879b          	sext.w	a5,a5
   17ed4:	0ff7f793          	andi	a5,a5,255
   17ed8:	fef42223          	sw	a5,-28(s0)
    int off = 0;
   17edc:	fe042623          	sw	zero,-20(s0)
    for (int i = 0; i < slots_total; i++) {
   17ee0:	fe042423          	sw	zero,-24(s0)
   17ee4:	09c0006f          	j	17f80 <get_dev_bar+0xe4>
        dcfg = *(dev_cfg_type *)&pnp->cfg_table[off];
   17ee8:	fec42783          	lw	a5,-20(s0)
   17eec:	04078793          	addi	a5,a5,64
   17ef0:	fb843703          	ld	a4,-72(s0)
   17ef4:	00f707b3          	add	a5,a4,a5
   17ef8:	0007b703          	ld	a4,0(a5)
   17efc:	fce43023          	sd	a4,-64(s0)
   17f00:	0087b703          	ld	a4,8(a5)
   17f04:	fce43423          	sd	a4,-56(s0)
   17f08:	0107b703          	ld	a4,16(a5)
   17f0c:	fce43823          	sd	a4,-48(s0)
   17f10:	0187b783          	ld	a5,24(a5)
   17f14:	fcf43c23          	sd	a5,-40(s0)
        off += sizeof(dcfg);
   17f18:	fec42783          	lw	a5,-20(s0)
   17f1c:	0207879b          	addiw	a5,a5,32
   17f20:	0007879b          	sext.w	a5,a5
   17f24:	fef42623          	sw	a5,-20(s0)
        if (dcfg.u.descrtype != PNP_CFG_TYPE_SLAVE) {
   17f28:	fc144783          	lbu	a5,-63(s0)
   17f2c:	0037f793          	andi	a5,a5,3
   17f30:	0ff7f793          	andi	a5,a5,255
   17f34:	00078713          	mv	a4,a5
   17f38:	00200793          	li	a5,2
   17f3c:	02f71a63          	bne	a4,a5,17f70 <get_dev_bar+0xd4>
        if (dcfg.u.vid == vid && dcfg.u.did == did) {
   17f40:	fc645783          	lhu	a5,-58(s0)
   17f44:	fb645703          	lhu	a4,-74(s0)
   17f48:	0007071b          	sext.w	a4,a4
   17f4c:	0007879b          	sext.w	a5,a5
   17f50:	02f71263          	bne	a4,a5,17f74 <get_dev_bar+0xd8>
   17f54:	fc445783          	lhu	a5,-60(s0)
   17f58:	fb445703          	lhu	a4,-76(s0)
   17f5c:	0007071b          	sext.w	a4,a4
   17f60:	0007879b          	sext.w	a5,a5
   17f64:	00f71863          	bne	a4,a5,17f74 <get_dev_bar+0xd8>
            return dcfg.u.addr_start;
   17f68:	fd043783          	ld	a5,-48(s0)
   17f6c:	02c0006f          	j	17f98 <get_dev_bar+0xfc>
            continue;
   17f70:	00000013          	nop
    for (int i = 0; i < slots_total; i++) {
   17f74:	fe842783          	lw	a5,-24(s0)
   17f78:	0017879b          	addiw	a5,a5,1
   17f7c:	fef42423          	sw	a5,-24(s0)
   17f80:	fe842703          	lw	a4,-24(s0)
   17f84:	fe442783          	lw	a5,-28(s0)
   17f88:	0007071b          	sext.w	a4,a4
   17f8c:	0007879b          	sext.w	a5,a5
   17f90:	f4f74ce3          	blt	a4,a5,17ee8 <get_dev_bar+0x4c>
    return DEV_NONE;
   17f94:	fff00793          	li	a5,-1
}
   17f98:	00078513          	mv	a0,a5
   17f9c:	04813403          	ld	s0,72(sp)
   17fa0:	05010113          	addi	sp,sp,80
   17fa4:	00008067          	ret

0000000000017fa8 <mpu_region_total>:
static int mpu_region_total() {
   17fa8:	fe010113          	addi	sp,sp,-32
   17fac:	00813c23          	sd	s0,24(sp)
   17fb0:	02010413          	addi	s0,sp,32
    uint64_t val = 0;
   17fb4:	fe043423          	sd	zero,-24(s0)
    asm("csrr %0, 0xBC4" : "=r" (val));
   17fb8:	bc4027f3          	csrr	a5,0xbc4
   17fbc:	fef43423          	sd	a5,-24(s0)
    return (int)(val >> 8);
   17fc0:	fe843783          	ld	a5,-24(s0)
   17fc4:	0087d793          	srli	a5,a5,0x8
   17fc8:	0007879b          	sext.w	a5,a5
}
   17fcc:	00078513          	mv	a0,a5
   17fd0:	01813403          	ld	s0,24(sp)
   17fd4:	02010113          	addi	sp,sp,32
   17fd8:	00008067          	ret

0000000000017fdc <mpu_disable_region>:
static void mpu_disable_region(int idx) {
   17fdc:	fd010113          	addi	sp,sp,-48
   17fe0:	02813423          	sd	s0,40(sp)
   17fe4:	03010413          	addi	s0,sp,48
   17fe8:	00050793          	mv	a5,a0
   17fec:	fcf42e23          	sw	a5,-36(s0)
    ctrl.value = 0;
   17ff0:	fe043423          	sd	zero,-24(s0)
    ctrl.bits.IDX = idx;
   17ff4:	fdc42783          	lw	a5,-36(s0)
   17ff8:	0ff7f793          	andi	a5,a5,255
   17ffc:	fef404a3          	sb	a5,-23(s0)
    ctrl.bits.WE = 1;
   18000:	fe844783          	lbu	a5,-24(s0)
   18004:	f807e793          	ori	a5,a5,-128
   18008:	fef40423          	sb	a5,-24(s0)
    asm("csrw 0xBC4, %0" : :"r"(ctrl.value));
   1800c:	fe843783          	ld	a5,-24(s0)
   18010:	bc479073          	csrw	0xbc4,a5
}
   18014:	00000013          	nop
   18018:	02813403          	ld	s0,40(sp)
   1801c:	03010113          	addi	sp,sp,48
   18020:	00008067          	ret

0000000000018024 <mpu_enable_region>:
                       const char *rwx) {
   18024:	fb010113          	addi	sp,sp,-80
   18028:	04813423          	sd	s0,72(sp)
   1802c:	05010413          	addi	s0,sp,80
   18030:	00050793          	mv	a5,a0
   18034:	fcb43023          	sd	a1,-64(s0)
   18038:	fac43c23          	sd	a2,-72(s0)
   1803c:	fae43823          	sd	a4,-80(s0)
   18040:	fcf42623          	sw	a5,-52(s0)
   18044:	00068793          	mv	a5,a3
   18048:	fcf42423          	sw	a5,-56(s0)
    uint64_t mask = (~0ull) << 10;
   1804c:	c0000793          	li	a5,-1024
   18050:	fef43423          	sd	a5,-24(s0)
    const char *p = rwx;
   18054:	fb043783          	ld	a5,-80(s0)
   18058:	fef43023          	sd	a5,-32(s0)
    asm("csrw 0xBC2, %0" : :"r"(bar));
   1805c:	fc043783          	ld	a5,-64(s0)
   18060:	bc279073          	csrw	0xbc2,a5
    KB >>= 1;
   18064:	fb843783          	ld	a5,-72(s0)
   18068:	0017d793          	srli	a5,a5,0x1
   1806c:	faf43c23          	sd	a5,-72(s0)
    while (KB) {
   18070:	01c0006f          	j	1808c <mpu_enable_region+0x68>
        mask <<= 1;
   18074:	fe843783          	ld	a5,-24(s0)
   18078:	00179793          	slli	a5,a5,0x1
   1807c:	fef43423          	sd	a5,-24(s0)
        KB >>= 1;
   18080:	fb843783          	ld	a5,-72(s0)
   18084:	0017d793          	srli	a5,a5,0x1
   18088:	faf43c23          	sd	a5,-72(s0)
    while (KB) {
   1808c:	fb843783          	ld	a5,-72(s0)
   18090:	fe0792e3          	bnez	a5,18074 <mpu_enable_region+0x50>
    asm("csrw 0xBC3, %0" : :"r"(mask));
   18094:	fe843783          	ld	a5,-24(s0)
   18098:	bc379073          	csrw	0xbc3,a5
    ctrl.value = 0;
   1809c:	fc043c23          	sd	zero,-40(s0)
    ctrl.bits.IDX = idx;
   180a0:	fcc42783          	lw	a5,-52(s0)
   180a4:	0ff7f793          	andi	a5,a5,255
   180a8:	fcf40ca3          	sb	a5,-39(s0)
    ctrl.bits.ENA = 1;
   180ac:	fd844783          	lbu	a5,-40(s0)
   180b0:	0107e793          	ori	a5,a5,16
   180b4:	fcf40c23          	sb	a5,-40(s0)
    ctrl.bits.CACHABLE = cached;
   180b8:	fc842783          	lw	a5,-56(s0)
   180bc:	0017f793          	andi	a5,a5,1
   180c0:	0ff7f793          	andi	a5,a5,255
   180c4:	0017f793          	andi	a5,a5,1
   180c8:	0037969b          	slliw	a3,a5,0x3
   180cc:	fd844783          	lbu	a5,-40(s0)
   180d0:	ff77f793          	andi	a5,a5,-9
   180d4:	00078713          	mv	a4,a5
   180d8:	00068793          	mv	a5,a3
   180dc:	00f767b3          	or	a5,a4,a5
   180e0:	fcf40c23          	sb	a5,-40(s0)
    ctrl.bits.WE = 1; // write into MPU
   180e4:	fd844783          	lbu	a5,-40(s0)
   180e8:	f807e793          	ori	a5,a5,-128
   180ec:	fcf40c23          	sb	a5,-40(s0)
    while (*p) {
   180f0:	0700006f          	j	18160 <mpu_enable_region+0x13c>
        if (*p == 'r') {
   180f4:	fe043783          	ld	a5,-32(s0)
   180f8:	0007c783          	lbu	a5,0(a5)
   180fc:	00078713          	mv	a4,a5
   18100:	07200793          	li	a5,114
   18104:	00f71863          	bne	a4,a5,18114 <mpu_enable_region+0xf0>
            ctrl.bits.RD = 1;
   18108:	fd844783          	lbu	a5,-40(s0)
   1810c:	0027e793          	ori	a5,a5,2
   18110:	fcf40c23          	sb	a5,-40(s0)
        if (*p == 'w') {
   18114:	fe043783          	ld	a5,-32(s0)
   18118:	0007c783          	lbu	a5,0(a5)
   1811c:	00078713          	mv	a4,a5
   18120:	07700793          	li	a5,119
   18124:	00f71863          	bne	a4,a5,18134 <mpu_enable_region+0x110>
            ctrl.bits.WR = 1;
   18128:	fd844783          	lbu	a5,-40(s0)
   1812c:	0017e793          	ori	a5,a5,1
   18130:	fcf40c23          	sb	a5,-40(s0)
        if (*p == 'x') {
   18134:	fe043783          	ld	a5,-32(s0)
   18138:	0007c783          	lbu	a5,0(a5)
   1813c:	00078713          	mv	a4,a5
   18140:	07800793          	li	a5,120
   18144:	00f71863          	bne	a4,a5,18154 <mpu_enable_region+0x130>
            ctrl.bits.EXEC = 1;
   18148:	fd844783          	lbu	a5,-40(s0)
   1814c:	0047e793          	ori	a5,a5,4
   18150:	fcf40c23          	sb	a5,-40(s0)
        p++;
   18154:	fe043783          	ld	a5,-32(s0)
   18158:	00178793          	addi	a5,a5,1
   1815c:	fef43023          	sd	a5,-32(s0)
    while (*p) {
   18160:	fe043783          	ld	a5,-32(s0)
   18164:	0007c783          	lbu	a5,0(a5)
   18168:	f80796e3          	bnez	a5,180f4 <mpu_enable_region+0xd0>
    asm("csrw 0xBC4, %0" : :"r"(ctrl.value));
   1816c:	fd843783          	ld	a5,-40(s0)
   18170:	bc479073          	csrw	0xbc4,a5
}
   18174:	00000013          	nop
   18178:	04813403          	ld	s0,72(sp)
   1817c:	05010113          	addi	sp,sp,80
   18180:	00008067          	ret

0000000000018184 <spi_is_idle>:
    uint8_t rxbuf[512]; // 512 data block
    uint16_t crc16_rx;
    uint16_t crc16_calculated;
} SpiDriverDataType;

static int32_t spi_is_idle(SpiDriverDataType *p) {
   18184:	fe010113          	addi	sp,sp,-32
   18188:	00813c23          	sd	s0,24(sp)
   1818c:	02010413          	addi	s0,sp,32
   18190:	fea43423          	sd	a0,-24(s0)
    // Bits[6:4] state machine state. 0 = idle    
    if ((p->map->rsrv4 & 0x70) == 0) {
   18194:	fe843783          	ld	a5,-24(s0)
   18198:	0007b783          	ld	a5,0(a5)
   1819c:	0447a783          	lw	a5,68(a5)
   181a0:	0007879b          	sext.w	a5,a5
   181a4:	0707f793          	andi	a5,a5,112
   181a8:	0007879b          	sext.w	a5,a5
   181ac:	00079663          	bnez	a5,181b8 <spi_is_idle+0x34>
        return 1;
   181b0:	00100793          	li	a5,1
   181b4:	0080006f          	j	181bc <spi_is_idle+0x38>
    }
    return 0;
   181b8:	00000793          	li	a5,0
}
   181bc:	00078513          	mv	a0,a5
   181c0:	01813403          	ld	s0,24(sp)
   181c4:	02010113          	addi	sp,sp,32
   181c8:	00008067          	ret

00000000000181cc <spi_init_crc15>:

static void spi_init_crc15(SpiDriverDataType *p) {
   181cc:	fe010113          	addi	sp,sp,-32
   181d0:	00813c23          	sd	s0,24(sp)
   181d4:	02010413          	addi	s0,sp,32
   181d8:	fea43423          	sd	a0,-24(s0)
    p->map->crc16 = 0;
   181dc:	fe843783          	ld	a5,-24(s0)
   181e0:	0007b783          	ld	a5,0(a5)
   181e4:	0407ac23          	sw	zero,88(a5)
}
   181e8:	00000013          	nop
   181ec:	01813403          	ld	s0,24(sp)
   181f0:	02010113          	addi	sp,sp,32
   181f4:	00008067          	ret

00000000000181f8 <spi_send_dummy>:

static int32_t spi_send_dummy(SpiDriverDataType *p, uint32_t cnt) {
   181f8:	fe010113          	addi	sp,sp,-32
   181fc:	00113c23          	sd	ra,24(sp)
   18200:	00813823          	sd	s0,16(sp)
   18204:	02010413          	addi	s0,sp,32
   18208:	fea43423          	sd	a0,-24(s0)
   1820c:	00058793          	mv	a5,a1
   18210:	fef42223          	sw	a5,-28(s0)
    p->map->rsrv4 = (cnt << 16);  // transmit bytes 1 no CRC
   18214:	fe843783          	ld	a5,-24(s0)
   18218:	0007b783          	ld	a5,0(a5)
   1821c:	fe442703          	lw	a4,-28(s0)
   18220:	0107171b          	slliw	a4,a4,0x10
   18224:	0007071b          	sext.w	a4,a4
   18228:	04e7a223          	sw	a4,68(a5)
    while (!spi_is_idle(p)) {}
   1822c:	00000013          	nop
   18230:	fe843503          	ld	a0,-24(s0)
   18234:	f51ff0ef          	jal	ra,18184 <spi_is_idle>
   18238:	00050793          	mv	a5,a0
   1823c:	fe078ae3          	beqz	a5,18230 <spi_send_dummy+0x38>
    return 0;
   18240:	00000793          	li	a5,0
}
   18244:	00078513          	mv	a0,a5
   18248:	01813083          	ld	ra,24(sp)
   1824c:	01013403          	ld	s0,16(sp)
   18250:	02010113          	addi	sp,sp,32
   18254:	00008067          	ret

0000000000018258 <spi_send_cmd>:

static int32_t spi_send_cmd(SpiDriverDataType *p, uint8_t cmd, uint32_t payload) {
   18258:	fe010113          	addi	sp,sp,-32
   1825c:	00113c23          	sd	ra,24(sp)
   18260:	00813823          	sd	s0,16(sp)
   18264:	02010413          	addi	s0,sp,32
   18268:	fea43423          	sd	a0,-24(s0)
   1826c:	00058793          	mv	a5,a1
   18270:	00060713          	mv	a4,a2
   18274:	fef403a3          	sb	a5,-25(s0)
   18278:	00070793          	mv	a5,a4
   1827c:	fef42023          	sw	a5,-32(s0)
    p->map->txdata = 0x40 | cmd;  // [7] 0=start bit; [6] 1=host request
   18280:	fe744783          	lbu	a5,-25(s0)
   18284:	0407e793          	ori	a5,a5,64
   18288:	0ff7f713          	andi	a4,a5,255
   1828c:	fe843783          	ld	a5,-24(s0)
   18290:	0007b783          	ld	a5,0(a5)
   18294:	0007071b          	sext.w	a4,a4
   18298:	04e7a423          	sw	a4,72(a5)
    p->map->txdata = payload & 0xFF;
   1829c:	fe843783          	ld	a5,-24(s0)
   182a0:	0007b783          	ld	a5,0(a5)
   182a4:	fe042703          	lw	a4,-32(s0)
   182a8:	0ff77713          	andi	a4,a4,255
   182ac:	0007071b          	sext.w	a4,a4
   182b0:	04e7a423          	sw	a4,72(a5)
    p->map->txdata = (payload >> 8) & 0xFF;
   182b4:	fe042783          	lw	a5,-32(s0)
   182b8:	0087d79b          	srliw	a5,a5,0x8
   182bc:	0007871b          	sext.w	a4,a5
   182c0:	fe843783          	ld	a5,-24(s0)
   182c4:	0007b783          	ld	a5,0(a5)
   182c8:	0ff77713          	andi	a4,a4,255
   182cc:	0007071b          	sext.w	a4,a4
   182d0:	04e7a423          	sw	a4,72(a5)
    p->map->txdata = (payload >> 16) & 0xFF;
   182d4:	fe042783          	lw	a5,-32(s0)
   182d8:	0107d79b          	srliw	a5,a5,0x10
   182dc:	0007871b          	sext.w	a4,a5
   182e0:	fe843783          	ld	a5,-24(s0)
   182e4:	0007b783          	ld	a5,0(a5)
   182e8:	0ff77713          	andi	a4,a4,255
   182ec:	0007071b          	sext.w	a4,a4
   182f0:	04e7a423          	sw	a4,72(a5)
    p->map->txdata = (payload >> 24) & 0xFF;
   182f4:	fe843783          	ld	a5,-24(s0)
   182f8:	0007b783          	ld	a5,0(a5)
   182fc:	fe042703          	lw	a4,-32(s0)
   18300:	0187571b          	srliw	a4,a4,0x18
   18304:	0007071b          	sext.w	a4,a4
   18308:	04e7a423          	sw	a4,72(a5)

    p->map->rsrv4 = (5 << 16) | (1 << 7);  // send cmd + 4 bytes + generate CRC7 byte
   1830c:	fe843783          	ld	a5,-24(s0)
   18310:	0007b783          	ld	a5,0(a5)
   18314:	00050737          	lui	a4,0x50
   18318:	0807071b          	addiw	a4,a4,128
   1831c:	04e7a223          	sw	a4,68(a5)
    while (!spi_is_idle(p)) {}
   18320:	00000013          	nop
   18324:	fe843503          	ld	a0,-24(s0)
   18328:	00000097          	auipc	ra,0x0
   1832c:	e5c080e7          	jalr	-420(ra) # 18184 <spi_is_idle>
   18330:	00050793          	mv	a5,a0
   18334:	fe0788e3          	beqz	a5,18324 <spi_send_cmd+0xcc>
    return 0;
   18338:	00000793          	li	a5,0
}
   1833c:	00078513          	mv	a0,a5
   18340:	01813083          	ld	ra,24(sp)
   18344:	01013403          	ld	s0,16(sp)
   18348:	02010113          	addi	sp,sp,32
   1834c:	00008067          	ret

0000000000018350 <read_rx_fifo>:

int read_rx_fifo(SpiDriverDataType *p) {
   18350:	fd010113          	addi	sp,sp,-48
   18354:	02813423          	sd	s0,40(sp)
   18358:	03010413          	addi	s0,sp,48
   1835c:	fca43c23          	sd	a0,-40(s0)
    int ret = 0;
   18360:	fe042623          	sw	zero,-20(s0)
    uint32_t rdata;

    rdata = p->map->rxdata;
   18364:	fd843783          	ld	a5,-40(s0)
   18368:	0007b783          	ld	a5,0(a5)
   1836c:	04c7a783          	lw	a5,76(a5)
   18370:	fef42423          	sw	a5,-24(s0)
    while ((rdata & QSPI_RXDATA_EMPTY) == 0) {
   18374:	0640006f          	j	183d8 <read_rx_fifo+0x88>
        if (p->rxcnt < sizeof(p->rxbuf)) {
   18378:	fd843783          	ld	a5,-40(s0)
   1837c:	00c7a783          	lw	a5,12(a5)
   18380:	0007879b          	sext.w	a5,a5
   18384:	00078713          	mv	a4,a5
   18388:	1ff00793          	li	a5,511
   1838c:	02e7e863          	bltu	a5,a4,183bc <read_rx_fifo+0x6c>
            p->rxbuf[p->rxcnt++] = (uint8_t)(rdata & 0xFF);
   18390:	fd843783          	ld	a5,-40(s0)
   18394:	00c7a783          	lw	a5,12(a5)
   18398:	0017871b          	addiw	a4,a5,1
   1839c:	0007069b          	sext.w	a3,a4
   183a0:	fd843703          	ld	a4,-40(s0)
   183a4:	00d72623          	sw	a3,12(a4) # 5000c <_end+0x30770>
   183a8:	fe842703          	lw	a4,-24(s0)
   183ac:	0ff77713          	andi	a4,a4,255
   183b0:	fd843683          	ld	a3,-40(s0)
   183b4:	00f687b3          	add	a5,a3,a5
   183b8:	00e78823          	sb	a4,16(a5)
        }
        rdata = p->map->rxdata;
   183bc:	fd843783          	ld	a5,-40(s0)
   183c0:	0007b783          	ld	a5,0(a5)
   183c4:	04c7a783          	lw	a5,76(a5)
   183c8:	fef42423          	sw	a5,-24(s0)
        ret++;
   183cc:	fec42783          	lw	a5,-20(s0)
   183d0:	0017879b          	addiw	a5,a5,1
   183d4:	fef42623          	sw	a5,-20(s0)
    while ((rdata & QSPI_RXDATA_EMPTY) == 0) {
   183d8:	fe842783          	lw	a5,-24(s0)
   183dc:	f807dee3          	bgez	a5,18378 <read_rx_fifo+0x28>
    }
    p->rxcnt = 0;  // prepare for the next read
   183e0:	fd843783          	ld	a5,-40(s0)
   183e4:	0007a623          	sw	zero,12(a5)
    return ret;
   183e8:	fec42783          	lw	a5,-20(s0)
}
   183ec:	00078513          	mv	a0,a5
   183f0:	02813403          	ld	s0,40(sp)
   183f4:	03010113          	addi	sp,sp,48
   183f8:	00008067          	ret

00000000000183fc <spi_recv_bytes>:

static int32_t spi_recv_bytes(SpiDriverDataType *p, uint32_t cnt, uint32_t synced) {
   183fc:	fd010113          	addi	sp,sp,-48
   18400:	02113423          	sd	ra,40(sp)
   18404:	02813023          	sd	s0,32(sp)
   18408:	03010413          	addi	s0,sp,48
   1840c:	fca43c23          	sd	a0,-40(s0)
   18410:	00058793          	mv	a5,a1
   18414:	00060713          	mv	a4,a2
   18418:	fcf42a23          	sw	a5,-44(s0)
   1841c:	00070793          	mv	a5,a4
   18420:	fcf42823          	sw	a5,-48(s0)
    uint32_t rxcnt;
    // [8] rx_ena=1
    // [9] rx_synced=0
    // [10] rx_data_block=0
    // [31:16] number of bytes=cnt
    p->map->rsrv4 = (1 << 8) | (synced << 9) | (cnt << 16);
   18424:	fd042783          	lw	a5,-48(s0)
   18428:	0097979b          	slliw	a5,a5,0x9
   1842c:	0007871b          	sext.w	a4,a5
   18430:	fd442783          	lw	a5,-44(s0)
   18434:	0107979b          	slliw	a5,a5,0x10
   18438:	0007879b          	sext.w	a5,a5
   1843c:	00f767b3          	or	a5,a4,a5
   18440:	0007871b          	sext.w	a4,a5
   18444:	fd843783          	ld	a5,-40(s0)
   18448:	0007b783          	ld	a5,0(a5)
   1844c:	10076713          	ori	a4,a4,256
   18450:	0007071b          	sext.w	a4,a4
   18454:	04e7a223          	sw	a4,68(a5)
    while (!spi_is_idle(p)) {}
   18458:	00000013          	nop
   1845c:	fd843503          	ld	a0,-40(s0)
   18460:	00000097          	auipc	ra,0x0
   18464:	d24080e7          	jalr	-732(ra) # 18184 <spi_is_idle>
   18468:	00050793          	mv	a5,a0
   1846c:	fe0788e3          	beqz	a5,1845c <spi_recv_bytes+0x60>
    rxcnt = read_rx_fifo(p);
   18470:	fd843503          	ld	a0,-40(s0)
   18474:	00000097          	auipc	ra,0x0
   18478:	edc080e7          	jalr	-292(ra) # 18350 <read_rx_fifo>
   1847c:	00050793          	mv	a5,a0
   18480:	fef42623          	sw	a5,-20(s0)
    if ((uint32_t)rxcnt != cnt) {
   18484:	fec42703          	lw	a4,-20(s0)
   18488:	fd442783          	lw	a5,-44(s0)
   1848c:	0007071b          	sext.w	a4,a4
   18490:	0007879b          	sext.w	a5,a5
   18494:	02f70063          	beq	a4,a5,184b4 <spi_recv_bytes+0xb8>
        printf_uart("warning: recv_bytes %d != %d\r\n", cnt, rxcnt);
   18498:	fec42703          	lw	a4,-20(s0)
   1849c:	fd442783          	lw	a5,-44(s0)
   184a0:	00070613          	mv	a2,a4
   184a4:	00078593          	mv	a1,a5
   184a8:	0001e7b7          	lui	a5,0x1e
   184ac:	e0078513          	addi	a0,a5,-512 # 1de00 <FCVT_WU_D_TESTS+0x7c8>
   184b0:	ca0fa0ef          	jal	ra,12950 <printf_uart>
    }
    return rxcnt;
   184b4:	fec42783          	lw	a5,-20(s0)
}
   184b8:	00078513          	mv	a0,a5
   184bc:	02813083          	ld	ra,40(sp)
   184c0:	02013403          	ld	s0,32(sp)
   184c4:	03010113          	addi	sp,sp,48
   184c8:	00008067          	ret

00000000000184cc <spi_recv_sync_data_block>:

static uint32_t spi_recv_sync_data_block(SpiDriverDataType *p) {
   184cc:	fd010113          	addi	sp,sp,-48
   184d0:	02113423          	sd	ra,40(sp)
   184d4:	02813023          	sd	s0,32(sp)
   184d8:	03010413          	addi	s0,sp,48
   184dc:	fca43c23          	sd	a0,-40(s0)
    uint32_t rxcnt;
    // [8] rx_ena=1
    // [9] rx_synced=0
    // [10] rx_data_block=1
    // [31:16] number of bytes=1
    p->map->rsrv4 = (1 << 8) | (1 << 10) | (1 << 16);
   184e0:	fd843783          	ld	a5,-40(s0)
   184e4:	0007b783          	ld	a5,0(a5)
   184e8:	00010737          	lui	a4,0x10
   184ec:	5007071b          	addiw	a4,a4,1280
   184f0:	04e7a223          	sw	a4,68(a5)
    while (!spi_is_idle(p)) {}
   184f4:	00000013          	nop
   184f8:	fd843503          	ld	a0,-40(s0)
   184fc:	c89ff0ef          	jal	ra,18184 <spi_is_idle>
   18500:	00050793          	mv	a5,a0
   18504:	fe078ae3          	beqz	a5,184f8 <spi_recv_sync_data_block+0x2c>
    rxcnt = read_rx_fifo(p);
   18508:	fd843503          	ld	a0,-40(s0)
   1850c:	e45ff0ef          	jal	ra,18350 <read_rx_fifo>
   18510:	00050793          	mv	a5,a0
   18514:	fef42623          	sw	a5,-20(s0)
    if (rxcnt != 1) {
   18518:	fec42783          	lw	a5,-20(s0)
   1851c:	0007871b          	sext.w	a4,a5
   18520:	00100793          	li	a5,1
   18524:	00f70e63          	beq	a4,a5,18540 <spi_recv_sync_data_block+0x74>
        printf_uart("warning: recv_bytes %d != 1\r\n", rxcnt);
   18528:	fec42783          	lw	a5,-20(s0)
   1852c:	00078593          	mv	a1,a5
   18530:	0001e7b7          	lui	a5,0x1e
   18534:	e2078513          	addi	a0,a5,-480 # 1de20 <FCVT_WU_D_TESTS+0x7e8>
   18538:	ffffa097          	auipc	ra,0xffffa
   1853c:	418080e7          	jalr	1048(ra) # 12950 <printf_uart>
    }
    return p->rxbuf[0];
   18540:	fd843783          	ld	a5,-40(s0)
   18544:	0107c783          	lbu	a5,16(a5)
   18548:	0007879b          	sext.w	a5,a5
}
   1854c:	00078513          	mv	a0,a5
   18550:	02813083          	ld	ra,40(sp)
   18554:	02013403          	ld	s0,32(sp)
   18558:	03010113          	addi	sp,sp,48
   1855c:	00008067          	ret

0000000000018560 <spi_recv_data_block_crc16>:

uint16_t spi_recv_data_block_crc16(SpiDriverDataType *p) {
   18560:	fd010113          	addi	sp,sp,-48
   18564:	02113423          	sd	ra,40(sp)
   18568:	02813023          	sd	s0,32(sp)
   1856c:	03010413          	addi	s0,sp,48
   18570:	fca43c23          	sd	a0,-40(s0)
    uint16_t ret = 0;
   18574:	fe041723          	sh	zero,-18(s0)
    // [8] rx_ena=1
    // [9] rx_synced=1
    // [10] rx_data_block=0
    // [31:16] number of bytes=2
    p->map->rsrv4 = (1 << 8) | (1 << 9) | (2 << 16);
   18578:	fd843783          	ld	a5,-40(s0)
   1857c:	0007b783          	ld	a5,0(a5)
   18580:	00020737          	lui	a4,0x20
   18584:	3007071b          	addiw	a4,a4,768
   18588:	04e7a223          	sw	a4,68(a5)
    while (!spi_is_idle(p)) {}
   1858c:	00000013          	nop
   18590:	fd843503          	ld	a0,-40(s0)
   18594:	00000097          	auipc	ra,0x0
   18598:	bf0080e7          	jalr	-1040(ra) # 18184 <spi_is_idle>
   1859c:	00050793          	mv	a5,a0
   185a0:	fe0788e3          	beqz	a5,18590 <spi_recv_data_block_crc16+0x30>
    ret = (uint16_t)(p->map->rxdata & 0xFF);
   185a4:	fd843783          	ld	a5,-40(s0)
   185a8:	0007b783          	ld	a5,0(a5)
   185ac:	04c7a783          	lw	a5,76(a5)
   185b0:	0007879b          	sext.w	a5,a5
   185b4:	03079793          	slli	a5,a5,0x30
   185b8:	0307d793          	srli	a5,a5,0x30
   185bc:	0ff7f793          	andi	a5,a5,255
   185c0:	fef41723          	sh	a5,-18(s0)
    ret = (ret << 8) | (uint16_t)(p->map->rxdata & 0xFF);
   185c4:	fee45783          	lhu	a5,-18(s0)
   185c8:	0007879b          	sext.w	a5,a5
   185cc:	0087979b          	slliw	a5,a5,0x8
   185d0:	0007879b          	sext.w	a5,a5
   185d4:	0107971b          	slliw	a4,a5,0x10
   185d8:	4107571b          	sraiw	a4,a4,0x10
   185dc:	fd843783          	ld	a5,-40(s0)
   185e0:	0007b783          	ld	a5,0(a5)
   185e4:	04c7a783          	lw	a5,76(a5)
   185e8:	0007879b          	sext.w	a5,a5
   185ec:	0107979b          	slliw	a5,a5,0x10
   185f0:	4107d79b          	sraiw	a5,a5,0x10
   185f4:	0ff7f793          	andi	a5,a5,255
   185f8:	0107979b          	slliw	a5,a5,0x10
   185fc:	4107d79b          	sraiw	a5,a5,0x10
   18600:	00f767b3          	or	a5,a4,a5
   18604:	0107979b          	slliw	a5,a5,0x10
   18608:	4107d79b          	sraiw	a5,a5,0x10
   1860c:	fef41723          	sh	a5,-18(s0)
    return ret;
   18610:	fee45783          	lhu	a5,-18(s0)
}
   18614:	00078513          	mv	a0,a5
   18618:	02813083          	ld	ra,40(sp)
   1861c:	02013403          	ld	s0,32(sp)
   18620:	03010113          	addi	sp,sp,48
   18624:	00008067          	ret

0000000000018628 <get_r1_response>:

uint8_t get_r1_response(SpiDriverDataType *p) {
   18628:	fd010113          	addi	sp,sp,-48
   1862c:	02113423          	sd	ra,40(sp)
   18630:	02813023          	sd	s0,32(sp)
   18634:	03010413          	addi	s0,sp,48
   18638:	fca43c23          	sd	a0,-40(s0)
    uint8_t ret;
    spi_recv_bytes(p, 1, RX_WAIT_SYNC);
   1863c:	00000613          	li	a2,0
   18640:	00100593          	li	a1,1
   18644:	fd843503          	ld	a0,-40(s0)
   18648:	00000097          	auipc	ra,0x0
   1864c:	db4080e7          	jalr	-588(ra) # 183fc <spi_recv_bytes>
    ret = p->rxbuf[0];
   18650:	fd843783          	ld	a5,-40(s0)
   18654:	0107c783          	lbu	a5,16(a5)
   18658:	fef407a3          	sb	a5,-17(s0)
    return ret;
   1865c:	fef44783          	lbu	a5,-17(s0)
}
   18660:	00078513          	mv	a0,a5
   18664:	02813083          	ld	ra,40(sp)
   18668:	02013403          	ld	s0,32(sp)
   1866c:	03010113          	addi	sp,sp,48
   18670:	00008067          	ret

0000000000018674 <get_ui32>:

// R3 is 40-bits split on [R1 (8-bits),R3 (32-bits)]
uint32_t get_ui32(SpiDriverDataType *p) {
   18674:	fd010113          	addi	sp,sp,-48
   18678:	02113423          	sd	ra,40(sp)
   1867c:	02813023          	sd	s0,32(sp)
   18680:	03010413          	addi	s0,sp,48
   18684:	fca43c23          	sd	a0,-40(s0)
    uint32_t ret = 0;
   18688:	fe042623          	sw	zero,-20(s0)
    int rxcnt;
    rxcnt = spi_recv_bytes(p, 4, RX_IS_SYNCED);
   1868c:	00100613          	li	a2,1
   18690:	00400593          	li	a1,4
   18694:	fd843503          	ld	a0,-40(s0)
   18698:	d65ff0ef          	jal	ra,183fc <spi_recv_bytes>
   1869c:	00050793          	mv	a5,a0
   186a0:	fef42223          	sw	a5,-28(s0)
    if (rxcnt != 4) {
   186a4:	fe442783          	lw	a5,-28(s0)
   186a8:	0007871b          	sext.w	a4,a5
   186ac:	00400793          	li	a5,4
   186b0:	00f70c63          	beq	a4,a5,186c8 <get_ui32+0x54>
        printf_uart("warning: get_ui32 rxcnt != %d\r\n", rxcnt);
   186b4:	fe442783          	lw	a5,-28(s0)
   186b8:	00078593          	mv	a1,a5
   186bc:	0001e7b7          	lui	a5,0x1e
   186c0:	e4078513          	addi	a0,a5,-448 # 1de40 <FCVT_WU_D_TESTS+0x808>
   186c4:	a8cfa0ef          	jal	ra,12950 <printf_uart>
    }
    for (int i = 0; i < rxcnt; i++) {
   186c8:	fe042423          	sw	zero,-24(s0)
   186cc:	03c0006f          	j	18708 <get_ui32+0x94>
        ret = (ret << 8) | p->rxbuf[i];
   186d0:	fec42783          	lw	a5,-20(s0)
   186d4:	0087979b          	slliw	a5,a5,0x8
   186d8:	0007869b          	sext.w	a3,a5
   186dc:	fd843703          	ld	a4,-40(s0)
   186e0:	fe842783          	lw	a5,-24(s0)
   186e4:	00f707b3          	add	a5,a4,a5
   186e8:	0107c783          	lbu	a5,16(a5)
   186ec:	0007879b          	sext.w	a5,a5
   186f0:	00068713          	mv	a4,a3
   186f4:	00f767b3          	or	a5,a4,a5
   186f8:	fef42623          	sw	a5,-20(s0)
    for (int i = 0; i < rxcnt; i++) {
   186fc:	fe842783          	lw	a5,-24(s0)
   18700:	0017879b          	addiw	a5,a5,1
   18704:	fef42423          	sw	a5,-24(s0)
   18708:	fe842703          	lw	a4,-24(s0)
   1870c:	fe442783          	lw	a5,-28(s0)
   18710:	0007071b          	sext.w	a4,a4
   18714:	0007879b          	sext.w	a5,a5
   18718:	faf74ce3          	blt	a4,a5,186d0 <get_ui32+0x5c>
    }
    return ret;
   1871c:	fec42783          	lw	a5,-20(s0)
}
   18720:	00078513          	mv	a0,a5
   18724:	02813083          	ld	ra,40(sp)
   18728:	02013403          	ld	s0,32(sp)
   1872c:	03010113          	addi	sp,sp,48
   18730:	00008067          	ret

0000000000018734 <spi_sd_card_init>:


ESdCardType spi_sd_card_init(SpiDriverDataType *p) {
   18734:	fc010113          	addi	sp,sp,-64
   18738:	02113c23          	sd	ra,56(sp)
   1873c:	02813823          	sd	s0,48(sp)
   18740:	04010413          	addi	s0,sp,64
   18744:	fca43423          	sd	a0,-56(s0)
    uint32_t R3;
    uint32_t R7;
    uint32_t OCR;
    uint32_t HCS;   // High Capacity Support
    int watchdog;
    clint_map *clint = (clint_map *)ADDR_BUS0_XSLV_CLINT;
   18748:	020007b7          	lui	a5,0x2000
   1874c:	fef43023          	sd	a5,-32(s0)
    p->etype = SD_Unknown;
   18750:	fc843783          	ld	a5,-56(s0)
   18754:	0007a423          	sw	zero,8(a5) # 2000008 <_end+0x1fe076c>

    // Reset SD-card
    R1 = 0;
   18758:	fc040fa3          	sb	zero,-33(s0)
    do {
        printf_uart("CMD0: %08x ", 0x0);
   1875c:	00000593          	li	a1,0
   18760:	0001e7b7          	lui	a5,0x1e
   18764:	e6078513          	addi	a0,a5,-416 # 1de60 <FCVT_WU_D_TESTS+0x828>
   18768:	ffffa097          	auipc	ra,0xffffa
   1876c:	1e8080e7          	jalr	488(ra) # 12950 <printf_uart>
        spi_send_cmd(p, CMD0, 0x0);
   18770:	00000613          	li	a2,0
   18774:	00000593          	li	a1,0
   18778:	fc843503          	ld	a0,-56(s0)
   1877c:	00000097          	auipc	ra,0x0
   18780:	adc080e7          	jalr	-1316(ra) # 18258 <spi_send_cmd>

        R1 = get_r1_response(p);
   18784:	fc843503          	ld	a0,-56(s0)
   18788:	ea1ff0ef          	jal	ra,18628 <get_r1_response>
   1878c:	00050793          	mv	a5,a0
   18790:	fcf40fa3          	sb	a5,-33(s0)
        printf_uart("R1: %02x\r\n", R1);
   18794:	fdf44783          	lbu	a5,-33(s0)
   18798:	0007879b          	sext.w	a5,a5
   1879c:	00078593          	mv	a1,a5
   187a0:	0001e7b7          	lui	a5,0x1e
   187a4:	e7078513          	addi	a0,a5,-400 # 1de70 <FCVT_WU_D_TESTS+0x838>
   187a8:	ffffa097          	auipc	ra,0xffffa
   187ac:	1a8080e7          	jalr	424(ra) # 12950 <printf_uart>
    } while (R1 != 0x01);
   187b0:	fdf44783          	lbu	a5,-33(s0)
   187b4:	0ff7f713          	andi	a4,a5,255
   187b8:	00100793          	li	a5,1
   187bc:	faf710e3          	bne	a4,a5,1875c <spi_sd_card_init+0x28>

    // Delay 2000 usec as implemented in uboot
    watchdog = clint->mtime;
   187c0:	fe043703          	ld	a4,-32(s0)
   187c4:	0000c7b7          	lui	a5,0xc
   187c8:	00f707b3          	add	a5,a4,a5
   187cc:	ff87b783          	ld	a5,-8(a5) # bff8 <_ftext-0x4008>
   187d0:	fef42423          	sw	a5,-24(s0)
    watchdog += 2 * SYS_HZ / 1000;
   187d4:	fe842703          	lw	a4,-24(s0)
   187d8:	000147b7          	lui	a5,0x14
   187dc:	8807879b          	addiw	a5,a5,-1920
   187e0:	00f707bb          	addw	a5,a4,a5
   187e4:	fef42423          	sw	a5,-24(s0)
    while (clint->mtime < watchdog) {}
   187e8:	00000013          	nop
   187ec:	fe043703          	ld	a4,-32(s0)
   187f0:	0000c7b7          	lui	a5,0xc
   187f4:	00f707b3          	add	a5,a4,a5
   187f8:	ff87b703          	ld	a4,-8(a5) # bff8 <_ftext-0x4008>
   187fc:	fe842783          	lw	a5,-24(s0)
   18800:	fef766e3          	bltu	a4,a5,187ec <spi_sd_card_init+0xb8>
    //               0001 2.7-3.6V
    //               0010 Reserved for Low Voltage Range
    //               0100 Reserved
    //               1000 Reserved
    //               Others Not defined
    printf_uart("%s", "CMD8: 000001AA ");
   18804:	0001e7b7          	lui	a5,0x1e
   18808:	e8078593          	addi	a1,a5,-384 # 1de80 <FCVT_WU_D_TESTS+0x848>
   1880c:	0001e7b7          	lui	a5,0x1e
   18810:	e9078513          	addi	a0,a5,-368 # 1de90 <FCVT_WU_D_TESTS+0x858>
   18814:	ffffa097          	auipc	ra,0xffffa
   18818:	13c080e7          	jalr	316(ra) # 12950 <printf_uart>
    spi_send_cmd(p, CMD8, 0x1AA);
   1881c:	1aa00613          	li	a2,426
   18820:	00800593          	li	a1,8
   18824:	fc843503          	ld	a0,-56(s0)
   18828:	00000097          	auipc	ra,0x0
   1882c:	a30080e7          	jalr	-1488(ra) # 18258 <spi_send_cmd>

    R1 = get_r1_response(p);
   18830:	fc843503          	ld	a0,-56(s0)
   18834:	df5ff0ef          	jal	ra,18628 <get_r1_response>
   18838:	00050793          	mv	a5,a0
   1883c:	fcf40fa3          	sb	a5,-33(s0)
    R7 = get_ui32(p);
   18840:	fc843503          	ld	a0,-56(s0)
   18844:	00000097          	auipc	ra,0x0
   18848:	e30080e7          	jalr	-464(ra) # 18674 <get_ui32>
   1884c:	00050793          	mv	a5,a0
   18850:	fcf42c23          	sw	a5,-40(s0)
    printf_uart("R1: %02x %08x\r\n", R1, R7);
   18854:	fdf44783          	lbu	a5,-33(s0)
   18858:	0007879b          	sext.w	a5,a5
   1885c:	fd842703          	lw	a4,-40(s0)
   18860:	00070613          	mv	a2,a4
   18864:	00078593          	mv	a1,a5
   18868:	0001e7b7          	lui	a5,0x1e
   1886c:	e9878513          	addi	a0,a5,-360 # 1de98 <FCVT_WU_D_TESTS+0x860>
   18870:	ffffa097          	auipc	ra,0xffffa
   18874:	0e0080e7          	jalr	224(ra) # 12950 <printf_uart>

    if (R1 == 0x01) {
   18878:	fdf44783          	lbu	a5,-33(s0)
   1887c:	0ff7f713          	andi	a4,a5,255
   18880:	00100793          	li	a5,1
   18884:	00f71a63          	bne	a4,a5,18898 <spi_sd_card_init+0x164>
       // SD-card ver 2 or higher (Standard or High Capacity)
       p->etype = SD_Ver2x_StandardCapacity;
   18888:	fc843783          	ld	a5,-56(s0)
   1888c:	00200713          	li	a4,2
   18890:	00e7a423          	sw	a4,8(a5)
   18894:	03c0006f          	j	188d0 <spi_sd_card_init+0x19c>
    } else if (R1 & R1_ILLEGAL_BIT) {
   18898:	fdf44783          	lbu	a5,-33(s0)
   1889c:	0007879b          	sext.w	a5,a5
   188a0:	0047f793          	andi	a5,a5,4
   188a4:	0007879b          	sext.w	a5,a5
   188a8:	00078a63          	beqz	a5,188bc <spi_sd_card_init+0x188>
       // SD-card ver 1.x or (Standard Capacity)
       p->etype = SD_Ver1x;
   188ac:	fc843783          	ld	a5,-56(s0)
   188b0:	00100713          	li	a4,1
   188b4:	00e7a423          	sw	a4,8(a5)
   188b8:	0180006f          	j	188d0 <spi_sd_card_init+0x19c>
    } else {
       p->etype = SD_Unknown;
   188bc:	fc843783          	ld	a5,-56(s0)
   188c0:	0007a423          	sw	zero,8(a5)
       return p->etype;
   188c4:	fc843783          	ld	a5,-56(s0)
   188c8:	0087a783          	lw	a5,8(a5)
   188cc:	3cc0006f          	j	18c98 <spi_sd_card_init+0x564>

    // CMD58 (Get OCR)
    // Not mandatory to send CMD58. Though it is recommended to be done in order
    // to get the supported voltage range of the card
    // Argument: none; Response R3 (5 bytes R1 + OCR)
    printf_uart("%s", "CMD58: 00000000 ");
   188d0:	0001e7b7          	lui	a5,0x1e
   188d4:	ea878593          	addi	a1,a5,-344 # 1dea8 <FCVT_WU_D_TESTS+0x870>
   188d8:	0001e7b7          	lui	a5,0x1e
   188dc:	e9078513          	addi	a0,a5,-368 # 1de90 <FCVT_WU_D_TESTS+0x858>
   188e0:	ffffa097          	auipc	ra,0xffffa
   188e4:	070080e7          	jalr	112(ra) # 12950 <printf_uart>
    spi_send_cmd(p, CMD58, 0);
   188e8:	00000613          	li	a2,0
   188ec:	03a00593          	li	a1,58
   188f0:	fc843503          	ld	a0,-56(s0)
   188f4:	00000097          	auipc	ra,0x0
   188f8:	964080e7          	jalr	-1692(ra) # 18258 <spi_send_cmd>

    // R3 is 40-bits split on [R1 (8-bits),R3 (32-bits)]
    R1 = get_r1_response(p);
   188fc:	fc843503          	ld	a0,-56(s0)
   18900:	d29ff0ef          	jal	ra,18628 <get_r1_response>
   18904:	00050793          	mv	a5,a0
   18908:	fcf40fa3          	sb	a5,-33(s0)
    OCR = get_ui32(p);
   1890c:	fc843503          	ld	a0,-56(s0)
   18910:	00000097          	auipc	ra,0x0
   18914:	d64080e7          	jalr	-668(ra) # 18674 <get_ui32>
   18918:	00050793          	mv	a5,a0
   1891c:	fcf42a23          	sw	a5,-44(s0)
    printf_uart("OCR: %02x %08x\r\n", R1, OCR);
   18920:	fdf44783          	lbu	a5,-33(s0)
   18924:	0007879b          	sext.w	a5,a5
   18928:	fd442703          	lw	a4,-44(s0)
   1892c:	00070613          	mv	a2,a4
   18930:	00078593          	mv	a1,a5
   18934:	0001e7b7          	lui	a5,0x1e
   18938:	ec078513          	addi	a0,a5,-320 # 1dec0 <FCVT_WU_D_TESTS+0x888>
   1893c:	ffffa097          	auipc	ra,0xffffa
   18940:	014080e7          	jalr	20(ra) # 12950 <printf_uart>
    if (R1 != 0x01) {
   18944:	fdf44783          	lbu	a5,-33(s0)
   18948:	0ff7f713          	andi	a4,a5,255
   1894c:	00100793          	li	a5,1
   18950:	00f70c63          	beq	a4,a5,18968 <spi_sd_card_init+0x234>
        p->etype = SD_Unknown;
   18954:	fc843783          	ld	a5,-56(s0)
   18958:	0007a423          	sw	zero,8(a5)
        return p->etype;
   1895c:	fc843783          	ld	a5,-56(s0)
   18960:	0087a783          	lw	a5,8(a5)
   18964:	3340006f          	j	18c98 <spi_sd_card_init+0x564>
    // [31] - reserved
    // [20] - HCS High Capacity Support (OCR)
    // [29:24] - reserved
    // [23:0] -Vdd Voltage Windows
    // Argument: none; Response R1
    watchdog = 0;
   18968:	fe042423          	sw	zero,-24(s0)
    do {
        HCS = OCR & 0xFFFFF;  // [23:0] VDD Voltage window
   1896c:	fd442703          	lw	a4,-44(s0)
   18970:	001007b7          	lui	a5,0x100
   18974:	fff78793          	addi	a5,a5,-1 # fffff <_end+0xe0763>
   18978:	00f777b3          	and	a5,a4,a5
   1897c:	fef42623          	sw	a5,-20(s0)
        if (p->etype == SD_Ver2x_StandardCapacity) {
   18980:	fc843783          	ld	a5,-56(s0)
   18984:	0087a783          	lw	a5,8(a5)
   18988:	00078713          	mv	a4,a5
   1898c:	00200793          	li	a5,2
   18990:	06f71663          	bne	a4,a5,189fc <spi_sd_card_init+0x2c8>
            printf_uart("%s", "CMD55: 00000000 ");
   18994:	0001e7b7          	lui	a5,0x1e
   18998:	ed878593          	addi	a1,a5,-296 # 1ded8 <FCVT_WU_D_TESTS+0x8a0>
   1899c:	0001e7b7          	lui	a5,0x1e
   189a0:	e9078513          	addi	a0,a5,-368 # 1de90 <FCVT_WU_D_TESTS+0x858>
   189a4:	ffffa097          	auipc	ra,0xffffa
   189a8:	fac080e7          	jalr	-84(ra) # 12950 <printf_uart>
            spi_send_cmd(p, CMD55, 0);
   189ac:	00000613          	li	a2,0
   189b0:	03700593          	li	a1,55
   189b4:	fc843503          	ld	a0,-56(s0)
   189b8:	00000097          	auipc	ra,0x0
   189bc:	8a0080e7          	jalr	-1888(ra) # 18258 <spi_send_cmd>
            R1 = get_r1_response(p);
   189c0:	fc843503          	ld	a0,-56(s0)
   189c4:	c65ff0ef          	jal	ra,18628 <get_r1_response>
   189c8:	00050793          	mv	a5,a0
   189cc:	fcf40fa3          	sb	a5,-33(s0)
            printf_uart("R1: %02x\r\n", R1);
   189d0:	fdf44783          	lbu	a5,-33(s0)
   189d4:	0007879b          	sext.w	a5,a5
   189d8:	00078593          	mv	a1,a5
   189dc:	0001e7b7          	lui	a5,0x1e
   189e0:	e7078513          	addi	a0,a5,-400 # 1de70 <FCVT_WU_D_TESTS+0x838>
   189e4:	ffffa097          	auipc	ra,0xffffa
   189e8:	f6c080e7          	jalr	-148(ra) # 12950 <printf_uart>
            HCS |= (1 << 30);
   189ec:	fec42703          	lw	a4,-20(s0)
   189f0:	400007b7          	lui	a5,0x40000
   189f4:	00f767b3          	or	a5,a4,a5
   189f8:	fef42623          	sw	a5,-20(s0)
        }

        printf_uart("ACMD41: %08x ", HCS);
   189fc:	fec42783          	lw	a5,-20(s0)
   18a00:	00078593          	mv	a1,a5
   18a04:	0001e7b7          	lui	a5,0x1e
   18a08:	ef078513          	addi	a0,a5,-272 # 1def0 <FCVT_WU_D_TESTS+0x8b8>
   18a0c:	ffffa097          	auipc	ra,0xffffa
   18a10:	f44080e7          	jalr	-188(ra) # 12950 <printf_uart>
        spi_send_cmd(p, ACMD41, HCS);  // Support High Capacity cards
   18a14:	fec42783          	lw	a5,-20(s0)
   18a18:	00078613          	mv	a2,a5
   18a1c:	02900593          	li	a1,41
   18a20:	fc843503          	ld	a0,-56(s0)
   18a24:	00000097          	auipc	ra,0x0
   18a28:	834080e7          	jalr	-1996(ra) # 18258 <spi_send_cmd>
        R1 = get_r1_response(p);
   18a2c:	fc843503          	ld	a0,-56(s0)
   18a30:	bf9ff0ef          	jal	ra,18628 <get_r1_response>
   18a34:	00050793          	mv	a5,a0
   18a38:	fcf40fa3          	sb	a5,-33(s0)
        R3 = get_ui32(p);
   18a3c:	fc843503          	ld	a0,-56(s0)
   18a40:	00000097          	auipc	ra,0x0
   18a44:	c34080e7          	jalr	-972(ra) # 18674 <get_ui32>
   18a48:	00050793          	mv	a5,a0
   18a4c:	fcf42823          	sw	a5,-48(s0)
        printf_uart("R3: %02x %08x\r\n", R1, R3);
   18a50:	fdf44783          	lbu	a5,-33(s0)
   18a54:	0007879b          	sext.w	a5,a5
   18a58:	fd042703          	lw	a4,-48(s0)
   18a5c:	00070613          	mv	a2,a4
   18a60:	00078593          	mv	a1,a5
   18a64:	0001e7b7          	lui	a5,0x1e
   18a68:	f0078513          	addi	a0,a5,-256 # 1df00 <FCVT_WU_D_TESTS+0x8c8>
   18a6c:	ffffa097          	auipc	ra,0xffffa
   18a70:	ee4080e7          	jalr	-284(ra) # 12950 <printf_uart>
        if (R1 & R1_ILLEGAL_BIT) {
   18a74:	fdf44783          	lbu	a5,-33(s0)
   18a78:	0007879b          	sext.w	a5,a5
   18a7c:	0047f793          	andi	a5,a5,4
   18a80:	0007879b          	sext.w	a5,a5
   18a84:	04079463          	bnez	a5,18acc <spi_sd_card_init+0x398>
           break;
        }
        if (R1 == 0x01) {
   18a88:	fdf44783          	lbu	a5,-33(s0)
   18a8c:	0ff7f713          	andi	a4,a5,255
   18a90:	00100793          	li	a5,1
   18a94:	00f71463          	bne	a4,a5,18a9c <spi_sd_card_init+0x368>
            // initialization in progress, no error just wait:
            watchdog = 0;
   18a98:	fe042423          	sw	zero,-24(s0)
        // The 'in idle state' bit in the R1 response of ACMD41 is used by the card 
        // to inform the host if initialization of ACMD41 is completed.
        //     Setting this bit to 1 indicates that the card is still initializing.
        //     Setting this bit to 0 indicates completion of initialization.
        // The host repeatedly issues ACMD41 until this bit is set to 0
    } while (((R1 & R1_IDLE_BIT) != 0) && watchdog++ < 2);
   18a9c:	fdf44783          	lbu	a5,-33(s0)
   18aa0:	0007879b          	sext.w	a5,a5
   18aa4:	0017f793          	andi	a5,a5,1
   18aa8:	0007879b          	sext.w	a5,a5
   18aac:	02078263          	beqz	a5,18ad0 <spi_sd_card_init+0x39c>
   18ab0:	fe842783          	lw	a5,-24(s0)
   18ab4:	0017871b          	addiw	a4,a5,1
   18ab8:	fee42423          	sw	a4,-24(s0)
   18abc:	00078713          	mv	a4,a5
   18ac0:	00100793          	li	a5,1
   18ac4:	eae7d4e3          	ble	a4,a5,1896c <spi_sd_card_init+0x238>
   18ac8:	0080006f          	j	18ad0 <spi_sd_card_init+0x39c>
           break;
   18acc:	00000013          	nop


    if (R1 & R1_ILLEGAL_BIT) {
   18ad0:	fdf44783          	lbu	a5,-33(s0)
   18ad4:	0007879b          	sext.w	a5,a5
   18ad8:	0047f793          	andi	a5,a5,4
   18adc:	0007879b          	sext.w	a5,a5
   18ae0:	0a078263          	beqz	a5,18b84 <spi_sd_card_init+0x450>
        // ACMD41 is unsupported, use CMD1
        watchdog = 0;
   18ae4:	fe042423          	sw	zero,-24(s0)
        do {
            printf_uart("CMD1: %08x ", HCS);
   18ae8:	fec42783          	lw	a5,-20(s0)
   18aec:	00078593          	mv	a1,a5
   18af0:	0001e7b7          	lui	a5,0x1e
   18af4:	f1078513          	addi	a0,a5,-240 # 1df10 <FCVT_WU_D_TESTS+0x8d8>
   18af8:	ffffa097          	auipc	ra,0xffffa
   18afc:	e58080e7          	jalr	-424(ra) # 12950 <printf_uart>
            spi_send_cmd(p, CMD1, HCS);  // Support High Capacity cards
   18b00:	fec42783          	lw	a5,-20(s0)
   18b04:	00078613          	mv	a2,a5
   18b08:	00100593          	li	a1,1
   18b0c:	fc843503          	ld	a0,-56(s0)
   18b10:	fffff097          	auipc	ra,0xfffff
   18b14:	748080e7          	jalr	1864(ra) # 18258 <spi_send_cmd>
            R1 = get_r1_response(p);
   18b18:	fc843503          	ld	a0,-56(s0)
   18b1c:	b0dff0ef          	jal	ra,18628 <get_r1_response>
   18b20:	00050793          	mv	a5,a0
   18b24:	fcf40fa3          	sb	a5,-33(s0)
            printf_uart("R1: %02x\r\n", R1);
   18b28:	fdf44783          	lbu	a5,-33(s0)
   18b2c:	0007879b          	sext.w	a5,a5
   18b30:	00078593          	mv	a1,a5
   18b34:	0001e7b7          	lui	a5,0x1e
   18b38:	e7078513          	addi	a0,a5,-400 # 1de70 <FCVT_WU_D_TESTS+0x838>
   18b3c:	ffffa097          	auipc	ra,0xffffa
   18b40:	e14080e7          	jalr	-492(ra) # 12950 <printf_uart>
            if (R1 == 0x01) {
   18b44:	fdf44783          	lbu	a5,-33(s0)
   18b48:	0ff7f713          	andi	a4,a5,255
   18b4c:	00100793          	li	a5,1
   18b50:	00f71463          	bne	a4,a5,18b58 <spi_sd_card_init+0x424>
                // initialization in progress, no error just wait:
                watchdog = 0;
   18b54:	fe042423          	sw	zero,-24(s0)
            }
        } while (((R1 & 0x1) != 0) && watchdog++ < 2);
   18b58:	fdf44783          	lbu	a5,-33(s0)
   18b5c:	0007879b          	sext.w	a5,a5
   18b60:	0017f793          	andi	a5,a5,1
   18b64:	0007879b          	sext.w	a5,a5
   18b68:	00078e63          	beqz	a5,18b84 <spi_sd_card_init+0x450>
   18b6c:	fe842783          	lw	a5,-24(s0)
   18b70:	0017871b          	addiw	a4,a5,1
   18b74:	fee42423          	sw	a4,-24(s0)
   18b78:	00078713          	mv	a4,a5
   18b7c:	00100793          	li	a5,1
   18b80:	f6e7d4e3          	ble	a4,a5,18ae8 <spi_sd_card_init+0x3b4>
    }
 
    // SD-card in Ready State: idle = 0
    if (p->etype == SD_Unknown || p->etype == SD_Ver1x) {
   18b84:	fc843783          	ld	a5,-56(s0)
   18b88:	0087a783          	lw	a5,8(a5)
   18b8c:	00078c63          	beqz	a5,18ba4 <spi_sd_card_init+0x470>
   18b90:	fc843783          	ld	a5,-56(s0)
   18b94:	0087a783          	lw	a5,8(a5)
   18b98:	00078713          	mv	a4,a5
   18b9c:	00100793          	li	a5,1
   18ba0:	00f71863          	bne	a4,a5,18bb0 <spi_sd_card_init+0x47c>
        return p->etype;
   18ba4:	fc843783          	ld	a5,-56(s0)
   18ba8:	0087a783          	lw	a5,8(a5)
   18bac:	0ec0006f          	j	18c98 <spi_sd_card_init+0x564>
    }


    if (p->etype == SD_Ver2x_StandardCapacity) {
   18bb0:	fc843783          	ld	a5,-56(s0)
   18bb4:	0087a783          	lw	a5,8(a5)
   18bb8:	00078713          	mv	a4,a5
   18bbc:	00200793          	li	a5,2
   18bc0:	0cf71863          	bne	a4,a5,18c90 <spi_sd_card_init+0x55c>
        // CMD58 (get CCS). Card capacity information (Standard or Extended)
        // Not mandatory to send CMD58. Though it is recommended to be done in order
        // to get the supported voltage range of the card
        // Argument: none; Response R3 (5 bytes R1 + OCR)
        printf_uart("%s", "CMD58: 00000000 ");
   18bc4:	0001e7b7          	lui	a5,0x1e
   18bc8:	ea878593          	addi	a1,a5,-344 # 1dea8 <FCVT_WU_D_TESTS+0x870>
   18bcc:	0001e7b7          	lui	a5,0x1e
   18bd0:	e9078513          	addi	a0,a5,-368 # 1de90 <FCVT_WU_D_TESTS+0x858>
   18bd4:	ffffa097          	auipc	ra,0xffffa
   18bd8:	d7c080e7          	jalr	-644(ra) # 12950 <printf_uart>
        spi_send_cmd(p, CMD58, 0);
   18bdc:	00000613          	li	a2,0
   18be0:	03a00593          	li	a1,58
   18be4:	fc843503          	ld	a0,-56(s0)
   18be8:	fffff097          	auipc	ra,0xfffff
   18bec:	670080e7          	jalr	1648(ra) # 18258 <spi_send_cmd>

        R1 = get_r1_response(p);
   18bf0:	fc843503          	ld	a0,-56(s0)
   18bf4:	a35ff0ef          	jal	ra,18628 <get_r1_response>
   18bf8:	00050793          	mv	a5,a0
   18bfc:	fcf40fa3          	sb	a5,-33(s0)
        R3 = get_ui32(p);
   18c00:	fc843503          	ld	a0,-56(s0)
   18c04:	00000097          	auipc	ra,0x0
   18c08:	a70080e7          	jalr	-1424(ra) # 18674 <get_ui32>
   18c0c:	00050793          	mv	a5,a0
   18c10:	fcf42823          	sw	a5,-48(s0)
        HCS = (R3 >> 30) & 0x1;
   18c14:	fd042783          	lw	a5,-48(s0)
   18c18:	01e7d79b          	srliw	a5,a5,0x1e
   18c1c:	0007879b          	sext.w	a5,a5
   18c20:	0017f793          	andi	a5,a5,1
   18c24:	fef42623          	sw	a5,-20(s0)
        printf_uart("R3: %02x %04x HCS=%d\r\n", R1, R3, HCS);
   18c28:	fdf44783          	lbu	a5,-33(s0)
   18c2c:	0007879b          	sext.w	a5,a5
   18c30:	fec42683          	lw	a3,-20(s0)
   18c34:	fd042703          	lw	a4,-48(s0)
   18c38:	00070613          	mv	a2,a4
   18c3c:	00078593          	mv	a1,a5
   18c40:	0001e7b7          	lui	a5,0x1e
   18c44:	f2078513          	addi	a0,a5,-224 # 1df20 <FCVT_WU_D_TESTS+0x8e8>
   18c48:	ffffa097          	auipc	ra,0xffffa
   18c4c:	d08080e7          	jalr	-760(ra) # 12950 <printf_uart>

        // R1=0: Ready State without errors:
        if (R1 != 0x00) {
   18c50:	fdf44783          	lbu	a5,-33(s0)
   18c54:	0ff7f793          	andi	a5,a5,255
   18c58:	00078863          	beqz	a5,18c68 <spi_sd_card_init+0x534>
            p->etype = SD_Unknown;
   18c5c:	fc843783          	ld	a5,-56(s0)
   18c60:	0007a423          	sw	zero,8(a5)
   18c64:	02c0006f          	j	18c90 <spi_sd_card_init+0x55c>
        } else if (HCS) {
   18c68:	fec42783          	lw	a5,-20(s0)
   18c6c:	0007879b          	sext.w	a5,a5
   18c70:	00078a63          	beqz	a5,18c84 <spi_sd_card_init+0x550>
            p->etype = SD_Ver2x_HighCapacity;
   18c74:	fc843783          	ld	a5,-56(s0)
   18c78:	00300713          	li	a4,3
   18c7c:	00e7a423          	sw	a4,8(a5)
   18c80:	0100006f          	j	18c90 <spi_sd_card_init+0x55c>
        } else {
            p->etype = SD_Ver2x_StandardCapacity;
   18c84:	fc843783          	ld	a5,-56(s0)
   18c88:	00200713          	li	a4,2
   18c8c:	00e7a423          	sw	a4,8(a5)
        }
    }

    return p->etype;
   18c90:	fc843783          	ld	a5,-56(s0)
   18c94:	0087a783          	lw	a5,8(a5)
}
   18c98:	00078513          	mv	a0,a5
   18c9c:	03813083          	ld	ra,56(sp)
   18ca0:	03013403          	ld	s0,48(sp)
   18ca4:	04010113          	addi	sp,sp,64
   18ca8:	00008067          	ret

0000000000018cac <spi_sd_read_block>:

int spi_sd_read_block(SpiDriverDataType *p) {
   18cac:	fd010113          	addi	sp,sp,-48
   18cb0:	02113423          	sd	ra,40(sp)
   18cb4:	02813023          	sd	s0,32(sp)
   18cb8:	03010413          	addi	s0,sp,48
   18cbc:	fca43c23          	sd	a0,-40(s0)
   // Check Data token:
    uint8_t data_prefix = 0;
   18cc0:	fe0407a3          	sb	zero,-17(s0)

    data_prefix = spi_recv_sync_data_block(p);
   18cc4:	fd843503          	ld	a0,-40(s0)
   18cc8:	00000097          	auipc	ra,0x0
   18ccc:	804080e7          	jalr	-2044(ra) # 184cc <spi_recv_sync_data_block>
   18cd0:	00050793          	mv	a5,a0
   18cd4:	0007879b          	sext.w	a5,a5
   18cd8:	fef407a3          	sb	a5,-17(s0)
#ifdef DEBUG_DATA_BLOCK
    printf_uart("StartToken: %02x ", data_prefix);
#endif
    if (data_prefix != DATA_START_BLOCK) {
   18cdc:	fef44783          	lbu	a5,-17(s0)
   18ce0:	0ff7f713          	andi	a4,a5,255
   18ce4:	0fe00793          	li	a5,254
   18ce8:	02f70463          	beq	a4,a5,18d10 <spi_sd_read_block+0x64>
        printf_uart("wrong prefix: %02x != %02x\r\n",
   18cec:	fef44783          	lbu	a5,-17(s0)
   18cf0:	0007879b          	sext.w	a5,a5
   18cf4:	0fe00613          	li	a2,254
   18cf8:	00078593          	mv	a1,a5
   18cfc:	0001e7b7          	lui	a5,0x1e
   18d00:	f3878513          	addi	a0,a5,-200 # 1df38 <FCVT_WU_D_TESTS+0x900>
   18d04:	c4df90ef          	jal	ra,12950 <printf_uart>
                    data_prefix, DATA_START_BLOCK);
        return 0;
   18d08:	00000793          	li	a5,0
   18d0c:	0580006f          	j	18d64 <spi_sd_read_block+0xb8>
    }
#ifdef DEBUG_DATA_BLOCK
    printf_uart("%s", "\r\n");
#endif

    spi_init_crc15(p);
   18d10:	fd843503          	ld	a0,-40(s0)
   18d14:	cb8ff0ef          	jal	ra,181cc <spi_init_crc15>
    spi_recv_bytes(p, 512, RX_IS_SYNCED);
   18d18:	00100613          	li	a2,1
   18d1c:	20000593          	li	a1,512
   18d20:	fd843503          	ld	a0,-40(s0)
   18d24:	ed8ff0ef          	jal	ra,183fc <spi_recv_bytes>

    // Expected CRC16:
    p->crc16_calculated = (uint16_t)p->map->crc16;
   18d28:	fd843783          	ld	a5,-40(s0)
   18d2c:	0007b783          	ld	a5,0(a5)
   18d30:	0587a783          	lw	a5,88(a5)
   18d34:	0007879b          	sext.w	a5,a5
   18d38:	03079713          	slli	a4,a5,0x30
   18d3c:	03075713          	srli	a4,a4,0x30
   18d40:	fd843783          	ld	a5,-40(s0)
   18d44:	20e79923          	sh	a4,530(a5)
    // Received CRC16:
    p->crc16_rx = spi_recv_data_block_crc16(p);
   18d48:	fd843503          	ld	a0,-40(s0)
   18d4c:	815ff0ef          	jal	ra,18560 <spi_recv_data_block_crc16>
   18d50:	00050793          	mv	a5,a0
   18d54:	00078713          	mv	a4,a5
   18d58:	fd843783          	ld	a5,-40(s0)
   18d5c:	20e79823          	sh	a4,528(a5)
    return 512;
   18d60:	20000793          	li	a5,512
}
   18d64:	00078513          	mv	a0,a5
   18d68:	02813083          	ld	ra,40(sp)
   18d6c:	02013403          	ld	s0,32(sp)
   18d70:	03010113          	addi	sp,sp,48
   18d74:	00008067          	ret

0000000000018d78 <spi_sd_card_memcpy>:

int spi_sd_card_memcpy(uint64_t src, uint64_t dst, int sz) {
   18d78:	fa010113          	addi	sp,sp,-96
   18d7c:	04113c23          	sd	ra,88(sp)
   18d80:	04813823          	sd	s0,80(sp)
   18d84:	06010413          	addi	s0,sp,96
   18d88:	faa43c23          	sd	a0,-72(s0)
   18d8c:	fab43823          	sd	a1,-80(s0)
   18d90:	00060793          	mv	a5,a2
   18d94:	faf42623          	sw	a5,-84(s0)
    uint32_t sd_addr;
    int block_size = 512;
   18d98:	20000793          	li	a5,512
   18d9c:	fef42223          	sw	a5,-28(s0)
    int rdcnt;
    int bytes_copied = 0;
   18da0:	fe042423          	sw	zero,-24(s0)
    uint8_t R1;
    prci_map *prci = (prci_map *)ADDR_BUS1_APB_PRCI;
   18da4:	100127b7          	lui	a5,0x10012
   18da8:	fcf43c23          	sd	a5,-40(s0)
    SpiDriverDataType *p = (SpiDriverDataType *)fw_get_ram_data("spi");
   18dac:	0001e7b7          	lui	a5,0x1e
   18db0:	f5878513          	addi	a0,a5,-168 # 1df58 <FCVT_WU_D_TESTS+0x920>
   18db4:	ffff9097          	auipc	ra,0xffff9
   18db8:	eb4080e7          	jalr	-332(ra) # 11c68 <fw_get_ram_data>
   18dbc:	fca43823          	sd	a0,-48(s0)

    if (p->etype == SD_Ver2x_HighCapacity) {
   18dc0:	fd043783          	ld	a5,-48(s0)
   18dc4:	0087a783          	lw	a5,8(a5)
   18dc8:	00078713          	mv	a4,a5
   18dcc:	00300793          	li	a5,3
   18dd0:	00f71a63          	bne	a4,a5,18de4 <spi_sd_card_memcpy+0x6c>
        sd_addr = (uint32_t)(src >> 9);  // Data block is always 512 bytes
   18dd4:	fb843783          	ld	a5,-72(s0)
   18dd8:	0097d793          	srli	a5,a5,0x9
   18ddc:	fef42623          	sw	a5,-20(s0)
   18de0:	00c0006f          	j	18dec <spi_sd_card_memcpy+0x74>
    } else {
        sd_addr = (uint32_t)src;
   18de4:	fb843783          	ld	a5,-72(s0)
   18de8:	fef42623          	sw	a5,-20(s0)
    }

#ifdef DEBUG_DATA_BLOCK
    printf_uart("CMD18: %08x ", sd_addr);
#endif
    spi_send_cmd(p, CMD18, sd_addr);
   18dec:	fec42783          	lw	a5,-20(s0)
   18df0:	00078613          	mv	a2,a5
   18df4:	01200593          	li	a1,18
   18df8:	fd043503          	ld	a0,-48(s0)
   18dfc:	fffff097          	auipc	ra,0xfffff
   18e00:	45c080e7          	jalr	1116(ra) # 18258 <spi_send_cmd>
    R1 = get_r1_response(p);
   18e04:	fd043503          	ld	a0,-48(s0)
   18e08:	821ff0ef          	jal	ra,18628 <get_r1_response>
   18e0c:	00050793          	mv	a5,a0
   18e10:	fcf407a3          	sb	a5,-49(s0)
#ifdef DEBUG_DATA_BLOCK
    printf_uart("R1: %02x\r\n", R1);
#endif

    // SD-card should be in Transfer State without errors:
    if (R1 != 0x00) {
   18e14:	fcf44783          	lbu	a5,-49(s0)
   18e18:	0ff7f793          	andi	a5,a5,255
   18e1c:	0e078a63          	beqz	a5,18f10 <spi_sd_card_memcpy+0x198>
        printf_uart("CMD18 failed src=0x%llx R1: %02x\r\n", (uint64_t)src, R1);
   18e20:	fcf44783          	lbu	a5,-49(s0)
   18e24:	0007879b          	sext.w	a5,a5
   18e28:	00078613          	mv	a2,a5
   18e2c:	fb843583          	ld	a1,-72(s0)
   18e30:	0001e7b7          	lui	a5,0x1e
   18e34:	f6078513          	addi	a0,a5,-160 # 1df60 <FCVT_WU_D_TESTS+0x928>
   18e38:	ffffa097          	auipc	ra,0xffffa
   18e3c:	b18080e7          	jalr	-1256(ra) # 12950 <printf_uart>
        return 0;
   18e40:	00000793          	li	a5,0
   18e44:	10c0006f          	j	18f50 <spi_sd_card_memcpy+0x1d8>
    }

    while (bytes_copied < sz) {
        if (spi_sd_read_block(p)) {
   18e48:	fd043503          	ld	a0,-48(s0)
   18e4c:	00000097          	auipc	ra,0x0
   18e50:	e60080e7          	jalr	-416(ra) # 18cac <spi_sd_read_block>
   18e54:	00050793          	mv	a5,a0
   18e58:	0a078063          	beqz	a5,18ef8 <spi_sd_card_memcpy+0x180>
            for (int i = 0; i < 8; i++) {
                printf_uart("%02x ", p->rxbuf[i]);
            }
            printf_uart(".. %0x ?= %04x\r\n", p->crc16_rx, p->crc16_calculated);
#endif
            if (p->crc16_rx != p->crc16_calculated) {
   18e5c:	fd043783          	ld	a5,-48(s0)
   18e60:	2107d703          	lhu	a4,528(a5)
   18e64:	fd043783          	ld	a5,-48(s0)
   18e68:	2127d783          	lhu	a5,530(a5)
   18e6c:	0007071b          	sext.w	a4,a4
   18e70:	0007879b          	sext.w	a5,a5
   18e74:	02f70c63          	beq	a4,a5,18eac <spi_sd_card_memcpy+0x134>
                printf_uart("src=0x%llx CRC failed: %04x != %04x\r\n", 
                           (uint64_t)src, p->crc16_rx, p->crc16_calculated);
   18e78:	fd043783          	ld	a5,-48(s0)
   18e7c:	2107d783          	lhu	a5,528(a5)
                printf_uart("src=0x%llx CRC failed: %04x != %04x\r\n", 
   18e80:	0007871b          	sext.w	a4,a5
                           (uint64_t)src, p->crc16_rx, p->crc16_calculated);
   18e84:	fd043783          	ld	a5,-48(s0)
   18e88:	2127d783          	lhu	a5,530(a5)
                printf_uart("src=0x%llx CRC failed: %04x != %04x\r\n", 
   18e8c:	0007879b          	sext.w	a5,a5
   18e90:	00078693          	mv	a3,a5
   18e94:	00070613          	mv	a2,a4
   18e98:	fb843583          	ld	a1,-72(s0)
   18e9c:	0001e7b7          	lui	a5,0x1e
   18ea0:	f8878513          	addi	a0,a5,-120 # 1df88 <FCVT_WU_D_TESTS+0x950>
   18ea4:	ffffa097          	auipc	ra,0xffffa
   18ea8:	aac080e7          	jalr	-1364(ra) # 12950 <printf_uart>
            }

            if ((prci->pll_status & PRCI_PLL_STATUS_DDR_CALIB_DONE) != 0) {
   18eac:	fd843783          	ld	a5,-40(s0)
   18eb0:	0007a783          	lw	a5,0(a5)
   18eb4:	0027f793          	andi	a5,a5,2
   18eb8:	0007879b          	sext.w	a5,a5
   18ebc:	02078063          	beqz	a5,18edc <spi_sd_card_memcpy+0x164>
                memcpy((void *)dst, p->rxbuf, 512);
   18ec0:	fb043703          	ld	a4,-80(s0)
   18ec4:	fd043783          	ld	a5,-48(s0)
   18ec8:	01078793          	addi	a5,a5,16
   18ecc:	20000613          	li	a2,512
   18ed0:	00078593          	mv	a1,a5
   18ed4:	00070513          	mv	a0,a4
   18ed8:	2d6010ef          	jal	ra,1a1ae <memcpy>
            }
            dst += 512;
   18edc:	fb043783          	ld	a5,-80(s0)
   18ee0:	20078793          	addi	a5,a5,512
   18ee4:	faf43823          	sd	a5,-80(s0)
            bytes_copied += 512;
   18ee8:	fe842783          	lw	a5,-24(s0)
   18eec:	2007879b          	addiw	a5,a5,512
   18ef0:	fef42423          	sw	a5,-24(s0)
   18ef4:	01c0006f          	j	18f10 <spi_sd_card_memcpy+0x198>
        } else {
            printf_uart("Data block prefix not found src=0x%llx\r\n", (uint64_t)src);
   18ef8:	fb843583          	ld	a1,-72(s0)
   18efc:	0001e7b7          	lui	a5,0x1e
   18f00:	fb078513          	addi	a0,a5,-80 # 1dfb0 <FCVT_WU_D_TESTS+0x978>
   18f04:	ffffa097          	auipc	ra,0xffffa
   18f08:	a4c080e7          	jalr	-1460(ra) # 12950 <printf_uart>
            break;
   18f0c:	0180006f          	j	18f24 <spi_sd_card_memcpy+0x1ac>
    while (bytes_copied < sz) {
   18f10:	fe842703          	lw	a4,-24(s0)
   18f14:	fac42783          	lw	a5,-84(s0)
   18f18:	0007071b          	sext.w	a4,a4
   18f1c:	0007879b          	sext.w	a5,a5
   18f20:	f2f744e3          	blt	a4,a5,18e48 <spi_sd_card_memcpy+0xd0>

    // Stop Data block
#ifdef DEBUG_DATA_BLOCK
    printf_uart("CMD12: %08x ", sd_addr);
#endif
    spi_send_cmd(p, CMD12, sd_addr);
   18f24:	fec42783          	lw	a5,-20(s0)
   18f28:	00078613          	mv	a2,a5
   18f2c:	00c00593          	li	a1,12
   18f30:	fd043503          	ld	a0,-48(s0)
   18f34:	fffff097          	auipc	ra,0xfffff
   18f38:	324080e7          	jalr	804(ra) # 18258 <spi_send_cmd>
    R1 = get_r1_response(p);
   18f3c:	fd043503          	ld	a0,-48(s0)
   18f40:	ee8ff0ef          	jal	ra,18628 <get_r1_response>
   18f44:	00050793          	mv	a5,a0
   18f48:	fcf407a3          	sb	a5,-49(s0)
#ifdef DEBUG_DATA_BLOCK
    printf_uart("R1: %02x\r\n", R1);
#endif

    return bytes_copied;
   18f4c:	fe842783          	lw	a5,-24(s0)
}
   18f50:	00078513          	mv	a0,a5
   18f54:	05813083          	ld	ra,88(sp)
   18f58:	05013403          	ld	s0,80(sp)
   18f5c:	06010113          	addi	sp,sp,96
   18f60:	00008067          	ret

0000000000018f64 <spi_init>:

ESdCardType spi_init(void) {
   18f64:	fe010113          	addi	sp,sp,-32
   18f68:	00113c23          	sd	ra,24(sp)
   18f6c:	00813823          	sd	s0,16(sp)
   18f70:	02010413          	addi	s0,sp,32
    int watchdog;

    SpiDriverDataType *p = (SpiDriverDataType *)fw_malloc(sizeof(SpiDriverDataType));
   18f74:	21800513          	li	a0,536
   18f78:	bc1f80ef          	jal	ra,11b38 <fw_malloc>
   18f7c:	fea43423          	sd	a0,-24(s0)
    memset(p, 0, sizeof(SpiDriverDataType));
   18f80:	21800613          	li	a2,536
   18f84:	00000593          	li	a1,0
   18f88:	fe843503          	ld	a0,-24(s0)
   18f8c:	2e2010ef          	jal	ra,1a26e <memset>
    p->map = (qspi_map *)ADDR_BUS1_APB_QSPI2;
   18f90:	fe843783          	ld	a5,-24(s0)
   18f94:	10050737          	lui	a4,0x10050
   18f98:	00e7b023          	sd	a4,0(a5)
    p->map->sckdiv = 2;    // half period
   18f9c:	fe843783          	ld	a5,-24(s0)
   18fa0:	0007b783          	ld	a5,0(a5)
   18fa4:	00200713          	li	a4,2
   18fa8:	00e7a023          	sw	a4,0(a5)
    p->map->rsrv1[0] = 4096;    // watchdog to receive start bit
   18fac:	fe843783          	ld	a5,-24(s0)
   18fb0:	0007b783          	ld	a5,0(a5)
   18fb4:	00001737          	lui	a4,0x1
   18fb8:	00e7a423          	sw	a4,8(a5)

    fw_register_ram_data("spi", p);
   18fbc:	fe843583          	ld	a1,-24(s0)
   18fc0:	0001e7b7          	lui	a5,0x1e
   18fc4:	f5878513          	addi	a0,a5,-168 # 1df58 <FCVT_WU_D_TESTS+0x920>
   18fc8:	ffff9097          	auipc	ra,0xffff9
   18fcc:	c10080e7          	jalr	-1008(ra) # 11bd8 <fw_register_ram_data>
   
    return spi_sd_card_init(p);
   18fd0:	fe843503          	ld	a0,-24(s0)
   18fd4:	fffff097          	auipc	ra,0xfffff
   18fd8:	760080e7          	jalr	1888(ra) # 18734 <spi_sd_card_init>
   18fdc:	00050793          	mv	a5,a0
   18fe0:	0007879b          	sext.w	a5,a5
}
   18fe4:	00078513          	mv	a0,a5
   18fe8:	01813083          	ld	ra,24(sp)
   18fec:	01013403          	ld	s0,16(sp)
   18ff0:	02010113          	addi	sp,sp,32
   18ff4:	00008067          	ret
   18ff8:	0000                	unimp
	...

0000000000018ffc <get_dev_bar>:
static uint64_t get_dev_bar(pnp_map *pnp, uint16_t vid, uint16_t did) {
   18ffc:	fb010113          	addi	sp,sp,-80
   19000:	04813423          	sd	s0,72(sp)
   19004:	05010413          	addi	s0,sp,80
   19008:	faa43c23          	sd	a0,-72(s0)
   1900c:	00058793          	mv	a5,a1
   19010:	00060713          	mv	a4,a2
   19014:	faf41b23          	sh	a5,-74(s0)
   19018:	00070793          	mv	a5,a4
   1901c:	faf41a23          	sh	a5,-76(s0)
    int slots_total = (pnp->cfg >> 8) & 0xFF;
   19020:	fb843783          	ld	a5,-72(s0)
   19024:	0087a783          	lw	a5,8(a5)
   19028:	0087d79b          	srliw	a5,a5,0x8
   1902c:	0007879b          	sext.w	a5,a5
   19030:	0007879b          	sext.w	a5,a5
   19034:	0ff7f793          	andi	a5,a5,255
   19038:	fef42223          	sw	a5,-28(s0)
    int off = 0;
   1903c:	fe042623          	sw	zero,-20(s0)
    for (int i = 0; i < slots_total; i++) {
   19040:	fe042423          	sw	zero,-24(s0)
   19044:	09c0006f          	j	190e0 <get_dev_bar+0xe4>
        dcfg = *(dev_cfg_type *)&pnp->cfg_table[off];
   19048:	fec42783          	lw	a5,-20(s0)
   1904c:	04078793          	addi	a5,a5,64
   19050:	fb843703          	ld	a4,-72(s0)
   19054:	00f707b3          	add	a5,a4,a5
   19058:	0007b703          	ld	a4,0(a5)
   1905c:	fce43023          	sd	a4,-64(s0)
   19060:	0087b703          	ld	a4,8(a5)
   19064:	fce43423          	sd	a4,-56(s0)
   19068:	0107b703          	ld	a4,16(a5)
   1906c:	fce43823          	sd	a4,-48(s0)
   19070:	0187b783          	ld	a5,24(a5)
   19074:	fcf43c23          	sd	a5,-40(s0)
        off += sizeof(dcfg);
   19078:	fec42783          	lw	a5,-20(s0)
   1907c:	0207879b          	addiw	a5,a5,32
   19080:	0007879b          	sext.w	a5,a5
   19084:	fef42623          	sw	a5,-20(s0)
        if (dcfg.u.descrtype != PNP_CFG_TYPE_SLAVE) {
   19088:	fc144783          	lbu	a5,-63(s0)
   1908c:	0037f793          	andi	a5,a5,3
   19090:	0ff7f793          	andi	a5,a5,255
   19094:	00078713          	mv	a4,a5
   19098:	00200793          	li	a5,2
   1909c:	02f71a63          	bne	a4,a5,190d0 <get_dev_bar+0xd4>
        if (dcfg.u.vid == vid && dcfg.u.did == did) {
   190a0:	fc645783          	lhu	a5,-58(s0)
   190a4:	fb645703          	lhu	a4,-74(s0)
   190a8:	0007071b          	sext.w	a4,a4
   190ac:	0007879b          	sext.w	a5,a5
   190b0:	02f71263          	bne	a4,a5,190d4 <get_dev_bar+0xd8>
   190b4:	fc445783          	lhu	a5,-60(s0)
   190b8:	fb445703          	lhu	a4,-76(s0)
   190bc:	0007071b          	sext.w	a4,a4
   190c0:	0007879b          	sext.w	a5,a5
   190c4:	00f71863          	bne	a4,a5,190d4 <get_dev_bar+0xd8>
            return dcfg.u.addr_start;
   190c8:	fd043783          	ld	a5,-48(s0)
   190cc:	02c0006f          	j	190f8 <get_dev_bar+0xfc>
            continue;
   190d0:	00000013          	nop
    for (int i = 0; i < slots_total; i++) {
   190d4:	fe842783          	lw	a5,-24(s0)
   190d8:	0017879b          	addiw	a5,a5,1
   190dc:	fef42423          	sw	a5,-24(s0)
   190e0:	fe842703          	lw	a4,-24(s0)
   190e4:	fe442783          	lw	a5,-28(s0)
   190e8:	0007071b          	sext.w	a4,a4
   190ec:	0007879b          	sext.w	a5,a5
   190f0:	f4f74ce3          	blt	a4,a5,19048 <get_dev_bar+0x4c>
    return DEV_NONE;
   190f4:	fff00793          	li	a5,-1
}
   190f8:	00078513          	mv	a0,a5
   190fc:	04813403          	ld	s0,72(sp)
   19100:	05010113          	addi	sp,sp,80
   19104:	00008067          	ret

0000000000019108 <mpu_region_total>:
static int mpu_region_total() {
   19108:	fe010113          	addi	sp,sp,-32
   1910c:	00813c23          	sd	s0,24(sp)
   19110:	02010413          	addi	s0,sp,32
    uint64_t val = 0;
   19114:	fe043423          	sd	zero,-24(s0)
    asm("csrr %0, 0xBC4" : "=r" (val));
   19118:	bc4027f3          	csrr	a5,0xbc4
   1911c:	fef43423          	sd	a5,-24(s0)
    return (int)(val >> 8);
   19120:	fe843783          	ld	a5,-24(s0)
   19124:	0087d793          	srli	a5,a5,0x8
   19128:	0007879b          	sext.w	a5,a5
}
   1912c:	00078513          	mv	a0,a5
   19130:	01813403          	ld	s0,24(sp)
   19134:	02010113          	addi	sp,sp,32
   19138:	00008067          	ret

000000000001913c <mpu_disable_region>:
static void mpu_disable_region(int idx) {
   1913c:	fd010113          	addi	sp,sp,-48
   19140:	02813423          	sd	s0,40(sp)
   19144:	03010413          	addi	s0,sp,48
   19148:	00050793          	mv	a5,a0
   1914c:	fcf42e23          	sw	a5,-36(s0)
    ctrl.value = 0;
   19150:	fe043423          	sd	zero,-24(s0)
    ctrl.bits.IDX = idx;
   19154:	fdc42783          	lw	a5,-36(s0)
   19158:	0ff7f793          	andi	a5,a5,255
   1915c:	fef404a3          	sb	a5,-23(s0)
    ctrl.bits.WE = 1;
   19160:	fe844783          	lbu	a5,-24(s0)
   19164:	f807e793          	ori	a5,a5,-128
   19168:	fef40423          	sb	a5,-24(s0)
    asm("csrw 0xBC4, %0" : :"r"(ctrl.value));
   1916c:	fe843783          	ld	a5,-24(s0)
   19170:	bc479073          	csrw	0xbc4,a5
}
   19174:	00000013          	nop
   19178:	02813403          	ld	s0,40(sp)
   1917c:	03010113          	addi	sp,sp,48
   19180:	00008067          	ret

0000000000019184 <mpu_enable_region>:
                       const char *rwx) {
   19184:	fb010113          	addi	sp,sp,-80
   19188:	04813423          	sd	s0,72(sp)
   1918c:	05010413          	addi	s0,sp,80
   19190:	00050793          	mv	a5,a0
   19194:	fcb43023          	sd	a1,-64(s0)
   19198:	fac43c23          	sd	a2,-72(s0)
   1919c:	fae43823          	sd	a4,-80(s0)
   191a0:	fcf42623          	sw	a5,-52(s0)
   191a4:	00068793          	mv	a5,a3
   191a8:	fcf42423          	sw	a5,-56(s0)
    uint64_t mask = (~0ull) << 10;
   191ac:	c0000793          	li	a5,-1024
   191b0:	fef43423          	sd	a5,-24(s0)
    const char *p = rwx;
   191b4:	fb043783          	ld	a5,-80(s0)
   191b8:	fef43023          	sd	a5,-32(s0)
    asm("csrw 0xBC2, %0" : :"r"(bar));
   191bc:	fc043783          	ld	a5,-64(s0)
   191c0:	bc279073          	csrw	0xbc2,a5
    KB >>= 1;
   191c4:	fb843783          	ld	a5,-72(s0)
   191c8:	0017d793          	srli	a5,a5,0x1
   191cc:	faf43c23          	sd	a5,-72(s0)
    while (KB) {
   191d0:	01c0006f          	j	191ec <mpu_enable_region+0x68>
        mask <<= 1;
   191d4:	fe843783          	ld	a5,-24(s0)
   191d8:	00179793          	slli	a5,a5,0x1
   191dc:	fef43423          	sd	a5,-24(s0)
        KB >>= 1;
   191e0:	fb843783          	ld	a5,-72(s0)
   191e4:	0017d793          	srli	a5,a5,0x1
   191e8:	faf43c23          	sd	a5,-72(s0)
    while (KB) {
   191ec:	fb843783          	ld	a5,-72(s0)
   191f0:	fe0792e3          	bnez	a5,191d4 <mpu_enable_region+0x50>
    asm("csrw 0xBC3, %0" : :"r"(mask));
   191f4:	fe843783          	ld	a5,-24(s0)
   191f8:	bc379073          	csrw	0xbc3,a5
    ctrl.value = 0;
   191fc:	fc043c23          	sd	zero,-40(s0)
    ctrl.bits.IDX = idx;
   19200:	fcc42783          	lw	a5,-52(s0)
   19204:	0ff7f793          	andi	a5,a5,255
   19208:	fcf40ca3          	sb	a5,-39(s0)
    ctrl.bits.ENA = 1;
   1920c:	fd844783          	lbu	a5,-40(s0)
   19210:	0107e793          	ori	a5,a5,16
   19214:	fcf40c23          	sb	a5,-40(s0)
    ctrl.bits.CACHABLE = cached;
   19218:	fc842783          	lw	a5,-56(s0)
   1921c:	0017f793          	andi	a5,a5,1
   19220:	0ff7f793          	andi	a5,a5,255
   19224:	0017f793          	andi	a5,a5,1
   19228:	0037969b          	slliw	a3,a5,0x3
   1922c:	fd844783          	lbu	a5,-40(s0)
   19230:	ff77f793          	andi	a5,a5,-9
   19234:	00078713          	mv	a4,a5
   19238:	00068793          	mv	a5,a3
   1923c:	00f767b3          	or	a5,a4,a5
   19240:	fcf40c23          	sb	a5,-40(s0)
    ctrl.bits.WE = 1; // write into MPU
   19244:	fd844783          	lbu	a5,-40(s0)
   19248:	f807e793          	ori	a5,a5,-128
   1924c:	fcf40c23          	sb	a5,-40(s0)
    while (*p) {
   19250:	0700006f          	j	192c0 <mpu_enable_region+0x13c>
        if (*p == 'r') {
   19254:	fe043783          	ld	a5,-32(s0)
   19258:	0007c783          	lbu	a5,0(a5)
   1925c:	00078713          	mv	a4,a5
   19260:	07200793          	li	a5,114
   19264:	00f71863          	bne	a4,a5,19274 <mpu_enable_region+0xf0>
            ctrl.bits.RD = 1;
   19268:	fd844783          	lbu	a5,-40(s0)
   1926c:	0027e793          	ori	a5,a5,2
   19270:	fcf40c23          	sb	a5,-40(s0)
        if (*p == 'w') {
   19274:	fe043783          	ld	a5,-32(s0)
   19278:	0007c783          	lbu	a5,0(a5)
   1927c:	00078713          	mv	a4,a5
   19280:	07700793          	li	a5,119
   19284:	00f71863          	bne	a4,a5,19294 <mpu_enable_region+0x110>
            ctrl.bits.WR = 1;
   19288:	fd844783          	lbu	a5,-40(s0)
   1928c:	0017e793          	ori	a5,a5,1
   19290:	fcf40c23          	sb	a5,-40(s0)
        if (*p == 'x') {
   19294:	fe043783          	ld	a5,-32(s0)
   19298:	0007c783          	lbu	a5,0(a5)
   1929c:	00078713          	mv	a4,a5
   192a0:	07800793          	li	a5,120
   192a4:	00f71863          	bne	a4,a5,192b4 <mpu_enable_region+0x130>
            ctrl.bits.EXEC = 1;
   192a8:	fd844783          	lbu	a5,-40(s0)
   192ac:	0047e793          	ori	a5,a5,4
   192b0:	fcf40c23          	sb	a5,-40(s0)
        p++;
   192b4:	fe043783          	ld	a5,-32(s0)
   192b8:	00178793          	addi	a5,a5,1
   192bc:	fef43023          	sd	a5,-32(s0)
    while (*p) {
   192c0:	fe043783          	ld	a5,-32(s0)
   192c4:	0007c783          	lbu	a5,0(a5)
   192c8:	f80796e3          	bnez	a5,19254 <mpu_enable_region+0xd0>
    asm("csrw 0xBC4, %0" : :"r"(ctrl.value));
   192cc:	fd843783          	ld	a5,-40(s0)
   192d0:	bc479073          	csrw	0xbc4,a5
}
   192d4:	00000013          	nop
   192d8:	04813403          	ld	s0,72(sp)
   192dc:	05010113          	addi	sp,sp,80
   192e0:	00008067          	ret

00000000000192e4 <hwthread1>:
#include "axi_maps.h"
#include "encoding.h"
#include "fw_api.h"


int hwthread1() {
   192e4:	fc010113          	addi	sp,sp,-64
   192e8:	02113c23          	sd	ra,56(sp)
   192ec:	02813823          	sd	s0,48(sp)
   192f0:	04010413          	addi	s0,sp,64
    pnp_map *pnp = (pnp_map *)ADDR_BUS0_XSLV_PNP;
   192f4:	100ff7b7          	lui	a5,0x100ff
   192f8:	fef43423          	sd	a5,-24(s0)
    clint_map *clint = (clint_map *)ADDR_BUS0_XSLV_CLINT;
   192fc:	020007b7          	lui	a5,0x2000
   19300:	fef43023          	sd	a5,-32(s0)
    uint32_t *tdata;
    uint32_t mod40;
    uint64_t msie = 0x1ull << 3;
   19304:	00800793          	li	a5,8
   19308:	fcf43c23          	sd	a5,-40(s0)

    clint->msip[fw_get_cpuid()] = 0;          // clear SW pending bit in CLINT
   1930c:	a09f90ef          	jal	ra,12d14 <fw_get_cpuid>
   19310:	00050793          	mv	a5,a0
   19314:	fe043703          	ld	a4,-32(s0)
   19318:	00279793          	slli	a5,a5,0x2
   1931c:	00f707b3          	add	a5,a4,a5
   19320:	0007a023          	sw	zero,0(a5) # 2000000 <_end+0x1fe0764>
    fw_mie_enable(HART_IRQ_MSIP);
   19324:	00300513          	li	a0,3
   19328:	a8df90ef          	jal	ra,12db4 <fw_mie_enable>
    fw_enable_m_interrupts();
   1932c:	a31f90ef          	jal	ra,12d5c <fw_enable_m_interrupts>
    // because it is always stored in L1-cache in each processor.
    //
    // Print 'passed' only on second cycle. First cycle is the test itself.
    while (1) {

        asm("wfi");
   19330:	10500073          	wfi

        tdata = (uint32_t *)pnp->fwdbg1;    // thread0 should initialize SRAM location of the variable
   19334:	fe843783          	ld	a5,-24(s0)
   19338:	0287b783          	ld	a5,40(a5)
   1933c:	fcf43823          	sd	a5,-48(s0)

        while (*tdata < 75) {
   19340:	0680006f          	j	193a8 <hwthread1+0xc4>
            mod40 = (*tdata) % 40;
   19344:	fd043783          	ld	a5,-48(s0)
   19348:	0007a783          	lw	a5,0(a5)
   1934c:	00078713          	mv	a4,a5
   19350:	02800793          	li	a5,40
   19354:	02f777bb          	remuw	a5,a4,a5
   19358:	fcf42623          	sw	a5,-52(s0)
            if (mod40 >= 10 && mod40 < 20) {
   1935c:	fcc42783          	lw	a5,-52(s0)
   19360:	0007871b          	sext.w	a4,a5
   19364:	00900793          	li	a5,9
   19368:	04e7f063          	bleu	a4,a5,193a8 <hwthread1+0xc4>
   1936c:	fcc42783          	lw	a5,-52(s0)
   19370:	0007871b          	sext.w	a4,a5
   19374:	01300793          	li	a5,19
   19378:	02e7e863          	bltu	a5,a4,193a8 <hwthread1+0xc4>
                pnp->fwdbg2 = fw_get_cpuid();  // to debug in RTL and see CPU index
   1937c:	999f90ef          	jal	ra,12d14 <fw_get_cpuid>
   19380:	00050793          	mv	a5,a0
   19384:	00078713          	mv	a4,a5
   19388:	fe843783          	ld	a5,-24(s0)
   1938c:	02e7b823          	sd	a4,48(a5)
                (*tdata)++;
   19390:	fd043783          	ld	a5,-48(s0)
   19394:	0007a783          	lw	a5,0(a5)
   19398:	0017879b          	addiw	a5,a5,1
   1939c:	0007871b          	sext.w	a4,a5
   193a0:	fd043783          	ld	a5,-48(s0)
   193a4:	00e7a023          	sw	a4,0(a5)
        while (*tdata < 75) {
   193a8:	fd043783          	ld	a5,-48(s0)
   193ac:	0007a783          	lw	a5,0(a5)
   193b0:	00078713          	mv	a4,a5
   193b4:	04a00793          	li	a5,74
   193b8:	f8e7f6e3          	bleu	a4,a5,19344 <hwthread1+0x60>
        asm("wfi");
   193bc:	f75ff06f          	j	19330 <hwthread1+0x4c>
   193c0:	0000                	unimp
	...

00000000000193c4 <get_dev_bar>:
static uint64_t get_dev_bar(pnp_map *pnp, uint16_t vid, uint16_t did) {
   193c4:	fb010113          	addi	sp,sp,-80
   193c8:	04813423          	sd	s0,72(sp)
   193cc:	05010413          	addi	s0,sp,80
   193d0:	faa43c23          	sd	a0,-72(s0)
   193d4:	00058793          	mv	a5,a1
   193d8:	00060713          	mv	a4,a2
   193dc:	faf41b23          	sh	a5,-74(s0)
   193e0:	00070793          	mv	a5,a4
   193e4:	faf41a23          	sh	a5,-76(s0)
    int slots_total = (pnp->cfg >> 8) & 0xFF;
   193e8:	fb843783          	ld	a5,-72(s0)
   193ec:	0087a783          	lw	a5,8(a5)
   193f0:	0087d79b          	srliw	a5,a5,0x8
   193f4:	0007879b          	sext.w	a5,a5
   193f8:	0007879b          	sext.w	a5,a5
   193fc:	0ff7f793          	andi	a5,a5,255
   19400:	fef42223          	sw	a5,-28(s0)
    int off = 0;
   19404:	fe042623          	sw	zero,-20(s0)
    for (int i = 0; i < slots_total; i++) {
   19408:	fe042423          	sw	zero,-24(s0)
   1940c:	09c0006f          	j	194a8 <get_dev_bar+0xe4>
        dcfg = *(dev_cfg_type *)&pnp->cfg_table[off];
   19410:	fec42783          	lw	a5,-20(s0)
   19414:	04078793          	addi	a5,a5,64
   19418:	fb843703          	ld	a4,-72(s0)
   1941c:	00f707b3          	add	a5,a4,a5
   19420:	0007b703          	ld	a4,0(a5)
   19424:	fce43023          	sd	a4,-64(s0)
   19428:	0087b703          	ld	a4,8(a5)
   1942c:	fce43423          	sd	a4,-56(s0)
   19430:	0107b703          	ld	a4,16(a5)
   19434:	fce43823          	sd	a4,-48(s0)
   19438:	0187b783          	ld	a5,24(a5)
   1943c:	fcf43c23          	sd	a5,-40(s0)
        off += sizeof(dcfg);
   19440:	fec42783          	lw	a5,-20(s0)
   19444:	0207879b          	addiw	a5,a5,32
   19448:	0007879b          	sext.w	a5,a5
   1944c:	fef42623          	sw	a5,-20(s0)
        if (dcfg.u.descrtype != PNP_CFG_TYPE_SLAVE) {
   19450:	fc144783          	lbu	a5,-63(s0)
   19454:	0037f793          	andi	a5,a5,3
   19458:	0ff7f793          	andi	a5,a5,255
   1945c:	00078713          	mv	a4,a5
   19460:	00200793          	li	a5,2
   19464:	02f71a63          	bne	a4,a5,19498 <get_dev_bar+0xd4>
        if (dcfg.u.vid == vid && dcfg.u.did == did) {
   19468:	fc645783          	lhu	a5,-58(s0)
   1946c:	fb645703          	lhu	a4,-74(s0)
   19470:	0007071b          	sext.w	a4,a4
   19474:	0007879b          	sext.w	a5,a5
   19478:	02f71263          	bne	a4,a5,1949c <get_dev_bar+0xd8>
   1947c:	fc445783          	lhu	a5,-60(s0)
   19480:	fb445703          	lhu	a4,-76(s0)
   19484:	0007071b          	sext.w	a4,a4
   19488:	0007879b          	sext.w	a5,a5
   1948c:	00f71863          	bne	a4,a5,1949c <get_dev_bar+0xd8>
            return dcfg.u.addr_start;
   19490:	fd043783          	ld	a5,-48(s0)
   19494:	02c0006f          	j	194c0 <get_dev_bar+0xfc>
            continue;
   19498:	00000013          	nop
    for (int i = 0; i < slots_total; i++) {
   1949c:	fe842783          	lw	a5,-24(s0)
   194a0:	0017879b          	addiw	a5,a5,1
   194a4:	fef42423          	sw	a5,-24(s0)
   194a8:	fe842703          	lw	a4,-24(s0)
   194ac:	fe442783          	lw	a5,-28(s0)
   194b0:	0007071b          	sext.w	a4,a4
   194b4:	0007879b          	sext.w	a5,a5
   194b8:	f4f74ce3          	blt	a4,a5,19410 <get_dev_bar+0x4c>
    return DEV_NONE;
   194bc:	fff00793          	li	a5,-1
}
   194c0:	00078513          	mv	a0,a5
   194c4:	04813403          	ld	s0,72(sp)
   194c8:	05010113          	addi	sp,sp,80
   194cc:	00008067          	ret

00000000000194d0 <mpu_region_total>:
static int mpu_region_total() {
   194d0:	fe010113          	addi	sp,sp,-32
   194d4:	00813c23          	sd	s0,24(sp)
   194d8:	02010413          	addi	s0,sp,32
    uint64_t val = 0;
   194dc:	fe043423          	sd	zero,-24(s0)
    asm("csrr %0, 0xBC4" : "=r" (val));
   194e0:	bc4027f3          	csrr	a5,0xbc4
   194e4:	fef43423          	sd	a5,-24(s0)
    return (int)(val >> 8);
   194e8:	fe843783          	ld	a5,-24(s0)
   194ec:	0087d793          	srli	a5,a5,0x8
   194f0:	0007879b          	sext.w	a5,a5
}
   194f4:	00078513          	mv	a0,a5
   194f8:	01813403          	ld	s0,24(sp)
   194fc:	02010113          	addi	sp,sp,32
   19500:	00008067          	ret

0000000000019504 <mpu_disable_region>:
static void mpu_disable_region(int idx) {
   19504:	fd010113          	addi	sp,sp,-48
   19508:	02813423          	sd	s0,40(sp)
   1950c:	03010413          	addi	s0,sp,48
   19510:	00050793          	mv	a5,a0
   19514:	fcf42e23          	sw	a5,-36(s0)
    ctrl.value = 0;
   19518:	fe043423          	sd	zero,-24(s0)
    ctrl.bits.IDX = idx;
   1951c:	fdc42783          	lw	a5,-36(s0)
   19520:	0ff7f793          	andi	a5,a5,255
   19524:	fef404a3          	sb	a5,-23(s0)
    ctrl.bits.WE = 1;
   19528:	fe844783          	lbu	a5,-24(s0)
   1952c:	f807e793          	ori	a5,a5,-128
   19530:	fef40423          	sb	a5,-24(s0)
    asm("csrw 0xBC4, %0" : :"r"(ctrl.value));
   19534:	fe843783          	ld	a5,-24(s0)
   19538:	bc479073          	csrw	0xbc4,a5
}
   1953c:	00000013          	nop
   19540:	02813403          	ld	s0,40(sp)
   19544:	03010113          	addi	sp,sp,48
   19548:	00008067          	ret

000000000001954c <mpu_enable_region>:
                       const char *rwx) {
   1954c:	fb010113          	addi	sp,sp,-80
   19550:	04813423          	sd	s0,72(sp)
   19554:	05010413          	addi	s0,sp,80
   19558:	00050793          	mv	a5,a0
   1955c:	fcb43023          	sd	a1,-64(s0)
   19560:	fac43c23          	sd	a2,-72(s0)
   19564:	fae43823          	sd	a4,-80(s0)
   19568:	fcf42623          	sw	a5,-52(s0)
   1956c:	00068793          	mv	a5,a3
   19570:	fcf42423          	sw	a5,-56(s0)
    uint64_t mask = (~0ull) << 10;
   19574:	c0000793          	li	a5,-1024
   19578:	fef43423          	sd	a5,-24(s0)
    const char *p = rwx;
   1957c:	fb043783          	ld	a5,-80(s0)
   19580:	fef43023          	sd	a5,-32(s0)
    asm("csrw 0xBC2, %0" : :"r"(bar));
   19584:	fc043783          	ld	a5,-64(s0)
   19588:	bc279073          	csrw	0xbc2,a5
    KB >>= 1;
   1958c:	fb843783          	ld	a5,-72(s0)
   19590:	0017d793          	srli	a5,a5,0x1
   19594:	faf43c23          	sd	a5,-72(s0)
    while (KB) {
   19598:	01c0006f          	j	195b4 <mpu_enable_region+0x68>
        mask <<= 1;
   1959c:	fe843783          	ld	a5,-24(s0)
   195a0:	00179793          	slli	a5,a5,0x1
   195a4:	fef43423          	sd	a5,-24(s0)
        KB >>= 1;
   195a8:	fb843783          	ld	a5,-72(s0)
   195ac:	0017d793          	srli	a5,a5,0x1
   195b0:	faf43c23          	sd	a5,-72(s0)
    while (KB) {
   195b4:	fb843783          	ld	a5,-72(s0)
   195b8:	fe0792e3          	bnez	a5,1959c <mpu_enable_region+0x50>
    asm("csrw 0xBC3, %0" : :"r"(mask));
   195bc:	fe843783          	ld	a5,-24(s0)
   195c0:	bc379073          	csrw	0xbc3,a5
    ctrl.value = 0;
   195c4:	fc043c23          	sd	zero,-40(s0)
    ctrl.bits.IDX = idx;
   195c8:	fcc42783          	lw	a5,-52(s0)
   195cc:	0ff7f793          	andi	a5,a5,255
   195d0:	fcf40ca3          	sb	a5,-39(s0)
    ctrl.bits.ENA = 1;
   195d4:	fd844783          	lbu	a5,-40(s0)
   195d8:	0107e793          	ori	a5,a5,16
   195dc:	fcf40c23          	sb	a5,-40(s0)
    ctrl.bits.CACHABLE = cached;
   195e0:	fc842783          	lw	a5,-56(s0)
   195e4:	0017f793          	andi	a5,a5,1
   195e8:	0ff7f793          	andi	a5,a5,255
   195ec:	0017f793          	andi	a5,a5,1
   195f0:	0037969b          	slliw	a3,a5,0x3
   195f4:	fd844783          	lbu	a5,-40(s0)
   195f8:	ff77f793          	andi	a5,a5,-9
   195fc:	00078713          	mv	a4,a5
   19600:	00068793          	mv	a5,a3
   19604:	00f767b3          	or	a5,a4,a5
   19608:	fcf40c23          	sb	a5,-40(s0)
    ctrl.bits.WE = 1; // write into MPU
   1960c:	fd844783          	lbu	a5,-40(s0)
   19610:	f807e793          	ori	a5,a5,-128
   19614:	fcf40c23          	sb	a5,-40(s0)
    while (*p) {
   19618:	0700006f          	j	19688 <mpu_enable_region+0x13c>
        if (*p == 'r') {
   1961c:	fe043783          	ld	a5,-32(s0)
   19620:	0007c783          	lbu	a5,0(a5)
   19624:	00078713          	mv	a4,a5
   19628:	07200793          	li	a5,114
   1962c:	00f71863          	bne	a4,a5,1963c <mpu_enable_region+0xf0>
            ctrl.bits.RD = 1;
   19630:	fd844783          	lbu	a5,-40(s0)
   19634:	0027e793          	ori	a5,a5,2
   19638:	fcf40c23          	sb	a5,-40(s0)
        if (*p == 'w') {
   1963c:	fe043783          	ld	a5,-32(s0)
   19640:	0007c783          	lbu	a5,0(a5)
   19644:	00078713          	mv	a4,a5
   19648:	07700793          	li	a5,119
   1964c:	00f71863          	bne	a4,a5,1965c <mpu_enable_region+0x110>
            ctrl.bits.WR = 1;
   19650:	fd844783          	lbu	a5,-40(s0)
   19654:	0017e793          	ori	a5,a5,1
   19658:	fcf40c23          	sb	a5,-40(s0)
        if (*p == 'x') {
   1965c:	fe043783          	ld	a5,-32(s0)
   19660:	0007c783          	lbu	a5,0(a5)
   19664:	00078713          	mv	a4,a5
   19668:	07800793          	li	a5,120
   1966c:	00f71863          	bne	a4,a5,1967c <mpu_enable_region+0x130>
            ctrl.bits.EXEC = 1;
   19670:	fd844783          	lbu	a5,-40(s0)
   19674:	0047e793          	ori	a5,a5,4
   19678:	fcf40c23          	sb	a5,-40(s0)
        p++;
   1967c:	fe043783          	ld	a5,-32(s0)
   19680:	00178793          	addi	a5,a5,1
   19684:	fef43023          	sd	a5,-32(s0)
    while (*p) {
   19688:	fe043783          	ld	a5,-32(s0)
   1968c:	0007c783          	lbu	a5,0(a5)
   19690:	f80796e3          	bnez	a5,1961c <mpu_enable_region+0xd0>
    asm("csrw 0xBC4, %0" : :"r"(ctrl.value));
   19694:	fd843783          	ld	a5,-40(s0)
   19698:	bc479073          	csrw	0xbc4,a5
}
   1969c:	00000013          	nop
   196a0:	04813403          	ld	s0,72(sp)
   196a4:	05010113          	addi	sp,sp,80
   196a8:	00008067          	ret

00000000000196ac <hwthread2>:
#include "axi_maps.h"
#include "encoding.h"
#include "fw_api.h"


int hwthread2() {
   196ac:	fc010113          	addi	sp,sp,-64
   196b0:	02113c23          	sd	ra,56(sp)
   196b4:	02813823          	sd	s0,48(sp)
   196b8:	04010413          	addi	s0,sp,64
    pnp_map *pnp = (pnp_map *)ADDR_BUS0_XSLV_PNP;
   196bc:	100ff7b7          	lui	a5,0x100ff
   196c0:	fef43423          	sd	a5,-24(s0)
    clint_map *clint = (clint_map *)ADDR_BUS0_XSLV_CLINT;
   196c4:	020007b7          	lui	a5,0x2000
   196c8:	fef43023          	sd	a5,-32(s0)
    uint32_t *tdata;
    uint32_t mod40;
    uint64_t msie = 0x1ull << 3;
   196cc:	00800793          	li	a5,8
   196d0:	fcf43c23          	sd	a5,-40(s0)

    clint->msip[fw_get_cpuid()] = 0;          // clear SW pending bit in CLINT
   196d4:	e40f90ef          	jal	ra,12d14 <fw_get_cpuid>
   196d8:	00050793          	mv	a5,a0
   196dc:	fe043703          	ld	a4,-32(s0)
   196e0:	00279793          	slli	a5,a5,0x2
   196e4:	00f707b3          	add	a5,a4,a5
   196e8:	0007a023          	sw	zero,0(a5) # 2000000 <_end+0x1fe0764>
    fw_mie_enable(HART_IRQ_MSIP);
   196ec:	00300513          	li	a0,3
   196f0:	ec4f90ef          	jal	ra,12db4 <fw_mie_enable>
    fw_enable_m_interrupts();
   196f4:	e68f90ef          	jal	ra,12d5c <fw_enable_m_interrupts>
    // Without Coherent-L2 CPUs can't see updated value (without flush) 
    // because it is always stored in L1-cache in each processor.
    //
    // Print 'passed' only on second cycle. First cycle is the test itself.
    while (1) {
        asm("wfi");
   196f8:	10500073          	wfi

        tdata = (uint32_t *)pnp->fwdbg1;    // thread0 should initialize SRAM location of the variable
   196fc:	fe843783          	ld	a5,-24(s0)
   19700:	0287b783          	ld	a5,40(a5)
   19704:	fcf43823          	sd	a5,-48(s0)

        while (*tdata < 75) {
   19708:	0680006f          	j	19770 <hwthread2+0xc4>
            mod40 = (*tdata) % 40;
   1970c:	fd043783          	ld	a5,-48(s0)
   19710:	0007a783          	lw	a5,0(a5)
   19714:	00078713          	mv	a4,a5
   19718:	02800793          	li	a5,40
   1971c:	02f777bb          	remuw	a5,a4,a5
   19720:	fcf42623          	sw	a5,-52(s0)
            if (mod40 >= 20 && mod40 < 30) {
   19724:	fcc42783          	lw	a5,-52(s0)
   19728:	0007871b          	sext.w	a4,a5
   1972c:	01300793          	li	a5,19
   19730:	04e7f063          	bleu	a4,a5,19770 <hwthread2+0xc4>
   19734:	fcc42783          	lw	a5,-52(s0)
   19738:	0007871b          	sext.w	a4,a5
   1973c:	01d00793          	li	a5,29
   19740:	02e7e863          	bltu	a5,a4,19770 <hwthread2+0xc4>
                pnp->fwdbg2 = fw_get_cpuid();  // to debug in RTL and see CPU index
   19744:	dd0f90ef          	jal	ra,12d14 <fw_get_cpuid>
   19748:	00050793          	mv	a5,a0
   1974c:	00078713          	mv	a4,a5
   19750:	fe843783          	ld	a5,-24(s0)
   19754:	02e7b823          	sd	a4,48(a5)
                (*tdata)++;
   19758:	fd043783          	ld	a5,-48(s0)
   1975c:	0007a783          	lw	a5,0(a5)
   19760:	0017879b          	addiw	a5,a5,1
   19764:	0007871b          	sext.w	a4,a5
   19768:	fd043783          	ld	a5,-48(s0)
   1976c:	00e7a023          	sw	a4,0(a5)
        while (*tdata < 75) {
   19770:	fd043783          	ld	a5,-48(s0)
   19774:	0007a783          	lw	a5,0(a5)
   19778:	00078713          	mv	a4,a5
   1977c:	04a00793          	li	a5,74
   19780:	f8e7f6e3          	bleu	a4,a5,1970c <hwthread2+0x60>
        asm("wfi");
   19784:	f75ff06f          	j	196f8 <hwthread2+0x4c>
   19788:	0000                	unimp
	...

000000000001978c <get_dev_bar>:
static uint64_t get_dev_bar(pnp_map *pnp, uint16_t vid, uint16_t did) {
   1978c:	fb010113          	addi	sp,sp,-80
   19790:	04813423          	sd	s0,72(sp)
   19794:	05010413          	addi	s0,sp,80
   19798:	faa43c23          	sd	a0,-72(s0)
   1979c:	00058793          	mv	a5,a1
   197a0:	00060713          	mv	a4,a2
   197a4:	faf41b23          	sh	a5,-74(s0)
   197a8:	00070793          	mv	a5,a4
   197ac:	faf41a23          	sh	a5,-76(s0)
    int slots_total = (pnp->cfg >> 8) & 0xFF;
   197b0:	fb843783          	ld	a5,-72(s0)
   197b4:	0087a783          	lw	a5,8(a5)
   197b8:	0087d79b          	srliw	a5,a5,0x8
   197bc:	0007879b          	sext.w	a5,a5
   197c0:	0007879b          	sext.w	a5,a5
   197c4:	0ff7f793          	andi	a5,a5,255
   197c8:	fef42223          	sw	a5,-28(s0)
    int off = 0;
   197cc:	fe042623          	sw	zero,-20(s0)
    for (int i = 0; i < slots_total; i++) {
   197d0:	fe042423          	sw	zero,-24(s0)
   197d4:	09c0006f          	j	19870 <get_dev_bar+0xe4>
        dcfg = *(dev_cfg_type *)&pnp->cfg_table[off];
   197d8:	fec42783          	lw	a5,-20(s0)
   197dc:	04078793          	addi	a5,a5,64
   197e0:	fb843703          	ld	a4,-72(s0)
   197e4:	00f707b3          	add	a5,a4,a5
   197e8:	0007b703          	ld	a4,0(a5)
   197ec:	fce43023          	sd	a4,-64(s0)
   197f0:	0087b703          	ld	a4,8(a5)
   197f4:	fce43423          	sd	a4,-56(s0)
   197f8:	0107b703          	ld	a4,16(a5)
   197fc:	fce43823          	sd	a4,-48(s0)
   19800:	0187b783          	ld	a5,24(a5)
   19804:	fcf43c23          	sd	a5,-40(s0)
        off += sizeof(dcfg);
   19808:	fec42783          	lw	a5,-20(s0)
   1980c:	0207879b          	addiw	a5,a5,32
   19810:	0007879b          	sext.w	a5,a5
   19814:	fef42623          	sw	a5,-20(s0)
        if (dcfg.u.descrtype != PNP_CFG_TYPE_SLAVE) {
   19818:	fc144783          	lbu	a5,-63(s0)
   1981c:	0037f793          	andi	a5,a5,3
   19820:	0ff7f793          	andi	a5,a5,255
   19824:	00078713          	mv	a4,a5
   19828:	00200793          	li	a5,2
   1982c:	02f71a63          	bne	a4,a5,19860 <get_dev_bar+0xd4>
        if (dcfg.u.vid == vid && dcfg.u.did == did) {
   19830:	fc645783          	lhu	a5,-58(s0)
   19834:	fb645703          	lhu	a4,-74(s0)
   19838:	0007071b          	sext.w	a4,a4
   1983c:	0007879b          	sext.w	a5,a5
   19840:	02f71263          	bne	a4,a5,19864 <get_dev_bar+0xd8>
   19844:	fc445783          	lhu	a5,-60(s0)
   19848:	fb445703          	lhu	a4,-76(s0)
   1984c:	0007071b          	sext.w	a4,a4
   19850:	0007879b          	sext.w	a5,a5
   19854:	00f71863          	bne	a4,a5,19864 <get_dev_bar+0xd8>
            return dcfg.u.addr_start;
   19858:	fd043783          	ld	a5,-48(s0)
   1985c:	02c0006f          	j	19888 <get_dev_bar+0xfc>
            continue;
   19860:	00000013          	nop
    for (int i = 0; i < slots_total; i++) {
   19864:	fe842783          	lw	a5,-24(s0)
   19868:	0017879b          	addiw	a5,a5,1
   1986c:	fef42423          	sw	a5,-24(s0)
   19870:	fe842703          	lw	a4,-24(s0)
   19874:	fe442783          	lw	a5,-28(s0)
   19878:	0007071b          	sext.w	a4,a4
   1987c:	0007879b          	sext.w	a5,a5
   19880:	f4f74ce3          	blt	a4,a5,197d8 <get_dev_bar+0x4c>
    return DEV_NONE;
   19884:	fff00793          	li	a5,-1
}
   19888:	00078513          	mv	a0,a5
   1988c:	04813403          	ld	s0,72(sp)
   19890:	05010113          	addi	sp,sp,80
   19894:	00008067          	ret

0000000000019898 <mpu_region_total>:
static int mpu_region_total() {
   19898:	fe010113          	addi	sp,sp,-32
   1989c:	00813c23          	sd	s0,24(sp)
   198a0:	02010413          	addi	s0,sp,32
    uint64_t val = 0;
   198a4:	fe043423          	sd	zero,-24(s0)
    asm("csrr %0, 0xBC4" : "=r" (val));
   198a8:	bc4027f3          	csrr	a5,0xbc4
   198ac:	fef43423          	sd	a5,-24(s0)
    return (int)(val >> 8);
   198b0:	fe843783          	ld	a5,-24(s0)
   198b4:	0087d793          	srli	a5,a5,0x8
   198b8:	0007879b          	sext.w	a5,a5
}
   198bc:	00078513          	mv	a0,a5
   198c0:	01813403          	ld	s0,24(sp)
   198c4:	02010113          	addi	sp,sp,32
   198c8:	00008067          	ret

00000000000198cc <mpu_disable_region>:
static void mpu_disable_region(int idx) {
   198cc:	fd010113          	addi	sp,sp,-48
   198d0:	02813423          	sd	s0,40(sp)
   198d4:	03010413          	addi	s0,sp,48
   198d8:	00050793          	mv	a5,a0
   198dc:	fcf42e23          	sw	a5,-36(s0)
    ctrl.value = 0;
   198e0:	fe043423          	sd	zero,-24(s0)
    ctrl.bits.IDX = idx;
   198e4:	fdc42783          	lw	a5,-36(s0)
   198e8:	0ff7f793          	andi	a5,a5,255
   198ec:	fef404a3          	sb	a5,-23(s0)
    ctrl.bits.WE = 1;
   198f0:	fe844783          	lbu	a5,-24(s0)
   198f4:	f807e793          	ori	a5,a5,-128
   198f8:	fef40423          	sb	a5,-24(s0)
    asm("csrw 0xBC4, %0" : :"r"(ctrl.value));
   198fc:	fe843783          	ld	a5,-24(s0)
   19900:	bc479073          	csrw	0xbc4,a5
}
   19904:	00000013          	nop
   19908:	02813403          	ld	s0,40(sp)
   1990c:	03010113          	addi	sp,sp,48
   19910:	00008067          	ret

0000000000019914 <mpu_enable_region>:
                       const char *rwx) {
   19914:	fb010113          	addi	sp,sp,-80
   19918:	04813423          	sd	s0,72(sp)
   1991c:	05010413          	addi	s0,sp,80
   19920:	00050793          	mv	a5,a0
   19924:	fcb43023          	sd	a1,-64(s0)
   19928:	fac43c23          	sd	a2,-72(s0)
   1992c:	fae43823          	sd	a4,-80(s0)
   19930:	fcf42623          	sw	a5,-52(s0)
   19934:	00068793          	mv	a5,a3
   19938:	fcf42423          	sw	a5,-56(s0)
    uint64_t mask = (~0ull) << 10;
   1993c:	c0000793          	li	a5,-1024
   19940:	fef43423          	sd	a5,-24(s0)
    const char *p = rwx;
   19944:	fb043783          	ld	a5,-80(s0)
   19948:	fef43023          	sd	a5,-32(s0)
    asm("csrw 0xBC2, %0" : :"r"(bar));
   1994c:	fc043783          	ld	a5,-64(s0)
   19950:	bc279073          	csrw	0xbc2,a5
    KB >>= 1;
   19954:	fb843783          	ld	a5,-72(s0)
   19958:	0017d793          	srli	a5,a5,0x1
   1995c:	faf43c23          	sd	a5,-72(s0)
    while (KB) {
   19960:	01c0006f          	j	1997c <mpu_enable_region+0x68>
        mask <<= 1;
   19964:	fe843783          	ld	a5,-24(s0)
   19968:	00179793          	slli	a5,a5,0x1
   1996c:	fef43423          	sd	a5,-24(s0)
        KB >>= 1;
   19970:	fb843783          	ld	a5,-72(s0)
   19974:	0017d793          	srli	a5,a5,0x1
   19978:	faf43c23          	sd	a5,-72(s0)
    while (KB) {
   1997c:	fb843783          	ld	a5,-72(s0)
   19980:	fe0792e3          	bnez	a5,19964 <mpu_enable_region+0x50>
    asm("csrw 0xBC3, %0" : :"r"(mask));
   19984:	fe843783          	ld	a5,-24(s0)
   19988:	bc379073          	csrw	0xbc3,a5
    ctrl.value = 0;
   1998c:	fc043c23          	sd	zero,-40(s0)
    ctrl.bits.IDX = idx;
   19990:	fcc42783          	lw	a5,-52(s0)
   19994:	0ff7f793          	andi	a5,a5,255
   19998:	fcf40ca3          	sb	a5,-39(s0)
    ctrl.bits.ENA = 1;
   1999c:	fd844783          	lbu	a5,-40(s0)
   199a0:	0107e793          	ori	a5,a5,16
   199a4:	fcf40c23          	sb	a5,-40(s0)
    ctrl.bits.CACHABLE = cached;
   199a8:	fc842783          	lw	a5,-56(s0)
   199ac:	0017f793          	andi	a5,a5,1
   199b0:	0ff7f793          	andi	a5,a5,255
   199b4:	0017f793          	andi	a5,a5,1
   199b8:	0037969b          	slliw	a3,a5,0x3
   199bc:	fd844783          	lbu	a5,-40(s0)
   199c0:	ff77f793          	andi	a5,a5,-9
   199c4:	00078713          	mv	a4,a5
   199c8:	00068793          	mv	a5,a3
   199cc:	00f767b3          	or	a5,a4,a5
   199d0:	fcf40c23          	sb	a5,-40(s0)
    ctrl.bits.WE = 1; // write into MPU
   199d4:	fd844783          	lbu	a5,-40(s0)
   199d8:	f807e793          	ori	a5,a5,-128
   199dc:	fcf40c23          	sb	a5,-40(s0)
    while (*p) {
   199e0:	0700006f          	j	19a50 <mpu_enable_region+0x13c>
        if (*p == 'r') {
   199e4:	fe043783          	ld	a5,-32(s0)
   199e8:	0007c783          	lbu	a5,0(a5)
   199ec:	00078713          	mv	a4,a5
   199f0:	07200793          	li	a5,114
   199f4:	00f71863          	bne	a4,a5,19a04 <mpu_enable_region+0xf0>
            ctrl.bits.RD = 1;
   199f8:	fd844783          	lbu	a5,-40(s0)
   199fc:	0027e793          	ori	a5,a5,2
   19a00:	fcf40c23          	sb	a5,-40(s0)
        if (*p == 'w') {
   19a04:	fe043783          	ld	a5,-32(s0)
   19a08:	0007c783          	lbu	a5,0(a5)
   19a0c:	00078713          	mv	a4,a5
   19a10:	07700793          	li	a5,119
   19a14:	00f71863          	bne	a4,a5,19a24 <mpu_enable_region+0x110>
            ctrl.bits.WR = 1;
   19a18:	fd844783          	lbu	a5,-40(s0)
   19a1c:	0017e793          	ori	a5,a5,1
   19a20:	fcf40c23          	sb	a5,-40(s0)
        if (*p == 'x') {
   19a24:	fe043783          	ld	a5,-32(s0)
   19a28:	0007c783          	lbu	a5,0(a5)
   19a2c:	00078713          	mv	a4,a5
   19a30:	07800793          	li	a5,120
   19a34:	00f71863          	bne	a4,a5,19a44 <mpu_enable_region+0x130>
            ctrl.bits.EXEC = 1;
   19a38:	fd844783          	lbu	a5,-40(s0)
   19a3c:	0047e793          	ori	a5,a5,4
   19a40:	fcf40c23          	sb	a5,-40(s0)
        p++;
   19a44:	fe043783          	ld	a5,-32(s0)
   19a48:	00178793          	addi	a5,a5,1
   19a4c:	fef43023          	sd	a5,-32(s0)
    while (*p) {
   19a50:	fe043783          	ld	a5,-32(s0)
   19a54:	0007c783          	lbu	a5,0(a5)
   19a58:	f80796e3          	bnez	a5,199e4 <mpu_enable_region+0xd0>
    asm("csrw 0xBC4, %0" : :"r"(ctrl.value));
   19a5c:	fd843783          	ld	a5,-40(s0)
   19a60:	bc479073          	csrw	0xbc4,a5
}
   19a64:	00000013          	nop
   19a68:	04813403          	ld	s0,72(sp)
   19a6c:	05010113          	addi	sp,sp,80
   19a70:	00008067          	ret

0000000000019a74 <hwthread3>:
#include "axi_maps.h"
#include "encoding.h"
#include "fw_api.h"


int hwthread3() {
   19a74:	fc010113          	addi	sp,sp,-64
   19a78:	02113c23          	sd	ra,56(sp)
   19a7c:	02813823          	sd	s0,48(sp)
   19a80:	04010413          	addi	s0,sp,64
    pnp_map *pnp = (pnp_map *)ADDR_BUS0_XSLV_PNP;
   19a84:	100ff7b7          	lui	a5,0x100ff
   19a88:	fef43423          	sd	a5,-24(s0)
    clint_map *clint = (clint_map *)ADDR_BUS0_XSLV_CLINT;
   19a8c:	020007b7          	lui	a5,0x2000
   19a90:	fef43023          	sd	a5,-32(s0)
    uint32_t *tdata;
    uint32_t mod40;
    uint64_t msie = 0x1ull << 3;
   19a94:	00800793          	li	a5,8
   19a98:	fcf43c23          	sd	a5,-40(s0)

    clint->msip[fw_get_cpuid()] = 0;    // clear SW pending bit in CLINT
   19a9c:	a78f90ef          	jal	ra,12d14 <fw_get_cpuid>
   19aa0:	00050793          	mv	a5,a0
   19aa4:	fe043703          	ld	a4,-32(s0)
   19aa8:	00279793          	slli	a5,a5,0x2
   19aac:	00f707b3          	add	a5,a4,a5
   19ab0:	0007a023          	sw	zero,0(a5) # 2000000 <_end+0x1fe0764>
    fw_mie_enable(HART_IRQ_MSIP);
   19ab4:	00300513          	li	a0,3
   19ab8:	afcf90ef          	jal	ra,12db4 <fw_mie_enable>
    fw_enable_m_interrupts();
   19abc:	aa0f90ef          	jal	ra,12d5c <fw_enable_m_interrupts>
    // because it is always stored in L1-cache in each processor.
    //
    // Print 'passed' only on second cycle. First cycle is the test itself.
    while (1) {

        asm("wfi");
   19ac0:	10500073          	wfi

        tdata = (uint32_t *)pnp->fwdbg1;    // thread0 should initialize SRAM location of the variable
   19ac4:	fe843783          	ld	a5,-24(s0)
   19ac8:	0287b783          	ld	a5,40(a5)
   19acc:	fcf43823          	sd	a5,-48(s0)

        while (*tdata < 75) {
   19ad0:	0680006f          	j	19b38 <hwthread3+0xc4>
            mod40 = (*tdata) % 40;
   19ad4:	fd043783          	ld	a5,-48(s0)
   19ad8:	0007a783          	lw	a5,0(a5)
   19adc:	00078713          	mv	a4,a5
   19ae0:	02800793          	li	a5,40
   19ae4:	02f777bb          	remuw	a5,a4,a5
   19ae8:	fcf42623          	sw	a5,-52(s0)
            if (mod40 >= 30 && mod40 < 40) {
   19aec:	fcc42783          	lw	a5,-52(s0)
   19af0:	0007871b          	sext.w	a4,a5
   19af4:	01d00793          	li	a5,29
   19af8:	04e7f063          	bleu	a4,a5,19b38 <hwthread3+0xc4>
   19afc:	fcc42783          	lw	a5,-52(s0)
   19b00:	0007871b          	sext.w	a4,a5
   19b04:	02700793          	li	a5,39
   19b08:	02e7e863          	bltu	a5,a4,19b38 <hwthread3+0xc4>
                pnp->fwdbg2 = fw_get_cpuid();  // to debug in RTL and see CPU index
   19b0c:	a08f90ef          	jal	ra,12d14 <fw_get_cpuid>
   19b10:	00050793          	mv	a5,a0
   19b14:	00078713          	mv	a4,a5
   19b18:	fe843783          	ld	a5,-24(s0)
   19b1c:	02e7b823          	sd	a4,48(a5)
                (*tdata)++;
   19b20:	fd043783          	ld	a5,-48(s0)
   19b24:	0007a783          	lw	a5,0(a5)
   19b28:	0017879b          	addiw	a5,a5,1
   19b2c:	0007871b          	sext.w	a4,a5
   19b30:	fd043783          	ld	a5,-48(s0)
   19b34:	00e7a023          	sw	a4,0(a5)
        while (*tdata < 75) {
   19b38:	fd043783          	ld	a5,-48(s0)
   19b3c:	0007a783          	lw	a5,0(a5)
   19b40:	00078713          	mv	a4,a5
   19b44:	04a00793          	li	a5,74
   19b48:	f8e7f6e3          	bleu	a4,a5,19ad4 <hwthread3+0x60>
        asm("wfi");
   19b4c:	f75ff06f          	j	19ac0 <hwthread3+0x4c>
   19b50:	0000                	unimp
	...

0000000000019b54 <get_dev_bar>:
static uint64_t get_dev_bar(pnp_map *pnp, uint16_t vid, uint16_t did) {
   19b54:	fb010113          	addi	sp,sp,-80
   19b58:	04813423          	sd	s0,72(sp)
   19b5c:	05010413          	addi	s0,sp,80
   19b60:	faa43c23          	sd	a0,-72(s0)
   19b64:	00058793          	mv	a5,a1
   19b68:	00060713          	mv	a4,a2
   19b6c:	faf41b23          	sh	a5,-74(s0)
   19b70:	00070793          	mv	a5,a4
   19b74:	faf41a23          	sh	a5,-76(s0)
    int slots_total = (pnp->cfg >> 8) & 0xFF;
   19b78:	fb843783          	ld	a5,-72(s0)
   19b7c:	0087a783          	lw	a5,8(a5)
   19b80:	0087d79b          	srliw	a5,a5,0x8
   19b84:	0007879b          	sext.w	a5,a5
   19b88:	0007879b          	sext.w	a5,a5
   19b8c:	0ff7f793          	andi	a5,a5,255
   19b90:	fef42223          	sw	a5,-28(s0)
    int off = 0;
   19b94:	fe042623          	sw	zero,-20(s0)
    for (int i = 0; i < slots_total; i++) {
   19b98:	fe042423          	sw	zero,-24(s0)
   19b9c:	09c0006f          	j	19c38 <get_dev_bar+0xe4>
        dcfg = *(dev_cfg_type *)&pnp->cfg_table[off];
   19ba0:	fec42783          	lw	a5,-20(s0)
   19ba4:	04078793          	addi	a5,a5,64
   19ba8:	fb843703          	ld	a4,-72(s0)
   19bac:	00f707b3          	add	a5,a4,a5
   19bb0:	0007b703          	ld	a4,0(a5)
   19bb4:	fce43023          	sd	a4,-64(s0)
   19bb8:	0087b703          	ld	a4,8(a5)
   19bbc:	fce43423          	sd	a4,-56(s0)
   19bc0:	0107b703          	ld	a4,16(a5)
   19bc4:	fce43823          	sd	a4,-48(s0)
   19bc8:	0187b783          	ld	a5,24(a5)
   19bcc:	fcf43c23          	sd	a5,-40(s0)
        off += sizeof(dcfg);
   19bd0:	fec42783          	lw	a5,-20(s0)
   19bd4:	0207879b          	addiw	a5,a5,32
   19bd8:	0007879b          	sext.w	a5,a5
   19bdc:	fef42623          	sw	a5,-20(s0)
        if (dcfg.u.descrtype != PNP_CFG_TYPE_SLAVE) {
   19be0:	fc144783          	lbu	a5,-63(s0)
   19be4:	0037f793          	andi	a5,a5,3
   19be8:	0ff7f793          	andi	a5,a5,255
   19bec:	00078713          	mv	a4,a5
   19bf0:	00200793          	li	a5,2
   19bf4:	02f71a63          	bne	a4,a5,19c28 <get_dev_bar+0xd4>
        if (dcfg.u.vid == vid && dcfg.u.did == did) {
   19bf8:	fc645783          	lhu	a5,-58(s0)
   19bfc:	fb645703          	lhu	a4,-74(s0)
   19c00:	0007071b          	sext.w	a4,a4
   19c04:	0007879b          	sext.w	a5,a5
   19c08:	02f71263          	bne	a4,a5,19c2c <get_dev_bar+0xd8>
   19c0c:	fc445783          	lhu	a5,-60(s0)
   19c10:	fb445703          	lhu	a4,-76(s0)
   19c14:	0007071b          	sext.w	a4,a4
   19c18:	0007879b          	sext.w	a5,a5
   19c1c:	00f71863          	bne	a4,a5,19c2c <get_dev_bar+0xd8>
            return dcfg.u.addr_start;
   19c20:	fd043783          	ld	a5,-48(s0)
   19c24:	02c0006f          	j	19c50 <get_dev_bar+0xfc>
            continue;
   19c28:	00000013          	nop
    for (int i = 0; i < slots_total; i++) {
   19c2c:	fe842783          	lw	a5,-24(s0)
   19c30:	0017879b          	addiw	a5,a5,1
   19c34:	fef42423          	sw	a5,-24(s0)
   19c38:	fe842703          	lw	a4,-24(s0)
   19c3c:	fe442783          	lw	a5,-28(s0)
   19c40:	0007071b          	sext.w	a4,a4
   19c44:	0007879b          	sext.w	a5,a5
   19c48:	f4f74ce3          	blt	a4,a5,19ba0 <get_dev_bar+0x4c>
    return DEV_NONE;
   19c4c:	fff00793          	li	a5,-1
}
   19c50:	00078513          	mv	a0,a5
   19c54:	04813403          	ld	s0,72(sp)
   19c58:	05010113          	addi	sp,sp,80
   19c5c:	00008067          	ret

0000000000019c60 <mpu_region_total>:
static int mpu_region_total() {
   19c60:	fe010113          	addi	sp,sp,-32
   19c64:	00813c23          	sd	s0,24(sp)
   19c68:	02010413          	addi	s0,sp,32
    uint64_t val = 0;
   19c6c:	fe043423          	sd	zero,-24(s0)
    asm("csrr %0, 0xBC4" : "=r" (val));
   19c70:	bc4027f3          	csrr	a5,0xbc4
   19c74:	fef43423          	sd	a5,-24(s0)
    return (int)(val >> 8);
   19c78:	fe843783          	ld	a5,-24(s0)
   19c7c:	0087d793          	srli	a5,a5,0x8
   19c80:	0007879b          	sext.w	a5,a5
}
   19c84:	00078513          	mv	a0,a5
   19c88:	01813403          	ld	s0,24(sp)
   19c8c:	02010113          	addi	sp,sp,32
   19c90:	00008067          	ret

0000000000019c94 <mpu_disable_region>:
static void mpu_disable_region(int idx) {
   19c94:	fd010113          	addi	sp,sp,-48
   19c98:	02813423          	sd	s0,40(sp)
   19c9c:	03010413          	addi	s0,sp,48
   19ca0:	00050793          	mv	a5,a0
   19ca4:	fcf42e23          	sw	a5,-36(s0)
    ctrl.value = 0;
   19ca8:	fe043423          	sd	zero,-24(s0)
    ctrl.bits.IDX = idx;
   19cac:	fdc42783          	lw	a5,-36(s0)
   19cb0:	0ff7f793          	andi	a5,a5,255
   19cb4:	fef404a3          	sb	a5,-23(s0)
    ctrl.bits.WE = 1;
   19cb8:	fe844783          	lbu	a5,-24(s0)
   19cbc:	f807e793          	ori	a5,a5,-128
   19cc0:	fef40423          	sb	a5,-24(s0)
    asm("csrw 0xBC4, %0" : :"r"(ctrl.value));
   19cc4:	fe843783          	ld	a5,-24(s0)
   19cc8:	bc479073          	csrw	0xbc4,a5
}
   19ccc:	00000013          	nop
   19cd0:	02813403          	ld	s0,40(sp)
   19cd4:	03010113          	addi	sp,sp,48
   19cd8:	00008067          	ret

0000000000019cdc <mpu_enable_region>:
                       const char *rwx) {
   19cdc:	fb010113          	addi	sp,sp,-80
   19ce0:	04813423          	sd	s0,72(sp)
   19ce4:	05010413          	addi	s0,sp,80
   19ce8:	00050793          	mv	a5,a0
   19cec:	fcb43023          	sd	a1,-64(s0)
   19cf0:	fac43c23          	sd	a2,-72(s0)
   19cf4:	fae43823          	sd	a4,-80(s0)
   19cf8:	fcf42623          	sw	a5,-52(s0)
   19cfc:	00068793          	mv	a5,a3
   19d00:	fcf42423          	sw	a5,-56(s0)
    uint64_t mask = (~0ull) << 10;
   19d04:	c0000793          	li	a5,-1024
   19d08:	fef43423          	sd	a5,-24(s0)
    const char *p = rwx;
   19d0c:	fb043783          	ld	a5,-80(s0)
   19d10:	fef43023          	sd	a5,-32(s0)
    asm("csrw 0xBC2, %0" : :"r"(bar));
   19d14:	fc043783          	ld	a5,-64(s0)
   19d18:	bc279073          	csrw	0xbc2,a5
    KB >>= 1;
   19d1c:	fb843783          	ld	a5,-72(s0)
   19d20:	0017d793          	srli	a5,a5,0x1
   19d24:	faf43c23          	sd	a5,-72(s0)
    while (KB) {
   19d28:	01c0006f          	j	19d44 <mpu_enable_region+0x68>
        mask <<= 1;
   19d2c:	fe843783          	ld	a5,-24(s0)
   19d30:	00179793          	slli	a5,a5,0x1
   19d34:	fef43423          	sd	a5,-24(s0)
        KB >>= 1;
   19d38:	fb843783          	ld	a5,-72(s0)
   19d3c:	0017d793          	srli	a5,a5,0x1
   19d40:	faf43c23          	sd	a5,-72(s0)
    while (KB) {
   19d44:	fb843783          	ld	a5,-72(s0)
   19d48:	fe0792e3          	bnez	a5,19d2c <mpu_enable_region+0x50>
    asm("csrw 0xBC3, %0" : :"r"(mask));
   19d4c:	fe843783          	ld	a5,-24(s0)
   19d50:	bc379073          	csrw	0xbc3,a5
    ctrl.value = 0;
   19d54:	fc043c23          	sd	zero,-40(s0)
    ctrl.bits.IDX = idx;
   19d58:	fcc42783          	lw	a5,-52(s0)
   19d5c:	0ff7f793          	andi	a5,a5,255
   19d60:	fcf40ca3          	sb	a5,-39(s0)
    ctrl.bits.ENA = 1;
   19d64:	fd844783          	lbu	a5,-40(s0)
   19d68:	0107e793          	ori	a5,a5,16
   19d6c:	fcf40c23          	sb	a5,-40(s0)
    ctrl.bits.CACHABLE = cached;
   19d70:	fc842783          	lw	a5,-56(s0)
   19d74:	0017f793          	andi	a5,a5,1
   19d78:	0ff7f793          	andi	a5,a5,255
   19d7c:	0017f793          	andi	a5,a5,1
   19d80:	0037969b          	slliw	a3,a5,0x3
   19d84:	fd844783          	lbu	a5,-40(s0)
   19d88:	ff77f793          	andi	a5,a5,-9
   19d8c:	00078713          	mv	a4,a5
   19d90:	00068793          	mv	a5,a3
   19d94:	00f767b3          	or	a5,a4,a5
   19d98:	fcf40c23          	sb	a5,-40(s0)
    ctrl.bits.WE = 1; // write into MPU
   19d9c:	fd844783          	lbu	a5,-40(s0)
   19da0:	f807e793          	ori	a5,a5,-128
   19da4:	fcf40c23          	sb	a5,-40(s0)
    while (*p) {
   19da8:	0700006f          	j	19e18 <mpu_enable_region+0x13c>
        if (*p == 'r') {
   19dac:	fe043783          	ld	a5,-32(s0)
   19db0:	0007c783          	lbu	a5,0(a5)
   19db4:	00078713          	mv	a4,a5
   19db8:	07200793          	li	a5,114
   19dbc:	00f71863          	bne	a4,a5,19dcc <mpu_enable_region+0xf0>
            ctrl.bits.RD = 1;
   19dc0:	fd844783          	lbu	a5,-40(s0)
   19dc4:	0027e793          	ori	a5,a5,2
   19dc8:	fcf40c23          	sb	a5,-40(s0)
        if (*p == 'w') {
   19dcc:	fe043783          	ld	a5,-32(s0)
   19dd0:	0007c783          	lbu	a5,0(a5)
   19dd4:	00078713          	mv	a4,a5
   19dd8:	07700793          	li	a5,119
   19ddc:	00f71863          	bne	a4,a5,19dec <mpu_enable_region+0x110>
            ctrl.bits.WR = 1;
   19de0:	fd844783          	lbu	a5,-40(s0)
   19de4:	0017e793          	ori	a5,a5,1
   19de8:	fcf40c23          	sb	a5,-40(s0)
        if (*p == 'x') {
   19dec:	fe043783          	ld	a5,-32(s0)
   19df0:	0007c783          	lbu	a5,0(a5)
   19df4:	00078713          	mv	a4,a5
   19df8:	07800793          	li	a5,120
   19dfc:	00f71863          	bne	a4,a5,19e0c <mpu_enable_region+0x130>
            ctrl.bits.EXEC = 1;
   19e00:	fd844783          	lbu	a5,-40(s0)
   19e04:	0047e793          	ori	a5,a5,4
   19e08:	fcf40c23          	sb	a5,-40(s0)
        p++;
   19e0c:	fe043783          	ld	a5,-32(s0)
   19e10:	00178793          	addi	a5,a5,1
   19e14:	fef43023          	sd	a5,-32(s0)
    while (*p) {
   19e18:	fe043783          	ld	a5,-32(s0)
   19e1c:	0007c783          	lbu	a5,0(a5)
   19e20:	f80796e3          	bnez	a5,19dac <mpu_enable_region+0xd0>
    asm("csrw 0xBC4, %0" : :"r"(ctrl.value));
   19e24:	fd843783          	ld	a5,-40(s0)
   19e28:	bc479073          	csrw	0xbc4,a5
}
   19e2c:	00000013          	nop
   19e30:	04813403          	ld	s0,72(sp)
   19e34:	05010113          	addi	sp,sp,80
   19e38:	00008067          	ret

0000000000019e3c <main>:

ESdCardType spi_init();
int spi_sd_card_memcpy(uint64_t src, uint64_t dst, int sz);


int main() {
   19e3c:	fc010113          	addi	sp,sp,-64
   19e40:	02113c23          	sd	ra,56(sp)
   19e44:	02813823          	sd	s0,48(sp)
   19e48:	04010413          	addi	s0,sp,64
    uint32_t cfg;
    pnp_map *pnp = (pnp_map *)ADDR_BUS0_XSLV_PNP;
   19e4c:	100ff7b7          	lui	a5,0x100ff
   19e50:	fef43423          	sd	a5,-24(s0)
    uart_map *uart = (uart_map *)ADDR_BUS0_XSLV_UART0;
   19e54:	100107b7          	lui	a5,0x10010
   19e58:	fef43023          	sd	a5,-32(s0)
    gpio_map *gpio = (gpio_map *)ADDR_BUS0_XSLV_GPIO;
   19e5c:	100607b7          	lui	a5,0x10060
   19e60:	fcf43c23          	sd	a5,-40(s0)
    uint64_t bar;
    uint32_t cpu_max;

    switch (fw_get_cpuid()) {
   19e64:	eb1f80ef          	jal	ra,12d14 <fw_get_cpuid>
   19e68:	00050793          	mv	a5,a0
   19e6c:	00078713          	mv	a4,a5
   19e70:	00070693          	mv	a3,a4
   19e74:	00100793          	li	a5,1
   19e78:	02f68a63          	beq	a3,a5,19eac <main+0x70>
   19e7c:	00070693          	mv	a3,a4
   19e80:	00100793          	li	a5,1
   19e84:	00d7c863          	blt	a5,a3,19e94 <main+0x58>
   19e88:	00070793          	mv	a5,a4
   19e8c:	02078e63          	beqz	a5,19ec8 <main+0x8c>
   19e90:	0340006f          	j	19ec4 <main+0x88>
   19e94:	00070693          	mv	a3,a4
   19e98:	00200793          	li	a5,2
   19e9c:	00f68c63          	beq	a3,a5,19eb4 <main+0x78>
   19ea0:	00300793          	li	a5,3
   19ea4:	00f70c63          	beq	a4,a5,19ebc <main+0x80>
   19ea8:	01c0006f          	j	19ec4 <main+0x88>
    case 0:
        break;
    case 1:
        hwthread1();
   19eac:	c38ff0ef          	jal	ra,192e4 <hwthread1>
        break;
   19eb0:	01c0006f          	j	19ecc <main+0x90>
    case 2:
        hwthread2();
   19eb4:	ff8ff0ef          	jal	ra,196ac <hwthread2>
        break;
   19eb8:	0140006f          	j	19ecc <main+0x90>
    case 3:
        hwthread3();
   19ebc:	bb9ff0ef          	jal	ra,19a74 <hwthread3>
        break;
   19ec0:	00c0006f          	j	19ecc <main+0x90>
    default:
        while (1) {}
   19ec4:	0000006f          	j	19ec4 <main+0x88>
        break;
   19ec8:	00000013          	nop
    }

    pnp->fwid = 0x20220116;
   19ecc:	fe843783          	ld	a5,-24(s0)
   19ed0:	20220737          	lui	a4,0x20220
   19ed4:	1167071b          	addiw	a4,a4,278
   19ed8:	00e7a223          	sw	a4,4(a5) # 10060004 <_end+0x10040768>
    gpio->input_en = 0x000f;
   19edc:	fd843783          	ld	a5,-40(s0)
   19ee0:	00f00713          	li	a4,15
   19ee4:	00e7a223          	sw	a4,4(a5)
    gpio->output_en = 0xfff0;
   19ee8:	fd843783          	ld	a5,-40(s0)
   19eec:	00010737          	lui	a4,0x10
   19ef0:	ff07071b          	addiw	a4,a4,-16
   19ef4:	00e7a423          	sw	a4,8(a5)
    fw_malloc_init();
   19ef8:	bb9f70ef          	jal	ra,11ab0 <fw_malloc_init>
    
    allocate_exception_table();
   19efc:	ffff7097          	auipc	ra,0xffff7
   19f00:	000080e7          	jalr	ra
    allocate_interrupt_table();
   19f04:	b8cf70ef          	jal	ra,11290 <allocate_interrupt_table>

    uart_isr_init();   // enable printf_uart function and Tx irq=1
   19f08:	ffff8097          	auipc	ra,0xffff8
   19f0c:	128080e7          	jalr	296(ra) # 12030 <uart_isr_init>
 
    led_set(0x01);
   19f10:	00100513          	li	a0,1
   19f14:	844f90ef          	jal	ra,12f58 <led_set>

#if 1
    cpu_max = pnp->cfg >> 28;
   19f18:	fe843783          	ld	a5,-24(s0)
   19f1c:	0087a783          	lw	a5,8(a5)
   19f20:	01c7d79b          	srliw	a5,a5,0x1c
   19f24:	fcf42a23          	sw	a5,-44(s0)

    printf_uart("HARTID . . . . .%d\r\n", fw_get_cpuid());
   19f28:	dedf80ef          	jal	ra,12d14 <fw_get_cpuid>
   19f2c:	00050793          	mv	a5,a0
   19f30:	00078593          	mv	a1,a5
   19f34:	0001e7b7          	lui	a5,0x1e
   19f38:	fe078513          	addi	a0,a5,-32 # 1dfe0 <FCVT_WU_D_TESTS+0x9a8>
   19f3c:	ffff9097          	auipc	ra,0xffff9
   19f40:	a14080e7          	jalr	-1516(ra) # 12950 <printf_uart>
    printf_uart("HARTS. . . . . .%d\r\n", cpu_max);
   19f44:	fd442783          	lw	a5,-44(s0)
   19f48:	00078593          	mv	a1,a5
   19f4c:	0001e7b7          	lui	a5,0x1e
   19f50:	ff878513          	addi	a0,a5,-8 # 1dff8 <FCVT_WU_D_TESTS+0x9c0>
   19f54:	ffff9097          	auipc	ra,0xffff9
   19f58:	9fc080e7          	jalr	-1540(ra) # 12950 <printf_uart>
    printf_uart("PLIC_IRQS  . . .%d\r\n", (pnp->cfg & 0xFF));
   19f5c:	fe843783          	ld	a5,-24(s0)
   19f60:	0087a783          	lw	a5,8(a5)
   19f64:	0ff7f793          	andi	a5,a5,255
   19f68:	0007879b          	sext.w	a5,a5
   19f6c:	00078593          	mv	a1,a5
   19f70:	0001e7b7          	lui	a5,0x1e
   19f74:	01078513          	addi	a0,a5,16 # 1e010 <FCVT_WU_D_TESTS+0x9d8>
   19f78:	ffff9097          	auipc	ra,0xffff9
   19f7c:	9d8080e7          	jalr	-1576(ra) # 12950 <printf_uart>
    printf_uart("HWID . . . . . .0x%08x\r\n", pnp->hwid);
   19f80:	fe843783          	ld	a5,-24(s0)
   19f84:	0007a783          	lw	a5,0(a5)
   19f88:	00078593          	mv	a1,a5
   19f8c:	0001e7b7          	lui	a5,0x1e
   19f90:	02878513          	addi	a0,a5,40 # 1e028 <FCVT_WU_D_TESTS+0x9f0>
   19f94:	ffff9097          	auipc	ra,0xffff9
   19f98:	9bc080e7          	jalr	-1604(ra) # 12950 <printf_uart>
    printf_uart("FWID . . . . . .0x%08x\r\n", pnp->fwid);
   19f9c:	fe843783          	ld	a5,-24(s0)
   19fa0:	0047a783          	lw	a5,4(a5)
   19fa4:	00078593          	mv	a1,a5
   19fa8:	0001e7b7          	lui	a5,0x1e
   19fac:	04878513          	addi	a0,a5,72 # 1e048 <FCVT_WU_D_TESTS+0xa10>
   19fb0:	ffff9097          	auipc	ra,0xffff9
   19fb4:	9a0080e7          	jalr	-1632(ra) # 12950 <printf_uart>

    led_set(0x02);
   19fb8:	00200513          	li	a0,2
   19fbc:	f9df80ef          	jal	ra,12f58 <led_set>

    test_plic();
   19fc0:	ffffb097          	auipc	ra,0xffffb
   19fc4:	5a4080e7          	jalr	1444(ra) # 15564 <test_plic>
    test_mtimer();
   19fc8:	9edfb0ef          	jal	ra,159b4 <test_mtimer>
    test_swirq();
   19fcc:	e09fb0ef          	jal	ra,15dd4 <test_swirq>
    test_l2coherence();
   19fd0:	a0cfc0ef          	jal	ra,161dc <test_l2coherence>
    test_pmp();
   19fd4:	865fc0ef          	jal	ra,16838 <test_pmp>
    test_mmu();
   19fd8:	d80fd0ef          	jal	ra,17558 <test_mmu>

    led_set(0x03);
   19fdc:	00300513          	li	a0,3
   19fe0:	f79f80ef          	jal	ra,12f58 <led_set>
    test_fpu();
   19fe4:	935f90ef          	jal	ra,13918 <test_fpu>

    led_set(0x04);
   19fe8:	00400513          	li	a0,4
   19fec:	f6df80ef          	jal	ra,12f58 <led_set>
    test_missaccess();
   19ff0:	d74fa0ef          	jal	ra,14564 <test_missaccess>

    led_set(0x05);
   19ff4:	00500513          	li	a0,5
   19ff8:	f61f80ef          	jal	ra,12f58 <led_set>
    test_stackprotect();
   19ffc:	addfa0ef          	jal	ra,14ad8 <test_stackprotect>


    led_set(0x55);
   1a000:	05500513          	li	a0,85
   1a004:	f55f80ef          	jal	ra,12f58 <led_set>
    print_pnp();
   1a008:	eb0f90ef          	jal	ra,136b8 <print_pnp>

    led_set(0x1F);
   1a00c:	01f00513          	li	a0,31
   1a010:	f49f80ef          	jal	ra,12f58 <led_set>

    test_ddr();
   1a014:	bbdfd0ef          	jal	ra,17bd0 <test_ddr>
#endif

    ESdCardType sdtype = spi_init();
   1a018:	fffff097          	auipc	ra,0xfffff
   1a01c:	f4c080e7          	jalr	-180(ra) # 18f64 <spi_init>
   1a020:	00050793          	mv	a5,a0
   1a024:	fcf42823          	sw	a5,-48(s0)

    SD_Unknown,
   1a028:	0001e7b7          	lui	a5,0x1e
   1a02c:	06878593          	addi	a1,a5,104 # 1e068 <FCVT_WU_D_TESTS+0xa30>
   1a030:	0001e7b7          	lui	a5,0x1e
   1a034:	08078513          	addi	a0,a5,128 # 1e080 <FCVT_WU_D_TESTS+0xa48>
   1a038:	ffff9097          	auipc	ra,0xffff9
   1a03c:	918080e7          	jalr	-1768(ra) # 12950 <printf_uart>
    printf_uart("%s", "SPI.Init . . . .");
    if (sdtype == SD_Ver1x) {
   1a040:	fd042783          	lw	a5,-48(s0)
   1a044:	0007871b          	sext.w	a4,a5
   1a048:	00100793          	li	a5,1
   1a04c:	02f71063          	bne	a4,a5,1a06c <main+0x230>
        printf_uart("%s\r\n", "SD1x");
   1a050:	0001e7b7          	lui	a5,0x1e
   1a054:	08878593          	addi	a1,a5,136 # 1e088 <FCVT_WU_D_TESTS+0xa50>
   1a058:	0001e7b7          	lui	a5,0x1e
   1a05c:	09078513          	addi	a0,a5,144 # 1e090 <FCVT_WU_D_TESTS+0xa58>
   1a060:	ffff9097          	auipc	ra,0xffff9
   1a064:	8f0080e7          	jalr	-1808(ra) # 12950 <printf_uart>
   1a068:	0780006f          	j	1a0e0 <main+0x2a4>
    } else if (sdtype == SD_Ver2x_StandardCapacity) {
   1a06c:	fd042783          	lw	a5,-48(s0)
   1a070:	0007871b          	sext.w	a4,a5
   1a074:	00200793          	li	a5,2
   1a078:	02f71063          	bne	a4,a5,1a098 <main+0x25c>
        printf_uart("%s\r\n", "SD2x");
   1a07c:	0001e7b7          	lui	a5,0x1e
   1a080:	09878593          	addi	a1,a5,152 # 1e098 <FCVT_WU_D_TESTS+0xa60>
   1a084:	0001e7b7          	lui	a5,0x1e
   1a088:	09078513          	addi	a0,a5,144 # 1e090 <FCVT_WU_D_TESTS+0xa58>
   1a08c:	ffff9097          	auipc	ra,0xffff9
   1a090:	8c4080e7          	jalr	-1852(ra) # 12950 <printf_uart>
   1a094:	04c0006f          	j	1a0e0 <main+0x2a4>
    } else if (sdtype == SD_Ver2x_HighCapacity) {
   1a098:	fd042783          	lw	a5,-48(s0)
   1a09c:	0007871b          	sext.w	a4,a5
   1a0a0:	00300793          	li	a5,3
   1a0a4:	02f71063          	bne	a4,a5,1a0c4 <main+0x288>
        printf_uart("%s\r\n", "SDHC");
   1a0a8:	0001e7b7          	lui	a5,0x1e
   1a0ac:	0a078593          	addi	a1,a5,160 # 1e0a0 <FCVT_WU_D_TESTS+0xa68>
   1a0b0:	0001e7b7          	lui	a5,0x1e
   1a0b4:	09078513          	addi	a0,a5,144 # 1e090 <FCVT_WU_D_TESTS+0xa58>
   1a0b8:	ffff9097          	auipc	ra,0xffff9
   1a0bc:	898080e7          	jalr	-1896(ra) # 12950 <printf_uart>
   1a0c0:	0200006f          	j	1a0e0 <main+0x2a4>
    } else {
        printf_uart("%s", "Wrong SD-card\r\n");
   1a0c4:	0001e7b7          	lui	a5,0x1e
   1a0c8:	0a878593          	addi	a1,a5,168 # 1e0a8 <FCVT_WU_D_TESTS+0xa70>
   1a0cc:	0001e7b7          	lui	a5,0x1e
   1a0d0:	08078513          	addi	a0,a5,128 # 1e080 <FCVT_WU_D_TESTS+0xa48>
   1a0d4:	ffff9097          	auipc	ra,0xffff9
   1a0d8:	87c080e7          	jalr	-1924(ra) # 12950 <printf_uart>
        while (1) {}
   1a0dc:	0000006f          	j	1a0dc <main+0x2a0>
    }

    static const int BBL_IMAGE_SIZE = 10*1024*1024;  // actually ~8MB

    printf_uart("%s", "Copy BBL . . . .");
   1a0e0:	0001e7b7          	lui	a5,0x1e
   1a0e4:	0b878593          	addi	a1,a5,184 # 1e0b8 <FCVT_WU_D_TESTS+0xa80>
   1a0e8:	0001e7b7          	lui	a5,0x1e
   1a0ec:	08078513          	addi	a0,a5,128 # 1e080 <FCVT_WU_D_TESTS+0xa48>
   1a0f0:	ffff9097          	auipc	ra,0xffff9
   1a0f4:	860080e7          	jalr	-1952(ra) # 12950 <printf_uart>
    int copied = spi_sd_card_memcpy(0, ADDR_BUS0_XSLV_DDR, BBL_IMAGE_SIZE);
   1a0f8:	000207b7          	lui	a5,0x20
   1a0fc:	8987a783          	lw	a5,-1896(a5) # 1f898 <BBL_IMAGE_SIZE.2354>
   1a100:	00078613          	mv	a2,a5
   1a104:	00100793          	li	a5,1
   1a108:	01f79593          	slli	a1,a5,0x1f
   1a10c:	00000513          	li	a0,0
   1a110:	c69fe0ef          	jal	ra,18d78 <spi_sd_card_memcpy>
   1a114:	00050793          	mv	a5,a0
   1a118:	fcf42623          	sw	a5,-52(s0)
    if (copied < BBL_IMAGE_SIZE) {
   1a11c:	000207b7          	lui	a5,0x20
   1a120:	8987a703          	lw	a4,-1896(a5) # 1f898 <BBL_IMAGE_SIZE.2354>
   1a124:	fcc42783          	lw	a5,-52(s0)
   1a128:	0007879b          	sext.w	a5,a5
   1a12c:	02e7d063          	ble	a4,a5,1a14c <main+0x310>
        printf_uart("%s\r\n", "Failed");
   1a130:	0001e7b7          	lui	a5,0x1e
   1a134:	0d078593          	addi	a1,a5,208 # 1e0d0 <FCVT_WU_D_TESTS+0xa98>
   1a138:	0001e7b7          	lui	a5,0x1e
   1a13c:	09078513          	addi	a0,a5,144 # 1e090 <FCVT_WU_D_TESTS+0xa58>
   1a140:	ffff9097          	auipc	ra,0xffff9
   1a144:	810080e7          	jalr	-2032(ra) # 12950 <printf_uart>
        while (1) {}
   1a148:	0000006f          	j	1a148 <main+0x30c>
    } else {
        printf_uart("%d B copied\r\n", copied);
   1a14c:	fcc42783          	lw	a5,-52(s0)
   1a150:	00078593          	mv	a1,a5
   1a154:	0001e7b7          	lui	a5,0x1e
   1a158:	0d878513          	addi	a0,a5,216 # 1e0d8 <FCVT_WU_D_TESTS+0xaa0>
   1a15c:	ffff8097          	auipc	ra,0xffff8
   1a160:	7f4080e7          	jalr	2036(ra) # 12950 <printf_uart>
    }

    // Run BSL and Linux from DDR:
    set_csr(mstatus, MSTATUS_MPP_M);          // run bbl-q and riscv-tests in machine mode
   1a164:	000027b7          	lui	a5,0x2
   1a168:	8007879b          	addiw	a5,a5,-2048
   1a16c:	3007a7f3          	csrrs	a5,mstatus,a5
   1a170:	fcf43023          	sd	a5,-64(s0)
    write_csr(mepc, ADDR_BUS0_XSLV_DDR);      // jump to ddr (bbl-q should be init)
   1a174:	00100793          	li	a5,1
   1a178:	01f79793          	slli	a5,a5,0x1f
   1a17c:	34179073          	csrw	mepc,a5

    // a0 = hart id
    // a1 = fdt header
    __asm__("fence.i");
   1a180:	0000100f          	fence.i
   for (int i = 0; i < BBL_IMAGE_SIZE/sizeof(uint64_t); i++) {
        printf_uart("%016llx\r\n", verif[i]);
   }
#endif

    __asm__("csrr a0, mhartid");
   1a184:	f1402573          	csrr	a0,mhartid
    __asm__("la a1, dtb_start");
   1a188:	00004597          	auipc	a1,0x4
   1a18c:	02058593          	addi	a1,a1,32 # 1e1a8 <dtb_start>
    __asm__("mret");
   1a190:	30200073          	mret

    // NEVER REACH THIS POINT
    return 0;
   1a194:	00000793          	li	a5,0
}
   1a198:	00078513          	mv	a0,a5
   1a19c:	03813083          	ld	ra,56(sp)
   1a1a0:	03013403          	ld	s0,48(sp)
   1a1a4:	04010113          	addi	sp,sp,64
   1a1a8:	00008067          	ret
	...

000000000001a1ae <memcpy>:
   1a1ae:	00a5c7b3          	xor	a5,a1,a0
   1a1b2:	8b9d                	andi	a5,a5,7
   1a1b4:	00c50733          	add	a4,a0,a2
   1a1b8:	e781                	bnez	a5,1a1c0 <memcpy+0x12>
   1a1ba:	479d                	li	a5,7
   1a1bc:	00c7ef63          	bltu	a5,a2,1a1da <memcpy+0x2c>
   1a1c0:	87aa                	mv	a5,a0
   1a1c2:	00e56963          	bltu	a0,a4,1a1d4 <memcpy+0x26>
   1a1c6:	8082                	ret
   1a1c8:	0005c683          	lbu	a3,0(a1)
   1a1cc:	0785                	addi	a5,a5,1
   1a1ce:	0585                	addi	a1,a1,1
   1a1d0:	fed78fa3          	sb	a3,-1(a5) # 1fff <_ftext-0xe001>
   1a1d4:	fee7eae3          	bltu	a5,a4,1a1c8 <memcpy+0x1a>
   1a1d8:	8082                	ret
   1a1da:	00757793          	andi	a5,a0,7
   1a1de:	ebbd                	bnez	a5,1a254 <memcpy+0xa6>
   1a1e0:	87aa                	mv	a5,a0
   1a1e2:	ff877693          	andi	a3,a4,-8
   1a1e6:	fc068613          	addi	a2,a3,-64
   1a1ea:	06c7fc63          	bleu	a2,a5,1a262 <memcpy+0xb4>
   1a1ee:	0005b383          	ld	t2,0(a1)
   1a1f2:	0085b283          	ld	t0,8(a1)
   1a1f6:	0105bf83          	ld	t6,16(a1)
   1a1fa:	0185bf03          	ld	t5,24(a1)
   1a1fe:	0205be83          	ld	t4,32(a1)
   1a202:	0285be03          	ld	t3,40(a1)
   1a206:	0305b303          	ld	t1,48(a1)
   1a20a:	0385b883          	ld	a7,56(a1)
   1a20e:	04858593          	addi	a1,a1,72
   1a212:	04878793          	addi	a5,a5,72
   1a216:	ff85b803          	ld	a6,-8(a1)
   1a21a:	fa77bc23          	sd	t2,-72(a5)
   1a21e:	fc57b023          	sd	t0,-64(a5)
   1a222:	fdf7b423          	sd	t6,-56(a5)
   1a226:	fde7b823          	sd	t5,-48(a5)
   1a22a:	fdd7bc23          	sd	t4,-40(a5)
   1a22e:	ffc7b023          	sd	t3,-32(a5)
   1a232:	fe67b423          	sd	t1,-24(a5)
   1a236:	ff17b823          	sd	a7,-16(a5)
   1a23a:	ff07bc23          	sd	a6,-8(a5)
   1a23e:	b775                	j	1a1ea <memcpy+0x3c>
   1a240:	0005c683          	lbu	a3,0(a1)
   1a244:	0785                	addi	a5,a5,1
   1a246:	0585                	addi	a1,a1,1
   1a248:	fed78fa3          	sb	a3,-1(a5)
   1a24c:	0077f693          	andi	a3,a5,7
   1a250:	fae5                	bnez	a3,1a240 <memcpy+0x92>
   1a252:	bf41                	j	1a1e2 <memcpy+0x34>
   1a254:	87aa                	mv	a5,a0
   1a256:	bfdd                	j	1a24c <memcpy+0x9e>
   1a258:	6190                	ld	a2,0(a1)
   1a25a:	07a1                	addi	a5,a5,8
   1a25c:	05a1                	addi	a1,a1,8
   1a25e:	fec7bc23          	sd	a2,-8(a5)
   1a262:	fed7ebe3          	bltu	a5,a3,1a258 <memcpy+0xaa>
   1a266:	f6e7e7e3          	bltu	a5,a4,1a1d4 <memcpy+0x26>
   1a26a:	8082                	ret
	...

000000000001a26e <memset>:
   1a26e:	483d                	li	a6,15
   1a270:	872a                	mv	a4,a0
   1a272:	02c87163          	bleu	a2,a6,1a294 <memset+0x26>
   1a276:	00f77793          	andi	a5,a4,15
   1a27a:	e3c1                	bnez	a5,1a2fa <memset+0x8c>
   1a27c:	e1bd                	bnez	a1,1a2e2 <memset+0x74>
   1a27e:	ff067693          	andi	a3,a2,-16
   1a282:	8a3d                	andi	a2,a2,15
   1a284:	96ba                	add	a3,a3,a4
   1a286:	e30c                	sd	a1,0(a4)
   1a288:	e70c                	sd	a1,8(a4)
   1a28a:	0741                	addi	a4,a4,16
   1a28c:	fed76de3          	bltu	a4,a3,1a286 <memset+0x18>
   1a290:	e211                	bnez	a2,1a294 <memset+0x26>
   1a292:	8082                	ret
   1a294:	40c806b3          	sub	a3,a6,a2
   1a298:	068a                	slli	a3,a3,0x2
   1a29a:	00000297          	auipc	t0,0x0
   1a29e:	9696                	add	a3,a3,t0
   1a2a0:	00a68067          	jr	10(a3)
   1a2a4:	00b70723          	sb	a1,14(a4) # 1000e <trap_table+0xa>
   1a2a8:	00b706a3          	sb	a1,13(a4)
   1a2ac:	00b70623          	sb	a1,12(a4)
   1a2b0:	00b705a3          	sb	a1,11(a4)
   1a2b4:	00b70523          	sb	a1,10(a4)
   1a2b8:	00b704a3          	sb	a1,9(a4)
   1a2bc:	00b70423          	sb	a1,8(a4)
   1a2c0:	00b703a3          	sb	a1,7(a4)
   1a2c4:	00b70323          	sb	a1,6(a4)
   1a2c8:	00b702a3          	sb	a1,5(a4)
   1a2cc:	00b70223          	sb	a1,4(a4)
   1a2d0:	00b701a3          	sb	a1,3(a4)
   1a2d4:	00b70123          	sb	a1,2(a4)
   1a2d8:	00b700a3          	sb	a1,1(a4)
   1a2dc:	00b70023          	sb	a1,0(a4)
   1a2e0:	8082                	ret
   1a2e2:	0ff5f593          	andi	a1,a1,255
   1a2e6:	00859693          	slli	a3,a1,0x8
   1a2ea:	8dd5                	or	a1,a1,a3
   1a2ec:	01059693          	slli	a3,a1,0x10
   1a2f0:	8dd5                	or	a1,a1,a3
   1a2f2:	02059693          	slli	a3,a1,0x20
   1a2f6:	8dd5                	or	a1,a1,a3
   1a2f8:	b759                	j	1a27e <memset+0x10>
   1a2fa:	00279693          	slli	a3,a5,0x2
   1a2fe:	00000297          	auipc	t0,0x0
   1a302:	9696                	add	a3,a3,t0
   1a304:	8286                	mv	t0,ra
   1a306:	fa2680e7          	jalr	-94(a3)
   1a30a:	8096                	mv	ra,t0
   1a30c:	17c1                	addi	a5,a5,-16
   1a30e:	8f1d                	sub	a4,a4,a5
   1a310:	963e                	add	a2,a2,a5
   1a312:	f8c871e3          	bleu	a2,a6,1a294 <memset+0x26>
   1a316:	b79d                	j	1a27c <memset+0xe>

000000000001a318 <strcmp>:
   1a318:	00b56733          	or	a4,a0,a1
   1a31c:	53fd                	li	t2,-1
   1a31e:	8b1d                	andi	a4,a4,7
   1a320:	eb4d                	bnez	a4,1a3d2 <strcmp+0xba>
   1a322:	00005e17          	auipc	t3,0x5
   1a326:	bc6e3e03          	ld	t3,-1082(t3) # 1eee8 <mask>
   1a32a:	6110                	ld	a2,0(a0)
   1a32c:	6194                	ld	a3,0(a1)
   1a32e:	01c672b3          	and	t0,a2,t3
   1a332:	01c66333          	or	t1,a2,t3
   1a336:	92f2                	add	t0,t0,t3
   1a338:	0062e2b3          	or	t0,t0,t1
   1a33c:	0a729963          	bne	t0,t2,1a3ee <strcmp+0xd6>
   1a340:	02d61e63          	bne	a2,a3,1a37c <strcmp+0x64>
   1a344:	6510                	ld	a2,8(a0)
   1a346:	6594                	ld	a3,8(a1)
   1a348:	01c672b3          	and	t0,a2,t3
   1a34c:	01c66333          	or	t1,a2,t3
   1a350:	92f2                	add	t0,t0,t3
   1a352:	0062e2b3          	or	t0,t0,t1
   1a356:	08729a63          	bne	t0,t2,1a3ea <strcmp+0xd2>
   1a35a:	02d61163          	bne	a2,a3,1a37c <strcmp+0x64>
   1a35e:	6910                	ld	a2,16(a0)
   1a360:	6994                	ld	a3,16(a1)
   1a362:	01c672b3          	and	t0,a2,t3
   1a366:	01c66333          	or	t1,a2,t3
   1a36a:	92f2                	add	t0,t0,t3
   1a36c:	0062e2b3          	or	t0,t0,t1
   1a370:	08729363          	bne	t0,t2,1a3f6 <strcmp+0xde>
   1a374:	0561                	addi	a0,a0,24
   1a376:	05e1                	addi	a1,a1,24
   1a378:	fad609e3          	beq	a2,a3,1a32a <strcmp+0x12>
   1a37c:	03061713          	slli	a4,a2,0x30
   1a380:	03069793          	slli	a5,a3,0x30
   1a384:	02f71863          	bne	a4,a5,1a3b4 <strcmp+0x9c>
   1a388:	02061713          	slli	a4,a2,0x20
   1a38c:	02069793          	slli	a5,a3,0x20
   1a390:	02f71263          	bne	a4,a5,1a3b4 <strcmp+0x9c>
   1a394:	01061713          	slli	a4,a2,0x10
   1a398:	01069793          	slli	a5,a3,0x10
   1a39c:	00f71c63          	bne	a4,a5,1a3b4 <strcmp+0x9c>
   1a3a0:	03065713          	srli	a4,a2,0x30
   1a3a4:	0306d793          	srli	a5,a3,0x30
   1a3a8:	40f70533          	sub	a0,a4,a5
   1a3ac:	0ff57593          	andi	a1,a0,255
   1a3b0:	e991                	bnez	a1,1a3c4 <strcmp+0xac>
   1a3b2:	8082                	ret
   1a3b4:	9341                	srli	a4,a4,0x30
   1a3b6:	93c1                	srli	a5,a5,0x30
   1a3b8:	40f70533          	sub	a0,a4,a5
   1a3bc:	0ff57593          	andi	a1,a0,255
   1a3c0:	e191                	bnez	a1,1a3c4 <strcmp+0xac>
   1a3c2:	8082                	ret
   1a3c4:	0ff77713          	andi	a4,a4,255
   1a3c8:	0ff7f793          	andi	a5,a5,255
   1a3cc:	40f70533          	sub	a0,a4,a5
   1a3d0:	8082                	ret
   1a3d2:	00054603          	lbu	a2,0(a0)
   1a3d6:	0005c683          	lbu	a3,0(a1)
   1a3da:	0505                	addi	a0,a0,1
   1a3dc:	0585                	addi	a1,a1,1
   1a3de:	00d61363          	bne	a2,a3,1a3e4 <strcmp+0xcc>
   1a3e2:	fa65                	bnez	a2,1a3d2 <strcmp+0xba>
   1a3e4:	40d60533          	sub	a0,a2,a3
   1a3e8:	8082                	ret
   1a3ea:	0521                	addi	a0,a0,8
   1a3ec:	05a1                	addi	a1,a1,8
   1a3ee:	fed612e3          	bne	a2,a3,1a3d2 <strcmp+0xba>
   1a3f2:	4501                	li	a0,0
   1a3f4:	8082                	ret
   1a3f6:	0541                	addi	a0,a0,16
   1a3f8:	05c1                	addi	a1,a1,16
   1a3fa:	fcd61ce3          	bne	a2,a3,1a3d2 <strcmp+0xba>
   1a3fe:	4501                	li	a0,0
   1a400:	8082                	ret

000000000001a402 <strnlen>:
   1a402:	95aa                	add	a1,a1,a0
   1a404:	87aa                	mv	a5,a0
   1a406:	00b78563          	beq	a5,a1,1a410 <strnlen+0xe>
   1a40a:	0007c703          	lbu	a4,0(a5)
   1a40e:	e701                	bnez	a4,1a416 <strnlen+0x14>
   1a410:	40a78533          	sub	a0,a5,a0
   1a414:	8082                	ret
   1a416:	0785                	addi	a5,a5,1
   1a418:	b7fd                	j	1a406 <strnlen+0x4>
	...
